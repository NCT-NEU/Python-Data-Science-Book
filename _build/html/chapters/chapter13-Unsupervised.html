
<!DOCTYPE html>


<html lang="en" data-content_root="../" >

  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>Chương 13: Học máy không giám sát &#8212; Khoa học dữ liệu trong Kinh tế và Kinh doanh</title>
  
  
  
  <script data-cfasync="false">
    document.documentElement.dataset.mode = localStorage.getItem("mode") || "";
    document.documentElement.dataset.theme = localStorage.getItem("theme") || "";
  </script>
  
  <!-- Loaded before other Sphinx assets -->
  <link href="../_static/styles/theme.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />
<link href="../_static/styles/bootstrap.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />
<link href="../_static/styles/pydata-sphinx-theme.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />

  
  <link href="../_static/vendor/fontawesome/6.5.2/css/all.min.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />
  <link rel="preload" as="font" type="font/woff2" crossorigin href="../_static/vendor/fontawesome/6.5.2/webfonts/fa-solid-900.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="../_static/vendor/fontawesome/6.5.2/webfonts/fa-brands-400.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="../_static/vendor/fontawesome/6.5.2/webfonts/fa-regular-400.woff2" />

    <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=03e43079" />
    <link rel="stylesheet" type="text/css" href="../_static/styles/sphinx-book-theme.css?v=eba8b062" />
    <link rel="stylesheet" type="text/css" href="../_static/togglebutton.css?v=13237357" />
    <link rel="stylesheet" type="text/css" href="../_static/copybutton.css?v=76b2166b" />
    <link rel="stylesheet" type="text/css" href="../_static/mystnb.4510f1fc1dee50b3e5859aac5469c37c29e427902b24a333a5f9fcb2f0b3ac41.css" />
    <link rel="stylesheet" type="text/css" href="../_static/sphinx-thebe.css?v=4fa983c6" />
    <link rel="stylesheet" type="text/css" href="../_static/sphinx-design.min.css?v=95c83b7e" />
  
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="../_static/scripts/bootstrap.js?digest=dfe6caa3a7d634c4db9b" />
<link rel="preload" as="script" href="../_static/scripts/pydata-sphinx-theme.js?digest=dfe6caa3a7d634c4db9b" />
  <script src="../_static/vendor/fontawesome/6.5.2/js/all.min.js?digest=dfe6caa3a7d634c4db9b"></script>

    <script src="../_static/documentation_options.js?v=9eb32ce0"></script>
    <script src="../_static/doctools.js?v=9a2dae69"></script>
    <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../_static/clipboard.min.js?v=a7894cd8"></script>
    <script src="../_static/copybutton.js?v=f281be69"></script>
    <script src="../_static/scripts/sphinx-book-theme.js?v=887ef09a"></script>
    <script>let toggleHintShow = 'Click to show';</script>
    <script>let toggleHintHide = 'Click to hide';</script>
    <script>let toggleOpenOnPrint = 'true';</script>
    <script src="../_static/togglebutton.js?v=4a39c7ea"></script>
    <script>var togglebuttonSelector = '.toggle, .admonition.dropdown';</script>
    <script src="../_static/design-tabs.js?v=f930bc37"></script>
    <script>const THEBE_JS_URL = "https://unpkg.com/thebe@0.8.2/lib/index.js"; const thebe_selector = ".thebe,.cell"; const thebe_selector_input = "pre"; const thebe_selector_output = ".output, .cell_output"</script>
    <script async="async" src="../_static/sphinx-thebe.js?v=c100c467"></script>
    <script>var togglebuttonSelector = '.toggle, .admonition.dropdown';</script>
    <script>const THEBE_JS_URL = "https://unpkg.com/thebe@0.8.2/lib/index.js"; const thebe_selector = ".thebe,.cell"; const thebe_selector_input = "pre"; const thebe_selector_output = ".output, .cell_output"</script>
    <script>window.MathJax = {"options": {"processHtmlClass": "tex2jax_process|mathjax_process|math|output_area"}}</script>
    <script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script>DOCUMENTATION_OPTIONS.pagename = 'chapters/chapter13-Unsupervised';</script>
    <link rel="canonical" href="https://www.tomasbeuzen.com/python-programming-for-data-science/chapters/chapter13-Unsupervised.html" />
    <link rel="icon" href="../_static/favicon2.png"/>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Python Basics" href="../practice-exercises/chapter1-basics-practice.html" />
    <link rel="prev" title="Chương 12: Các mô hình học máy có giám sát" href="chapter12-Supervised.html" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <meta name="docsearch:language" content="en"/>
  </head>
  
  
  <body data-bs-spy="scroll" data-bs-target=".bd-toc-nav" data-offset="180" data-bs-root-margin="0px 0px -60%" data-default-mode="">

  
  
  <div id="pst-skip-link" class="skip-link d-print-none"><a href="#main-content">Skip to main content</a></div>
  
  <div id="pst-scroll-pixel-helper"></div>
  
  <button type="button" class="btn rounded-pill" id="pst-back-to-top">
    <i class="fa-solid fa-arrow-up"></i>Back to top</button>

  
  <input type="checkbox"
          class="sidebar-toggle"
          id="pst-primary-sidebar-checkbox"/>
  <label class="overlay overlay-primary" for="pst-primary-sidebar-checkbox"></label>
  
  <input type="checkbox"
          class="sidebar-toggle"
          id="pst-secondary-sidebar-checkbox"/>
  <label class="overlay overlay-secondary" for="pst-secondary-sidebar-checkbox"></label>
  
  <div class="search-button__wrapper">
    <div class="search-button__overlay"></div>
    <div class="search-button__search-container">
<form class="bd-search d-flex align-items-center"
      action="../search.html"
      method="get">
  <i class="fa-solid fa-magnifying-glass"></i>
  <input type="search"
         class="form-control"
         name="q"
         id="search-input"
         placeholder="Search this book..."
         aria-label="Search this book..."
         autocomplete="off"
         autocorrect="off"
         autocapitalize="off"
         spellcheck="false"/>
  <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd>K</kbd></span>
</form></div>
  </div>

  <div class="pst-async-banner-revealer d-none">
  <aside id="bd-header-version-warning" class="d-none d-print-none" aria-label="Version warning"></aside>
</div>

  
    <header class="bd-header navbar navbar-expand-lg bd-navbar d-print-none">
    </header>
  

  <div class="bd-container">
    <div class="bd-container__inner bd-page-width">
      
      
      
      <div class="bd-sidebar-primary bd-sidebar">
        

  
  <div class="sidebar-header-items sidebar-primary__section">
    
    
    
    
  </div>
  
    <div class="sidebar-primary-items__start sidebar-primary__section">
        <div class="sidebar-primary-item">

  
    
  

<a class="navbar-brand logo" href="../README.html">
  
  
  
  
  
    
    
      
    
    
    <img src="../_static/logo.png" class="logo__image only-light" alt="Khoa học dữ liệu trong Kinh tế và Kinh doanh - Home"/>
    <script>document.write(`<img src="../_static/logo.png" class="logo__image only-dark" alt="Khoa học dữ liệu trong Kinh tế và Kinh doanh - Home"/>`);</script>
  
  
</a></div>
        <div class="sidebar-primary-item">

 <script>
 document.write(`
   <button class="btn search-button-field search-button__button" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="fa-solid fa-magnifying-glass"></i>
    <span class="search-button__default-text">Search</span>
    <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd class="kbd-shortcut__modifier">K</kbd></span>
   </button>
 `);
 </script></div>
        <div class="sidebar-primary-item"><nav class="bd-links bd-docs-nav" aria-label="Main">
    <div class="bd-toc-item navbar-nav active">
        
        <ul class="nav bd-sidenav bd-sidenav__home-link">
            <li class="toctree-l1">
                <a class="reference internal" href="../README.html">
                    Khoa học dữ liệu trong Kinh tế và Kinh doanh
                </a>
            </li>
        </ul>
        <p aria-level="2" class="caption" role="heading"><span class="caption-text">Chapters</span></p>
<ul class="current nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="gioi-thieu-ve-khoa-hoc-du-lieu.html">Chương 1: Các khái niệm cơ bản trong khoa học dữ liệu</a></li>

<li class="toctree-l1"><a class="reference internal" href="nguyen-ly-phan-tich-du-lieu.html">Chương 2: Nguyên lý của phân tích dữ liệu</a></li>
<li class="toctree-l1"><a class="reference internal" href="khung-phuong-phap-xay-dung-mo-hinh.html">Chương 3: Khung phương pháp luận trong xây dựng mô hình</a></li>
<li class="toctree-l1"><a class="reference internal" href="chapter4-basics.html">Chương 4: Python cơ bản</a></li>
<li class="toctree-l1"><a class="reference internal" href="chapter5-Numpy.html">Chương 5: Kiến thức cơ bản về NumPy</a></li>
<li class="toctree-l1"><a class="reference internal" href="chapter6-pandas.html">Chương 6: Giới thiệu về <code class="docutils literal notranslate"><span class="pre">pandas</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="chapter7-Import-data.html">Chương 7: Nhập và lưu trữ dữ liệu</a></li>
<li class="toctree-l1"><a class="reference internal" href="chapter8-prepare.html">Chương 8: Làm sạch và chuẩn bị dữ liệu</a></li>
<li class="toctree-l1"><a class="reference internal" href="chapter9-transform.html">Chương 9: Sắp xếp và biến đổi dữ liệu</a></li>
<li class="toctree-l1"><a class="reference internal" href="chapter10-visualization.html">10. Trực quan hóa dữ liệu</a></li>
<li class="toctree-l1"><a class="reference internal" href="chapter11-IntroML.html">Chương: Tổng quan về xây dựng mô hình trên dữ liệu</a></li>
<li class="toctree-l1"><a class="reference internal" href="chapter12-Supervised.html">Chương 12: Các mô hình học máy có giám sát</a></li>
<li class="toctree-l1 current active"><a class="current reference internal" href="#">Chương 13: Học máy không giám sát</a></li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">Practice Exercises</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="../practice-exercises/chapter1-basics-practice.html">Python Basics</a></li>
<li class="toctree-l1"><a class="reference internal" href="../practice-exercises/chapter2-loops-functions-practice.html">Loops &amp; Functions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../practice-exercises/chapter3-tests-classes-practice.html">Unit Tests &amp; Classes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../practice-exercises/chapter4-style-scripts-imports-practice.html">Style Guides, Scripts, Imports</a></li>
<li class="toctree-l1"><a class="reference internal" href="../practice-exercises/chapter5-numpy-practice.html">NumPy</a></li>
<li class="toctree-l1"><a class="reference internal" href="../practice-exercises/chapter7-pandas-practice.html">Pandas</a></li>
<li class="toctree-l1"><a class="reference internal" href="../practice-exercises/chapter8-wrangling-basics-practice.html">Basic Wrangling With Pandas</a></li>
<li class="toctree-l1"><a class="reference internal" href="../practice-exercises/chapter9-wrangling-advanced-practice.html">Advanced Wrangling With Pandas</a></li>
</ul>

    </div>
</nav></div>
    </div>
  
  
  <div class="sidebar-primary-items__end sidebar-primary__section">
  </div>
  
  <div id="rtd-footer-container"></div>


      </div>
      
      <main id="main-content" class="bd-main" role="main">
        
        

<div class="sbt-scroll-pixel-helper"></div>

          <div class="bd-content">
            <div class="bd-article-container">
              
              <div class="bd-header-article d-print-none">
<div class="header-article-items header-article__inner">
  
    <div class="header-article-items__start">
      
        <div class="header-article-item"><button class="sidebar-toggle primary-toggle btn btn-sm" title="Toggle primary sidebar" data-bs-placement="bottom" data-bs-toggle="tooltip">
  <span class="fa-solid fa-bars"></span>
</button></div>
      
    </div>
  
  
    <div class="header-article-items__end">
      
        <div class="header-article-item">

<div class="article-header-buttons">


<a href="https://github.com/TomasBeuzen/python-programming-for-data-science" target="_blank"
   class="btn btn-sm btn-source-repository-button"
   title="Source repository"
   data-bs-placement="bottom" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fab fa-github"></i>
  </span>

</a>






<div class="dropdown dropdown-download-buttons">
  <button class="btn dropdown-toggle" type="button" data-bs-toggle="dropdown" aria-expanded="false" aria-label="Download this page">
    <i class="fas fa-download"></i>
  </button>
  <ul class="dropdown-menu">
      
      
      
      <li><a href="../_sources/chapters/chapter13-Unsupervised.ipynb" target="_blank"
   class="btn btn-sm btn-download-source-button dropdown-item"
   title="Download source file"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-file"></i>
  </span>
<span class="btn__text-container">.ipynb</span>
</a>
</li>
      
      
      
      
      <li>
<button onclick="window.print()"
  class="btn btn-sm btn-download-pdf-button dropdown-item"
  title="Print to PDF"
  data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-file-pdf"></i>
  </span>
<span class="btn__text-container">.pdf</span>
</button>
</li>
      
  </ul>
</div>




<button onclick="toggleFullScreen()"
  class="btn btn-sm btn-fullscreen-button"
  title="Fullscreen mode"
  data-bs-placement="bottom" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-expand"></i>
  </span>

</button>



<script>
document.write(`
  <button class="btn btn-sm nav-link pst-navbar-icon theme-switch-button" title="light/dark" aria-label="light/dark" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="theme-switch fa-solid fa-sun fa-lg" data-mode="light"></i>
    <i class="theme-switch fa-solid fa-moon fa-lg" data-mode="dark"></i>
    <i class="theme-switch fa-solid fa-circle-half-stroke fa-lg" data-mode="auto"></i>
  </button>
`);
</script>


<script>
document.write(`
  <button class="btn btn-sm pst-navbar-icon search-button search-button__button" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="fa-solid fa-magnifying-glass fa-lg"></i>
  </button>
`);
</script>
<button class="sidebar-toggle secondary-toggle btn btn-sm" title="Toggle secondary sidebar" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <span class="fa-solid fa-list"></span>
</button>
</div></div>
      
    </div>
  
</div>
</div>
              
              

<div id="jb-print-docs-body" class="onlyprint">
    <h1>Chương 13: Học máy không giám sát</h1>
    <!-- Table of contents -->
    <div id="print-main-content">
        <div id="jb-print-toc">
            
            <div>
                <h2> Contents </h2>
            </div>
            <nav aria-label="Page">
                <ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#cac-loai-hoc-khong-giam-sat">Các loại Học không giám sát</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#nhung-thach-thuc-trong-hoc-khong-giam-sat">Những thách thức trong Học không giám sát</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#tien-xu-ly-va-co-gian-du-lieu">Tiền xử lý và Co giãn dữ liệu</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#cac-loai-tien-xu-ly-khac-nhau">Các loại Tiền xử lý khác nhau</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#ap-dung-cac-phep-bien-doi-du-lieu">Áp dụng các Phép biến đổi Dữ liệu</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#co-gian-du-lieu-huan-luyen-va-kiem-tra-theo-cung-mot-cach">Co giãn Dữ liệu Huấn luyện và Kiểm tra theo cùng một cách</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#cac-phuong-phap-tat-va-cac-lua-chon-thay-the-hieu-qua">Các phương pháp tắt và các lựa chọn thay thế hiệu quả</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#anh-huong-cua-tien-xu-ly-den-hoc-co-giam-sat">Ảnh hưởng của Tiền xử lý đến Học có giám sát</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#giam-chieu-trich-xuat-dac-trung-va-hoc-da-tap-manifold-learning">Giảm chiều, Trích xuất Đặc trưng, và Học Đa tạp (Manifold Learning)</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#phan-tich-thanh-phan-chinh-pca">Phân tích Thành phần Chính (PCA)</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#ap-dung-pca-cho-tap-du-lieu-ung-thu-de-truc-quan-hoa">Áp dụng PCA cho tập dữ liệu ung thư để trực quan hóa</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#cac-khuon-mat-dac-trung-eigenfaces-de-trich-xuat-dac-trung">Các khuôn mặt đặc trưng (Eigenfaces) để trích xuất đặc trưng</a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#phan-ra-ma-tran-khong-am-nmf">Phân rã Ma trận không âm (NMF)</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#ap-dung-nmf-cho-du-lieu-tong-hop">Áp dụng NMF cho dữ liệu tổng hợp</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#ap-dung-nmf-cho-hinh-anh-khuon-mat">Áp dụng NMF cho hình ảnh khuôn mặt</a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#hoc-da-tap-manifold-learning-voi-t-sne">Học Đa tạp (Manifold Learning) với t-SNE</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#phan-cum">Phân cụm</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#phan-cum-k-means">Phân cụm k-Means</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#cac-truong-hop-that-bai-cua-k-means">Các trường hợp thất bại của k-means</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#luong-tu-hoa-vector-hay-xem-k-means-nhu-la-mot-phuong-phap-phan-ra">Lượng tử hóa vector, hay xem k-means như là một phương pháp phân rã</a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#phan-cum-gop-agglomerative-clustering">Phân cụm Gộp (Agglomerative Clustering)</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#phan-cum-phan-cap-va-bieu-do-cay-dendrogram">Phân cụm phân cấp và biểu đồ cây (dendrogram)</a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#dbscan">DBSCAN</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#so-sanh-va-danh-gia-cac-thuat-toan-phan-cum">So sánh và Đánh giá các Thuật toán Phân cụm</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#danh-gia-phan-cum-voi-su-that-ngam-dinh-ground-truth">Đánh giá phân cụm với sự thật ngầm định (ground truth)</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#danh-gia-phan-cum-khong-co-su-that-ngam-dinh-ground-truth">Đánh giá phân cụm không có sự thật ngầm định (ground truth)</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#so-sanh-cac-thuat-toan-tren-tap-du-lieu-khuon-mat">So sánh các thuật toán trên tập dữ liệu khuôn mặt</a><ul class="nav section-nav flex-column">
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#phan-tich-tap-du-lieu-khuon-mat-voi-dbscan">Phân tích tập dữ liệu khuôn mặt với DBSCAN</a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#phan-tich-tap-du-lieu-khuon-mat-voi-k-means">Phân tích tập dữ liệu khuôn mặt với k-means</a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#phan-tich-tap-du-lieu-khuon-mat-voi-phan-cum-gop">Phân tích tập dữ liệu khuôn mặt với phân cụm gộp</a></li>
</ul>
</li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#tom-tat-cac-phuong-phap-phan-cum">Tóm tắt các Phương pháp Phân cụm</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#tom-tat-va-trien-vong">Tóm tắt và Triển vọng</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#tom-tat-giao-dien-estimator">Tóm tắt Giao diện Estimator</a></li>
</ul>
</li>
</ul>
            </nav>
        </div>
    </div>
</div>

              
                
<div id="searchbox"></div>
                <article class="bd-article">
                  
  <section class="tex2jax_ignore mathjax_ignore" id="chuong-13-hoc-may-khong-giam-sat">
<h1>Chương 13: Học máy không giám sát<a class="headerlink" href="#chuong-13-hoc-may-khong-giam-sat" title="Link to this heading">#</a></h1>
<hr><p>Họ giải thuật học máy thứ hai mà chúng ta sẽ thảo luận là các giải thuật học không giám sát.  Học không giám sát bao gồm tất cả các loại học máy mà không có đầu ra đã biết, không có “người thầy” để hướng dẫn giải thuật học.  Trong học không giám sát, giải thuật học chỉ được cung cấp dữ liệu đầu vào và được yêu cầu trích xuất kiến thức từ dữ liệu này.</p>
<section id="cac-loai-hoc-khong-giam-sat">
<h2>Các loại Học không giám sát<a class="headerlink" href="#cac-loai-hoc-khong-giam-sat" title="Link to this heading">#</a></h2>
<p>Chúng ta sẽ xem xét hai loại học không giám sát trong chương này: các phép biến đổi của tập dữ liệu và phân cụm.</p>
<p>Các phép biến đổi không giám sát của một tập dữ liệu là các giải thuật tạo ra một biểu diễn mới của dữ liệu có thể dễ hiểu hơn cho con người hoặc các giải thuật học máy khác so với biểu diễn ban đầu của dữ liệu.  Một ứng dụng phổ biến của các phép biến đổi không giám sát là giảm chiều dữ liệu, nhận một biểu diễn chiều cao của dữ liệu, bao gồm nhiều đặc trưng, và tìm một cách mới để biểu diễn dữ liệu này mà tóm tắt các đặc tính thiết yếu với ít đặc trưng hơn.  Một ứng dụng phổ biến của giảm chiều dữ liệu là giảm xuống hai chiều cho mục đích trực quan hóa.</p>
<p>Một ứng dụng khác cho các phép biến đổi không giám sát là tìm ra các phần hoặc thành phần “tạo nên” dữ liệu.  Một ví dụ về điều này là trích xuất chủ đề trên các bộ sưu tập tài liệu văn bản.  Ở đây, nhiệm vụ là tìm các chủ đề chưa biết được nói đến trong mỗi tài liệu, và tìm hiểu những chủ đề nào xuất hiện trong mỗi tài liệu.  Điều này có thể hữu ích để theo dõi các cuộc thảo luận về các chủ đề như bầu cử, kiểm soát súng, hoặc các ngôi sao nhạc pop trên mạng xã hội.</p>
<p>Mặt khác, các giải thuật phân cụm, phân chia dữ liệu thành các nhóm riêng biệt gồm các mục tương tự.  Hãy xem xét ví dụ về việc tải ảnh lên một trang mạng xã hội.  Để cho phép bạn tổ chức ảnh của mình, trang web có thể muốn nhóm các bức ảnh có cùng một người lại với nhau.  Tuy nhiên, trang web không biết bức ảnh nào có ai, và nó không biết có bao nhiêu người khác nhau xuất hiện trong bộ sưu tập ảnh của bạn.  Một phương pháp hợp lý là trích xuất tất cả các khuôn mặt và chia chúng thành các nhóm khuôn mặt trông giống nhau.  Hy vọng rằng, những nhóm này tương ứng với cùng một người, và các hình ảnh có thể được nhóm lại với nhau cho bạn.</p>
</section>
<section id="nhung-thach-thuc-trong-hoc-khong-giam-sat">
<h2>Những thách thức trong Học không giám sát<a class="headerlink" href="#nhung-thach-thuc-trong-hoc-khong-giam-sat" title="Link to this heading">#</a></h2>
<p>Một thách thức lớn trong học không giám sát là đánh giá xem giải thuật có học được điều gì hữu ích hay không.  Các giải thuật học không giám sát thường được áp dụng cho dữ liệu không chứa bất kỳ thông tin nhãn nào, vì vậy chúng ta không biết đầu ra đúng phải là gì.  Do đó, rất khó để nói liệu một mô hình có “làm tốt” hay không.  Ví dụ, giải thuật phân cụm giả định của chúng ta có thể đã nhóm tất cả các bức ảnh chụp khuôn mặt nhìn nghiêng và tất cả các bức ảnh chụp toàn mặt lại với nhau.  Đây chắc chắn sẽ là một cách khả thi để phân chia một bộ sưu tập ảnh chụp khuôn mặt người, nhưng đó không phải là cách chúng ta đang tìm kiếm.  Tuy nhiên, không có cách nào để chúng ta “chỉ” cho giải thuật biết chúng ta đang tìm kiếm điều gì, và thường cách duy nhất để đánh giá kết quả của một giải thuật không giám sát là kiểm tra thủ công.</p>
<p>Do đó, các giải thuật không giám sát thường được sử dụng trong một môi trường khám phá, khi một nhà khoa học dữ liệu muốn hiểu rõ hơn về dữ liệu, thay vì là một phần của một hệ thống tự động lớn hơn.  Một ứng dụng phổ biến khác cho các giải thuật không giám sát là làm một bước tiền xử lý cho các giải thuật có giám sát.  Học một biểu diễn mới của dữ liệu đôi khi có thể cải thiện độ chính xác của các giải thuật có giám sát, hoặc có thể dẫn đến giảm mức tiêu thụ bộ nhớ và thời gian.</p>
<p>Trước khi chúng ta bắt đầu với các giải thuật không giám sát “thực sự”, chúng ta sẽ thảo luận ngắn gọn về một số phương pháp tiền xử lý đơn giản thường hữu ích.  Mặc dù tiền xử lý và co giãn dữ liệu thường được sử dụng cùng với các giải thuật học có giám sát, các phương pháp co giãn không sử dụng thông tin có giám sát, khiến chúng trở thành không giám sát.</p>
</section>
<section id="tien-xu-ly-va-co-gian-du-lieu">
<h2>Tiền xử lý và Co giãn dữ liệu<a class="headerlink" href="#tien-xu-ly-va-co-gian-du-lieu" title="Link to this heading">#</a></h2>
<p>Trong chương trước, chúng ta đã thấy rằng một số giải thuật, như mạng nơ-ron và SVM, rất nhạy cảm với việc co giãn dữ liệu.  Do đó, một thực hành phổ biến là điều chỉnh các đặc trưng sao cho biểu diễn dữ liệu phù hợp hơn với các giải thuật này.  Thường thì, đây là một phép co giãn và dịch chuyển đơn giản trên từng đặc trưng của dữ liệu.  Đoạn mã sau (Hình 3-1) cho thấy một ví dụ đơn giản:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span><span class="w"> </span><span class="nn">mglearn</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">matplotlib.pyplot</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">plt</span>

<span class="n">mglearn</span><span class="o">.</span><span class="n">plots</span><span class="o">.</span><span class="n">plot_scaling</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../_images/7b96b99e451fdff44a981d514b20a6ad2e205755381193907138207a8977d5cc.png" src="../_images/7b96b99e451fdff44a981d514b20a6ad2e205755381193907138207a8977d5cc.png" />
</div>
</div>
<p><strong>Hình 3-1. Các cách khác nhau để co giãn và tiền xử lý một tập dữ liệu</strong></p>
<section id="cac-loai-tien-xu-ly-khac-nhau">
<h3>Các loại Tiền xử lý khác nhau<a class="headerlink" href="#cac-loai-tien-xu-ly-khac-nhau" title="Link to this heading">#</a></h3>
<p>Biểu đồ đầu tiên trong Hình 3-1 cho thấy một tập dữ liệu phân loại hai lớp tổng hợp với hai đặc trưng.  Đặc trưng thứ nhất (giá trị trục x) nằm trong khoảng từ 10 đến 15.  Đặc trưng thứ hai (giá trị trục y) nằm trong khoảng từ 1 đến 9.</p>
<p>Bốn biểu đồ sau cho thấy bốn cách khác nhau để biến đổi dữ liệu nhằm tạo ra các phạm vi tiêu chuẩn hơn.  <code class="docutils literal notranslate"><span class="pre">StandardScaler</span></code> trong scikit-learn đảm bảo rằng đối với mỗi đặc trưng, trung bình là 0 và phương sai là 1, đưa tất cả các đặc trưng về cùng một độ lớn.  Tuy nhiên, phép co giãn này không đảm bảo bất kỳ giá trị tối thiểu và tối đa cụ thể nào cho các đặc trưng.  <code class="docutils literal notranslate"><span class="pre">RobustScaler</span></code> hoạt động tương tự như <code class="docutils literal notranslate"><span class="pre">StandardScaler</span></code> ở chỗ nó đảm bảo các thuộc tính thống kê cho mỗi đặc trưng để chúng ở trên cùng một thang đo.  Tuy nhiên, <code class="docutils literal notranslate"><span class="pre">RobustScaler</span></code> sử dụng trung vị và tứ phân vị¹, thay vì trung bình và phương sai.  Điều này làm cho <code class="docutils literal notranslate"><span class="pre">RobustScaler</span></code> bỏ qua các điểm dữ liệu rất khác biệt so với phần còn lại (như lỗi đo lường).  Những điểm dữ liệu kỳ lạ này còn được gọi là các điểm ngoại lai, và có thể gây ra rắc rối cho các kỹ thuật co giãn khác.</p>
<p><code class="docutils literal notranslate"><span class="pre">MinMaxScaler</span></code>, mặt khác, dịch chuyển dữ liệu sao cho tất cả các đặc trưng đều nằm chính xác trong khoảng từ 0 đến 1.  Đối với tập dữ liệu hai chiều, điều này có nghĩa là tất cả dữ liệu được chứa trong hình chữ nhật được tạo bởi trục x từ 0 đến 1 và trục y từ 0 đến 1.</p>
<p>Cuối cùng, <code class="docutils literal notranslate"><span class="pre">Normalizer</span></code> thực hiện một loại co giãn rất khác.  Nó co giãn mỗi điểm dữ liệu sao cho vectơ đặc trưng có độ dài Euclid là 1.  Nói cách khác, nó chiếu một điểm dữ liệu lên vòng tròn (hoặc hình cầu, trong trường hợp nhiều chiều hơn) với bán kính là 1.  Điều này có nghĩa là mỗi điểm dữ liệu được co giãn bởi một số khác nhau (bằng nghịch đảo của độ dài của nó).  Phép chuẩn hóa này thường được sử dụng khi chỉ có hướng (hoặc góc) của dữ liệu là quan trọng, chứ không phải độ dài của vectơ đặc trưng.</p>
<hr class="docutils" />
<p>¹ Trung vị của một tập hợp các số là số x sao cho một nửa số các số nhỏ hơn x và một nửa số các số lớn hơn x.  Tứ phân vị dưới là số x sao cho một phần tư số các số nhỏ hơn x, và tứ phân vị trên là số x sao cho một phần tư số các số lớn hơn x.</p>
</section>
<section id="ap-dung-cac-phep-bien-doi-du-lieu">
<h3>Áp dụng các Phép biến đổi Dữ liệu<a class="headerlink" href="#ap-dung-cac-phep-bien-doi-du-lieu" title="Link to this heading">#</a></h3>
<p>Bây giờ chúng ta đã thấy các loại biến đổi khác nhau làm gì, hãy áp dụng chúng bằng scikit-learn.  Chúng ta sẽ sử dụng tập dữ liệu ung thư mà chúng ta đã thấy trong Chương 2.  Các phương pháp tiền xử lý như các scaler thường được áp dụng trước khi áp dụng một giải thuật học máy có giám sát.  Ví dụ, giả sử chúng ta muốn áp dụng kernel SVM (<code class="docutils literal notranslate"><span class="pre">SVC</span></code>) cho tập dữ liệu ung thư, và sử dụng <code class="docutils literal notranslate"><span class="pre">MinMaxScaler</span></code> để tiền xử lý dữ liệu.  Chúng ta bắt đầu bằng cách tải tập dữ liệu và chia nó thành một tập huấn luyện và một tập kiểm tra (chúng ta cần các tập huấn luyện và kiểm tra riêng biệt để đánh giá mô hình có giám sát mà chúng ta sẽ xây dựng sau khi tiền xử lý):</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span><span class="w"> </span><span class="nn">sklearn.datasets</span><span class="w"> </span><span class="kn">import</span> <span class="n">load_breast_cancer</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">sklearn.model_selection</span><span class="w"> </span><span class="kn">import</span> <span class="n">train_test_split</span>

<span class="n">cancer</span> <span class="o">=</span> <span class="n">load_breast_cancer</span><span class="p">()</span>

<span class="n">X_train</span><span class="p">,</span> <span class="n">X_test</span><span class="p">,</span> <span class="n">y_train</span><span class="p">,</span> <span class="n">y_test</span> <span class="o">=</span> <span class="n">train_test_split</span><span class="p">(</span><span class="n">cancer</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">cancer</span><span class="o">.</span><span class="n">target</span><span class="p">,</span>
                                                    <span class="n">random_state</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">X_train</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">X_test</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>(426, 30)
(143, 30)
</pre></div>
</div>
</div>
</div>
<p>Để nhắc lại, tập dữ liệu chứa 569 điểm dữ liệu, mỗi điểm được biểu diễn bởi 30 phép đo.  Chúng ta đã chia tập dữ liệu thành 426 mẫu cho tập huấn luyện và 143 mẫu cho tập kiểm tra.</p>
<p>Giống như các mô hình có giám sát mà chúng ta đã xây dựng trước đó, trước tiên chúng ta nhập lớp triển khai tiền xử lý, sau đó khởi tạo nó:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span><span class="w"> </span><span class="nn">sklearn.preprocessing</span><span class="w"> </span><span class="kn">import</span> <span class="n">MinMaxScaler</span>

<span class="n">scaler</span> <span class="o">=</span> <span class="n">MinMaxScaler</span><span class="p">()</span>
</pre></div>
</div>
</div>
</div>
<p>Sau đó, chúng ta khớp scaler bằng phương thức <code class="docutils literal notranslate"><span class="pre">fit</span></code>, áp dụng trên dữ liệu huấn luyện.  Đối với <code class="docutils literal notranslate"><span class="pre">MinMaxScaler</span></code>, phương thức <code class="docutils literal notranslate"><span class="pre">fit</span></code> tính toán giá trị tối thiểu và tối đa của mỗi đặc trưng trên tập huấn luyện.  Trái ngược với các bộ phân loại và hồi quy của Chương 2, scaler chỉ được cung cấp dữ liệu (<code class="docutils literal notranslate"><span class="pre">X_train</span></code>) khi <code class="docutils literal notranslate"><span class="pre">fit</span></code> được gọi, và <code class="docutils literal notranslate"><span class="pre">y_train</span></code> không được sử dụng:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">scaler</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X_train</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_html"><style>#sk-container-id-1 {
  /* Definition of color scheme common for light and dark mode */
  --sklearn-color-text: #000;
  --sklearn-color-text-muted: #666;
  --sklearn-color-line: gray;
  /* Definition of color scheme for unfitted estimators */
  --sklearn-color-unfitted-level-0: #fff5e6;
  --sklearn-color-unfitted-level-1: #f6e4d2;
  --sklearn-color-unfitted-level-2: #ffe0b3;
  --sklearn-color-unfitted-level-3: chocolate;
  /* Definition of color scheme for fitted estimators */
  --sklearn-color-fitted-level-0: #f0f8ff;
  --sklearn-color-fitted-level-1: #d4ebff;
  --sklearn-color-fitted-level-2: #b3dbfd;
  --sklearn-color-fitted-level-3: cornflowerblue;

  /* Specific color for light theme */
  --sklearn-color-text-on-default-background: var(--sg-text-color, var(--theme-code-foreground, var(--jp-content-font-color1, black)));
  --sklearn-color-background: var(--sg-background-color, var(--theme-background, var(--jp-layout-color0, white)));
  --sklearn-color-border-box: var(--sg-text-color, var(--theme-code-foreground, var(--jp-content-font-color1, black)));
  --sklearn-color-icon: #696969;

  @media (prefers-color-scheme: dark) {
    /* Redefinition of color scheme for dark theme */
    --sklearn-color-text-on-default-background: var(--sg-text-color, var(--theme-code-foreground, var(--jp-content-font-color1, white)));
    --sklearn-color-background: var(--sg-background-color, var(--theme-background, var(--jp-layout-color0, #111)));
    --sklearn-color-border-box: var(--sg-text-color, var(--theme-code-foreground, var(--jp-content-font-color1, white)));
    --sklearn-color-icon: #878787;
  }
}

#sk-container-id-1 {
  color: var(--sklearn-color-text);
}

#sk-container-id-1 pre {
  padding: 0;
}

#sk-container-id-1 input.sk-hidden--visually {
  border: 0;
  clip: rect(1px 1px 1px 1px);
  clip: rect(1px, 1px, 1px, 1px);
  height: 1px;
  margin: -1px;
  overflow: hidden;
  padding: 0;
  position: absolute;
  width: 1px;
}

#sk-container-id-1 div.sk-dashed-wrapped {
  border: 1px dashed var(--sklearn-color-line);
  margin: 0 0.4em 0.5em 0.4em;
  box-sizing: border-box;
  padding-bottom: 0.4em;
  background-color: var(--sklearn-color-background);
}

#sk-container-id-1 div.sk-container {
  /* jupyter's `normalize.less` sets `[hidden] { display: none; }`
     but bootstrap.min.css set `[hidden] { display: none !important; }`
     so we also need the `!important` here to be able to override the
     default hidden behavior on the sphinx rendered scikit-learn.org.
     See: https://github.com/scikit-learn/scikit-learn/issues/21755 */
  display: inline-block !important;
  position: relative;
}

#sk-container-id-1 div.sk-text-repr-fallback {
  display: none;
}

div.sk-parallel-item,
div.sk-serial,
div.sk-item {
  /* draw centered vertical line to link estimators */
  background-image: linear-gradient(var(--sklearn-color-text-on-default-background), var(--sklearn-color-text-on-default-background));
  background-size: 2px 100%;
  background-repeat: no-repeat;
  background-position: center center;
}

/* Parallel-specific style estimator block */

#sk-container-id-1 div.sk-parallel-item::after {
  content: "";
  width: 100%;
  border-bottom: 2px solid var(--sklearn-color-text-on-default-background);
  flex-grow: 1;
}

#sk-container-id-1 div.sk-parallel {
  display: flex;
  align-items: stretch;
  justify-content: center;
  background-color: var(--sklearn-color-background);
  position: relative;
}

#sk-container-id-1 div.sk-parallel-item {
  display: flex;
  flex-direction: column;
}

#sk-container-id-1 div.sk-parallel-item:first-child::after {
  align-self: flex-end;
  width: 50%;
}

#sk-container-id-1 div.sk-parallel-item:last-child::after {
  align-self: flex-start;
  width: 50%;
}

#sk-container-id-1 div.sk-parallel-item:only-child::after {
  width: 0;
}

/* Serial-specific style estimator block */

#sk-container-id-1 div.sk-serial {
  display: flex;
  flex-direction: column;
  align-items: center;
  background-color: var(--sklearn-color-background);
  padding-right: 1em;
  padding-left: 1em;
}


/* Toggleable style: style used for estimator/Pipeline/ColumnTransformer box that is
clickable and can be expanded/collapsed.
- Pipeline and ColumnTransformer use this feature and define the default style
- Estimators will overwrite some part of the style using the `sk-estimator` class
*/

/* Pipeline and ColumnTransformer style (default) */

#sk-container-id-1 div.sk-toggleable {
  /* Default theme specific background. It is overwritten whether we have a
  specific estimator or a Pipeline/ColumnTransformer */
  background-color: var(--sklearn-color-background);
}

/* Toggleable label */
#sk-container-id-1 label.sk-toggleable__label {
  cursor: pointer;
  display: flex;
  width: 100%;
  margin-bottom: 0;
  padding: 0.5em;
  box-sizing: border-box;
  text-align: center;
  align-items: start;
  justify-content: space-between;
  gap: 0.5em;
}

#sk-container-id-1 label.sk-toggleable__label .caption {
  font-size: 0.6rem;
  font-weight: lighter;
  color: var(--sklearn-color-text-muted);
}

#sk-container-id-1 label.sk-toggleable__label-arrow:before {
  /* Arrow on the left of the label */
  content: "▸";
  float: left;
  margin-right: 0.25em;
  color: var(--sklearn-color-icon);
}

#sk-container-id-1 label.sk-toggleable__label-arrow:hover:before {
  color: var(--sklearn-color-text);
}

/* Toggleable content - dropdown */

#sk-container-id-1 div.sk-toggleable__content {
  max-height: 0;
  max-width: 0;
  overflow: hidden;
  text-align: left;
  /* unfitted */
  background-color: var(--sklearn-color-unfitted-level-0);
}

#sk-container-id-1 div.sk-toggleable__content.fitted {
  /* fitted */
  background-color: var(--sklearn-color-fitted-level-0);
}

#sk-container-id-1 div.sk-toggleable__content pre {
  margin: 0.2em;
  border-radius: 0.25em;
  color: var(--sklearn-color-text);
  /* unfitted */
  background-color: var(--sklearn-color-unfitted-level-0);
}

#sk-container-id-1 div.sk-toggleable__content.fitted pre {
  /* unfitted */
  background-color: var(--sklearn-color-fitted-level-0);
}

#sk-container-id-1 input.sk-toggleable__control:checked~div.sk-toggleable__content {
  /* Expand drop-down */
  max-height: 200px;
  max-width: 100%;
  overflow: auto;
}

#sk-container-id-1 input.sk-toggleable__control:checked~label.sk-toggleable__label-arrow:before {
  content: "▾";
}

/* Pipeline/ColumnTransformer-specific style */

#sk-container-id-1 div.sk-label input.sk-toggleable__control:checked~label.sk-toggleable__label {
  color: var(--sklearn-color-text);
  background-color: var(--sklearn-color-unfitted-level-2);
}

#sk-container-id-1 div.sk-label.fitted input.sk-toggleable__control:checked~label.sk-toggleable__label {
  background-color: var(--sklearn-color-fitted-level-2);
}

/* Estimator-specific style */

/* Colorize estimator box */
#sk-container-id-1 div.sk-estimator input.sk-toggleable__control:checked~label.sk-toggleable__label {
  /* unfitted */
  background-color: var(--sklearn-color-unfitted-level-2);
}

#sk-container-id-1 div.sk-estimator.fitted input.sk-toggleable__control:checked~label.sk-toggleable__label {
  /* fitted */
  background-color: var(--sklearn-color-fitted-level-2);
}

#sk-container-id-1 div.sk-label label.sk-toggleable__label,
#sk-container-id-1 div.sk-label label {
  /* The background is the default theme color */
  color: var(--sklearn-color-text-on-default-background);
}

/* On hover, darken the color of the background */
#sk-container-id-1 div.sk-label:hover label.sk-toggleable__label {
  color: var(--sklearn-color-text);
  background-color: var(--sklearn-color-unfitted-level-2);
}

/* Label box, darken color on hover, fitted */
#sk-container-id-1 div.sk-label.fitted:hover label.sk-toggleable__label.fitted {
  color: var(--sklearn-color-text);
  background-color: var(--sklearn-color-fitted-level-2);
}

/* Estimator label */

#sk-container-id-1 div.sk-label label {
  font-family: monospace;
  font-weight: bold;
  display: inline-block;
  line-height: 1.2em;
}

#sk-container-id-1 div.sk-label-container {
  text-align: center;
}

/* Estimator-specific */
#sk-container-id-1 div.sk-estimator {
  font-family: monospace;
  border: 1px dotted var(--sklearn-color-border-box);
  border-radius: 0.25em;
  box-sizing: border-box;
  margin-bottom: 0.5em;
  /* unfitted */
  background-color: var(--sklearn-color-unfitted-level-0);
}

#sk-container-id-1 div.sk-estimator.fitted {
  /* fitted */
  background-color: var(--sklearn-color-fitted-level-0);
}

/* on hover */
#sk-container-id-1 div.sk-estimator:hover {
  /* unfitted */
  background-color: var(--sklearn-color-unfitted-level-2);
}

#sk-container-id-1 div.sk-estimator.fitted:hover {
  /* fitted */
  background-color: var(--sklearn-color-fitted-level-2);
}

/* Specification for estimator info (e.g. "i" and "?") */

/* Common style for "i" and "?" */

.sk-estimator-doc-link,
a:link.sk-estimator-doc-link,
a:visited.sk-estimator-doc-link {
  float: right;
  font-size: smaller;
  line-height: 1em;
  font-family: monospace;
  background-color: var(--sklearn-color-background);
  border-radius: 1em;
  height: 1em;
  width: 1em;
  text-decoration: none !important;
  margin-left: 0.5em;
  text-align: center;
  /* unfitted */
  border: var(--sklearn-color-unfitted-level-1) 1pt solid;
  color: var(--sklearn-color-unfitted-level-1);
}

.sk-estimator-doc-link.fitted,
a:link.sk-estimator-doc-link.fitted,
a:visited.sk-estimator-doc-link.fitted {
  /* fitted */
  border: var(--sklearn-color-fitted-level-1) 1pt solid;
  color: var(--sklearn-color-fitted-level-1);
}

/* On hover */
div.sk-estimator:hover .sk-estimator-doc-link:hover,
.sk-estimator-doc-link:hover,
div.sk-label-container:hover .sk-estimator-doc-link:hover,
.sk-estimator-doc-link:hover {
  /* unfitted */
  background-color: var(--sklearn-color-unfitted-level-3);
  color: var(--sklearn-color-background);
  text-decoration: none;
}

div.sk-estimator.fitted:hover .sk-estimator-doc-link.fitted:hover,
.sk-estimator-doc-link.fitted:hover,
div.sk-label-container:hover .sk-estimator-doc-link.fitted:hover,
.sk-estimator-doc-link.fitted:hover {
  /* fitted */
  background-color: var(--sklearn-color-fitted-level-3);
  color: var(--sklearn-color-background);
  text-decoration: none;
}

/* Span, style for the box shown on hovering the info icon */
.sk-estimator-doc-link span {
  display: none;
  z-index: 9999;
  position: relative;
  font-weight: normal;
  right: .2ex;
  padding: .5ex;
  margin: .5ex;
  width: min-content;
  min-width: 20ex;
  max-width: 50ex;
  color: var(--sklearn-color-text);
  box-shadow: 2pt 2pt 4pt #999;
  /* unfitted */
  background: var(--sklearn-color-unfitted-level-0);
  border: .5pt solid var(--sklearn-color-unfitted-level-3);
}

.sk-estimator-doc-link.fitted span {
  /* fitted */
  background: var(--sklearn-color-fitted-level-0);
  border: var(--sklearn-color-fitted-level-3);
}

.sk-estimator-doc-link:hover span {
  display: block;
}

/* "?"-specific style due to the `<a>` HTML tag */

#sk-container-id-1 a.estimator_doc_link {
  float: right;
  font-size: 1rem;
  line-height: 1em;
  font-family: monospace;
  background-color: var(--sklearn-color-background);
  border-radius: 1rem;
  height: 1rem;
  width: 1rem;
  text-decoration: none;
  /* unfitted */
  color: var(--sklearn-color-unfitted-level-1);
  border: var(--sklearn-color-unfitted-level-1) 1pt solid;
}

#sk-container-id-1 a.estimator_doc_link.fitted {
  /* fitted */
  border: var(--sklearn-color-fitted-level-1) 1pt solid;
  color: var(--sklearn-color-fitted-level-1);
}

/* On hover */
#sk-container-id-1 a.estimator_doc_link:hover {
  /* unfitted */
  background-color: var(--sklearn-color-unfitted-level-3);
  color: var(--sklearn-color-background);
  text-decoration: none;
}

#sk-container-id-1 a.estimator_doc_link.fitted:hover {
  /* fitted */
  background-color: var(--sklearn-color-fitted-level-3);
}
</style><div id="sk-container-id-1" class="sk-top-container"><div class="sk-text-repr-fallback"><pre>MinMaxScaler()</pre><b>In a Jupyter environment, please rerun this cell to show the HTML representation or trust the notebook. <br />On GitHub, the HTML representation is unable to render, please try loading this page with nbviewer.org.</b></div><div class="sk-container" hidden><div class="sk-item"><div class="sk-estimator fitted sk-toggleable"><input class="sk-toggleable__control sk-hidden--visually" id="sk-estimator-id-1" type="checkbox" checked><label for="sk-estimator-id-1" class="sk-toggleable__label fitted sk-toggleable__label-arrow"><div><div>MinMaxScaler</div></div><div><a class="sk-estimator-doc-link fitted" rel="noreferrer" target="_blank" href="https://scikit-learn.org/1.6/modules/generated/sklearn.preprocessing.MinMaxScaler.html">?<span>Documentation for MinMaxScaler</span></a><span class="sk-estimator-doc-link fitted">i<span>Fitted</span></span></div></label><div class="sk-toggleable__content fitted"><pre>MinMaxScaler()</pre></div> </div></div></div></div></div></div>
</div>
<p>Để áp dụng phép biến đổi mà chúng ta vừa học—tức là, để thực sự co giãn dữ liệu huấn luyện—chúng ta sử dụng phương thức <code class="docutils literal notranslate"><span class="pre">transform</span></code> của scaler.  Phương thức <code class="docutils literal notranslate"><span class="pre">transform</span></code> được sử dụng trong scikit-learn bất cứ khi nào một mô hình trả về một biểu diễn mới của dữ liệu:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>

<span class="c1"># biến đổi dữ liệu</span>
<span class="n">X_train_scaled</span> <span class="o">=</span> <span class="n">scaler</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">X_train</span><span class="p">)</span>
<span class="c1"># in các thuộc tính của tập dữ liệu trước và sau khi co giãn</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;transformed shape: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">X_train_scaled</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;per-feature minimum before scaling:</span><span class="se">\n</span><span class="s2"> </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">X_train</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)))</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;per-feature maximum before scaling:</span><span class="se">\n</span><span class="s2"> </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">X_train</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)))</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;per-feature minimum after scaling:</span><span class="se">\n</span><span class="s2"> </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
    <span class="n">X_train_scaled</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)))</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;per-feature maximum after scaling:</span><span class="se">\n</span><span class="s2"> </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
    <span class="n">X_train_scaled</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>transformed shape: (426, 30)
per-feature minimum before scaling:
 [6.981e+00 9.710e+00 4.379e+01 1.435e+02 5.263e-02 1.938e-02 0.000e+00
 0.000e+00 1.060e-01 5.024e-02 1.153e-01 3.602e-01 7.570e-01 6.802e+00
 1.713e-03 2.252e-03 0.000e+00 0.000e+00 9.539e-03 8.948e-04 7.930e+00
 1.202e+01 5.041e+01 1.852e+02 7.117e-02 2.729e-02 0.000e+00 0.000e+00
 1.566e-01 5.521e-02]
per-feature maximum before scaling:
 [2.811e+01 3.928e+01 1.885e+02 2.501e+03 1.634e-01 2.867e-01 4.268e-01
 2.012e-01 3.040e-01 9.575e-02 2.873e+00 4.885e+00 2.198e+01 5.422e+02
 3.113e-02 1.354e-01 3.960e-01 5.279e-02 6.146e-02 2.984e-02 3.604e+01
 4.954e+01 2.512e+02 4.254e+03 2.226e-01 9.379e-01 1.170e+00 2.910e-01
 5.774e-01 1.486e-01]
per-feature minimum after scaling:
 [0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0.
 0. 0. 0. 0. 0. 0.]
per-feature maximum after scaling:
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.
 1. 1. 1. 1. 1. 1.]
</pre></div>
</div>
</div>
</div>
<p>Dữ liệu đã biến đổi có cùng hình dạng với dữ liệu gốc—các đặc trưng chỉ đơn giản là được dịch chuyển và co giãn.  Bạn có thể thấy rằng tất cả các đặc trưng bây giờ đều nằm trong khoảng từ 0 đến 1, như mong muốn.</p>
<p>Để áp dụng SVM cho dữ liệu đã co giãn, chúng ta cũng cần biến đổi tập kiểm tra.  Điều này lại được thực hiện bằng cách gọi phương thức <code class="docutils literal notranslate"><span class="pre">transform</span></code>, lần này trên <code class="docutils literal notranslate"><span class="pre">X_test</span></code>:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># biến đổi dữ liệu kiểm tra</span>
<span class="n">X_test_scaled</span> <span class="o">=</span> <span class="n">scaler</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">X_test</span><span class="p">)</span>
<span class="c1"># in các thuộc tính dữ liệu kiểm tra sau khi co giãn</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;per-feature minimum after scaling:</span><span class="se">\n</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">X_test_scaled</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)))</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;per-feature maximum after scaling:</span><span class="se">\n</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">X_test_scaled</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>per-feature minimum after scaling:
[ 0.0336031   0.0226581   0.03144219  0.01141039  0.14128374  0.04406704
  0.          0.          0.1540404  -0.00615249 -0.00137796  0.00594501
  0.00430665  0.00079567  0.03919502  0.0112206   0.          0.
 -0.03191387  0.00664013  0.02660975  0.05810235  0.02031974  0.00943767
  0.1094235   0.02637792  0.          0.         -0.00023764 -0.00182032]
per-feature maximum after scaling:
[0.9578778  0.81501522 0.95577362 0.89353128 0.81132075 1.21958701
 0.87956888 0.9333996  0.93232323 1.0371347  0.42669616 0.49765736
 0.44117231 0.28371044 0.48703131 0.73863671 0.76717172 0.62928585
 1.33685792 0.39057253 0.89612238 0.79317697 0.84859804 0.74488793
 0.9154725  1.13188961 1.07008547 0.92371134 1.20532319 1.63068851]
</pre></div>
</div>
</div>
</div>
<p>Có lẽ hơi ngạc nhiên, bạn có thể thấy rằng đối với tập kiểm tra, sau khi co giãn, giá trị tối thiểu và tối đa không phải là 0 và 1.  Một số đặc trưng thậm chí còn nằm ngoài phạm vi 0-1!  Lời giải thích là <code class="docutils literal notranslate"><span class="pre">MinMaxScaler</span></code> (và tất cả các scaler khác) luôn áp dụng cùng một phép biến đổi cho tập huấn luyện và tập kiểm tra.  Điều này có nghĩa là phương thức <code class="docutils literal notranslate"><span class="pre">transform</span></code> luôn trừ đi giá trị tối thiểu của tập huấn luyện và chia cho phạm vi của tập huấn luyện, có thể khác với giá trị tối thiểu và phạm vi của tập kiểm tra.</p>
</section>
<section id="co-gian-du-lieu-huan-luyen-va-kiem-tra-theo-cung-mot-cach">
<h3>Co giãn Dữ liệu Huấn luyện và Kiểm tra theo cùng một cách<a class="headerlink" href="#co-gian-du-lieu-huan-luyen-va-kiem-tra-theo-cung-mot-cach" title="Link to this heading">#</a></h3>
<p>Điều quan trọng là phải áp dụng chính xác cùng một phép biến đổi cho tập huấn luyện và tập kiểm tra để mô hình có giám sát hoạt động trên tập kiểm tra.  Ví dụ sau (Hình 3-2) minh họa điều gì sẽ xảy ra nếu chúng ta sử dụng giá trị tối thiểu và phạm vi của tập kiểm tra thay thế:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span><span class="w"> </span><span class="nn">sklearn.datasets</span><span class="w"> </span><span class="kn">import</span> <span class="n">make_blobs</span>

<span class="c1"># tạo dữ liệu tổng hợp</span>
<span class="n">X</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">make_blobs</span><span class="p">(</span><span class="n">n_samples</span><span class="o">=</span><span class="mi">50</span><span class="p">,</span> <span class="n">centers</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">cluster_std</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="c1"># chia thành tập huấn luyện và tập kiểm tra</span>
<span class="n">X_train</span><span class="p">,</span> <span class="n">X_test</span> <span class="o">=</span> <span class="n">train_test_split</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">test_size</span><span class="o">=</span><span class="mf">.1</span><span class="p">)</span>

<span class="c1"># vẽ biểu đồ tập huấn luyện và tập kiểm tra</span>
<span class="n">fig</span><span class="p">,</span> <span class="n">axes</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">13</span><span class="p">,</span> <span class="mi">4</span><span class="p">))</span>
<span class="n">axes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">X_train</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">X_train</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span>
                <span class="n">c</span><span class="o">=</span><span class="n">mglearn</span><span class="o">.</span><span class="n">cm2</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">label</span><span class="o">=</span><span class="s2">&quot;Tập huấn luyện&quot;</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="mi">60</span><span class="p">)</span>
<span class="n">axes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">X_test</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">X_test</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">marker</span><span class="o">=</span><span class="s1">&#39;^&#39;</span><span class="p">,</span>
                <span class="n">c</span><span class="o">=</span><span class="n">mglearn</span><span class="o">.</span><span class="n">cm2</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="n">label</span><span class="o">=</span><span class="s2">&quot;Tập kiểm tra&quot;</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="mi">60</span><span class="p">)</span>
<span class="n">axes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">legend</span><span class="p">(</span><span class="n">loc</span><span class="o">=</span><span class="s1">&#39;upper left&#39;</span><span class="p">)</span>
<span class="n">axes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s2">&quot;Dữ liệu gốc&quot;</span><span class="p">)</span>

<span class="c1"># co giãn dữ liệu bằng MinMaxScaler</span>
<span class="n">scaler</span> <span class="o">=</span> <span class="n">MinMaxScaler</span><span class="p">()</span>
<span class="n">scaler</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X_train</span><span class="p">)</span>
<span class="n">X_train_scaled</span> <span class="o">=</span> <span class="n">scaler</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">X_train</span><span class="p">)</span>
<span class="n">X_test_scaled</span> <span class="o">=</span> <span class="n">scaler</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">X_test</span><span class="p">)</span>

<span class="c1"># trực quan hóa dữ liệu đã được co giãn đúng cách</span>
<span class="n">axes</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">X_train_scaled</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">X_train_scaled</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span>
                <span class="n">c</span><span class="o">=</span><span class="n">mglearn</span><span class="o">.</span><span class="n">cm2</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">label</span><span class="o">=</span><span class="s2">&quot;Tập huấn luyện&quot;</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="mi">60</span><span class="p">)</span>
<span class="n">axes</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">X_test_scaled</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">X_test_scaled</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">marker</span><span class="o">=</span><span class="s1">&#39;^&#39;</span><span class="p">,</span>
                <span class="n">c</span><span class="o">=</span><span class="n">mglearn</span><span class="o">.</span><span class="n">cm2</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="n">label</span><span class="o">=</span><span class="s2">&quot;Tập kiểm tra&quot;</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="mi">60</span><span class="p">)</span>
<span class="n">axes</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s2">&quot;Dữ liệu đã co giãn&quot;</span><span class="p">)</span>

<span class="c1"># co giãn lại tập kiểm tra một cách riêng biệt</span>
<span class="c1"># sao cho min của tập kiểm tra là 0 và max của tập kiểm tra là 1</span>
<span class="c1"># ĐỪNG LÀM VIỆC NÀY! Chỉ nhằm mục đích minh họa.</span>
<span class="n">test_scaler</span> <span class="o">=</span> <span class="n">MinMaxScaler</span><span class="p">()</span>
<span class="n">test_scaler</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X_test</span><span class="p">)</span>
<span class="n">X_test_scaled_badly</span> <span class="o">=</span> <span class="n">test_scaler</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">X_test</span><span class="p">)</span>

<span class="c1"># trực quan hóa dữ liệu đã co giãn sai cách</span>
<span class="n">axes</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">X_train_scaled</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">X_train_scaled</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span>
                <span class="n">c</span><span class="o">=</span><span class="n">mglearn</span><span class="o">.</span><span class="n">cm2</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">label</span><span class="o">=</span><span class="s2">&quot;Tập huấn luyện&quot;</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="mi">60</span><span class="p">)</span>
<span class="n">axes</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">X_test_scaled_badly</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">X_test_scaled_badly</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">marker</span><span class="o">=</span><span class="s1">&#39;^&#39;</span><span class="p">,</span>
                <span class="n">c</span><span class="o">=</span><span class="n">mglearn</span><span class="o">.</span><span class="n">cm2</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="n">label</span><span class="o">=</span><span class="s2">&quot;Tập kiểm tra&quot;</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="mi">60</span><span class="p">)</span>
<span class="n">axes</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s2">&quot;Dữ liệu đã co giãn không đúng cách&quot;</span><span class="p">)</span>

<span class="k">for</span> <span class="n">ax</span> <span class="ow">in</span> <span class="n">axes</span><span class="p">:</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s2">&quot;Đặc trưng 0&quot;</span><span class="p">)</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s2">&quot;Đặc trưng 1&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stderr highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>C:\Users\AD\AppData\Local\Temp\ipykernel_28472\67689783.py:10: UserWarning: *c* argument looks like a single numeric RGB or RGBA sequence, which should be avoided as value-mapping will have precedence in case its length matches with *x* &amp; *y*.  Please use the *color* keyword-argument or provide a 2D array with a single row if you intend to specify the same RGB or RGBA value for all points.
  axes[0].scatter(X_train[:, 0], X_train[:, 1],
C:\Users\AD\AppData\Local\Temp\ipykernel_28472\67689783.py:12: UserWarning: *c* argument looks like a single numeric RGB or RGBA sequence, which should be avoided as value-mapping will have precedence in case its length matches with *x* &amp; *y*.  Please use the *color* keyword-argument or provide a 2D array with a single row if you intend to specify the same RGB or RGBA value for all points.
  axes[0].scatter(X_test[:, 0], X_test[:, 1], marker=&#39;^&#39;,
C:\Users\AD\AppData\Local\Temp\ipykernel_28472\67689783.py:24: UserWarning: *c* argument looks like a single numeric RGB or RGBA sequence, which should be avoided as value-mapping will have precedence in case its length matches with *x* &amp; *y*.  Please use the *color* keyword-argument or provide a 2D array with a single row if you intend to specify the same RGB or RGBA value for all points.
  axes[1].scatter(X_train_scaled[:, 0], X_train_scaled[:, 1],
C:\Users\AD\AppData\Local\Temp\ipykernel_28472\67689783.py:26: UserWarning: *c* argument looks like a single numeric RGB or RGBA sequence, which should be avoided as value-mapping will have precedence in case its length matches with *x* &amp; *y*.  Please use the *color* keyword-argument or provide a 2D array with a single row if you intend to specify the same RGB or RGBA value for all points.
  axes[1].scatter(X_test_scaled[:, 0], X_test_scaled[:, 1], marker=&#39;^&#39;,
C:\Users\AD\AppData\Local\Temp\ipykernel_28472\67689783.py:38: UserWarning: *c* argument looks like a single numeric RGB or RGBA sequence, which should be avoided as value-mapping will have precedence in case its length matches with *x* &amp; *y*.  Please use the *color* keyword-argument or provide a 2D array with a single row if you intend to specify the same RGB or RGBA value for all points.
  axes[2].scatter(X_train_scaled[:, 0], X_train_scaled[:, 1],
C:\Users\AD\AppData\Local\Temp\ipykernel_28472\67689783.py:40: UserWarning: *c* argument looks like a single numeric RGB or RGBA sequence, which should be avoided as value-mapping will have precedence in case its length matches with *x* &amp; *y*.  Please use the *color* keyword-argument or provide a 2D array with a single row if you intend to specify the same RGB or RGBA value for all points.
  axes[2].scatter(X_test_scaled_badly[:, 0], X_test_scaled_badly[:, 1], marker=&#39;^&#39;,
</pre></div>
</div>
<img alt="../_images/592532d0e243787c0784ac9f5a73060b03b1dd8737f78107aab6de08fa844233.png" src="../_images/592532d0e243787c0784ac9f5a73060b03b1dd8737f78107aab6de08fa844233.png" />
</div>
</div>
<p><strong>Hình 3-2. Ảnh hưởng của việc co giãn dữ liệu huấn luyện và kiểm tra được hiển thị cùng nhau (giữa) và riêng biệt (phải)</strong></p>
<p>Bảng điều khiển đầu tiên là một tập dữ liệu hai chiều chưa được co giãn, với tập huấn luyện được hiển thị dưới dạng các vòng tròn và tập kiểm tra được hiển thị dưới dạng các hình tam giác.  Bảng điều khiển thứ hai là cùng một dữ liệu, nhưng được co giãn bằng <code class="docutils literal notranslate"><span class="pre">MinMaxScaler</span></code>.  Ở đây, chúng ta đã gọi <code class="docutils literal notranslate"><span class="pre">fit</span></code> trên tập huấn luyện, sau đó gọi <code class="docutils literal notranslate"><span class="pre">transform</span></code> trên các tập huấn luyện và kiểm tra.  Bạn có thể thấy rằng tập dữ liệu trong bảng điều khiển thứ hai trông giống hệt với bảng đầu tiên; chỉ có các vạch trên các trục đã thay đổi.  Bây giờ tất cả các đặc trưng đều nằm trong khoảng từ 0 đến 1.  Bạn cũng có thể thấy rằng các giá trị đặc trưng tối thiểu và tối đa cho dữ liệu kiểm tra (các hình tam giác) không phải là 0 và 1.</p>
<p>Bảng điều khiển thứ ba cho thấy điều gì sẽ xảy ra nếu chúng ta co giãn tập huấn luyện và tập kiểm tra một cách riêng biệt.  Trong trường hợp này, các giá trị đặc trưng tối thiểu và tối đa cho cả tập huấn luyện và tập kiểm tra đều là 0 và 1.  Nhưng bây giờ tập dữ liệu trông khác.  Các điểm kiểm tra đã di chuyển không phù hợp với tập huấn luyện, vì chúng được co giãn khác nhau.  Chúng ta đã thay đổi sự sắp xếp của dữ liệu một cách tùy tiện.  Rõ ràng đây không phải là điều chúng ta muốn làm.</p>
<p>Một cách khác để nghĩ về điều này, hãy tưởng tượng tập kiểm tra của bạn là một điểm duy nhất.  Không có cách nào để co giãn một điểm duy nhất một cách chính xác, để đáp ứng các yêu cầu tối thiểu và tối đa của <code class="docutils literal notranslate"><span class="pre">MinMaxScaler</span></code>.  Nhưng kích thước của tập kiểm tra của bạn không nên thay đổi quá trình xử lý của bạn.</p>
</section>
<section id="cac-phuong-phap-tat-va-cac-lua-chon-thay-the-hieu-qua">
<h3>Các phương pháp tắt và các lựa chọn thay thế hiệu quả<a class="headerlink" href="#cac-phuong-phap-tat-va-cac-lua-chon-thay-the-hieu-qua" title="Link to this heading">#</a></h3>
<p>Thông thường, bạn muốn khớp một mô hình trên một số tập dữ liệu, sau đó biến đổi nó.  Đây là một nhiệm vụ rất phổ biến, thường có thể được tính toán hiệu quả hơn so với việc chỉ gọi <code class="docutils literal notranslate"><span class="pre">fit</span></code> và sau đó là <code class="docutils literal notranslate"><span class="pre">transform</span></code>.  Đối với trường hợp sử dụng này, tất cả các mô hình có phương thức <code class="docutils literal notranslate"><span class="pre">transform</span></code> cũng có phương thức <code class="docutils literal notranslate"><span class="pre">fit_transform</span></code>.  Dưới đây là một ví dụ sử dụng <code class="docutils literal notranslate"><span class="pre">StandardScaler</span></code>:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span><span class="w"> </span><span class="nn">sklearn.preprocessing</span><span class="w"> </span><span class="kn">import</span> <span class="n">StandardScaler</span>

<span class="c1"># Giả sử X là dữ liệu của bạn</span>
<span class="n">X</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">make_blobs</span><span class="p">(</span><span class="n">n_samples</span><span class="o">=</span><span class="mi">50</span><span class="p">,</span> <span class="n">centers</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">cluster_std</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>

<span class="n">scaler</span> <span class="o">=</span> <span class="n">StandardScaler</span><span class="p">()</span>
<span class="c1"># gọi fit và transform theo trình tự (sử dụng chuỗi phương thức)</span>
<span class="n">X_scaled</span> <span class="o">=</span> <span class="n">scaler</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X</span><span class="p">)</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
<span class="c1"># kết quả tương tự, nhưng tính toán hiệu quả hơn</span>
<span class="n">X_scaled_d</span> <span class="o">=</span> <span class="n">scaler</span><span class="o">.</span><span class="n">fit_transform</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>Mặc dù <code class="docutils literal notranslate"><span class="pre">fit_transform</span></code> không nhất thiết hiệu quả hơn cho tất cả các mô hình, nhưng vẫn là một thực hành tốt để sử dụng phương thức này khi cố gắng biến đổi tập huấn luyện.</p>
</section>
<section id="anh-huong-cua-tien-xu-ly-den-hoc-co-giam-sat">
<h3>Ảnh hưởng của Tiền xử lý đến Học có giám sát<a class="headerlink" href="#anh-huong-cua-tien-xu-ly-den-hoc-co-giam-sat" title="Link to this heading">#</a></h3>
<p>Bây giờ hãy quay lại tập dữ liệu ung thư và xem ảnh hưởng của việc sử dụng <code class="docutils literal notranslate"><span class="pre">MinMaxScaler</span></code> đến việc học <code class="docutils literal notranslate"><span class="pre">SVC</span></code> (đây là một cách khác để thực hiện cùng một phép co giãn mà chúng ta đã làm trong Chương 2).  Trước tiên, hãy khớp <code class="docutils literal notranslate"><span class="pre">SVC</span></code> trên dữ liệu gốc một lần nữa để so sánh:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span><span class="w"> </span><span class="nn">sklearn.svm</span><span class="w"> </span><span class="kn">import</span> <span class="n">SVC</span>

<span class="n">X_train</span><span class="p">,</span> <span class="n">X_test</span><span class="p">,</span> <span class="n">y_train</span><span class="p">,</span> <span class="n">y_test</span> <span class="o">=</span> <span class="n">train_test_split</span><span class="p">(</span><span class="n">cancer</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">cancer</span><span class="o">.</span><span class="n">target</span><span class="p">,</span>
                                                    <span class="n">random_state</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="n">svm</span> <span class="o">=</span> <span class="n">SVC</span><span class="p">(</span><span class="n">C</span><span class="o">=</span><span class="mi">100</span><span class="p">)</span>
<span class="n">svm</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X_train</span><span class="p">,</span> <span class="n">y_train</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Test set accuracy: </span><span class="si">{:.2f}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">svm</span><span class="o">.</span><span class="n">score</span><span class="p">(</span><span class="n">X_test</span><span class="p">,</span> <span class="n">y_test</span><span class="p">)))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Test set accuracy: 0.94
</pre></div>
</div>
</div>
</div>
<p>Bây giờ, hãy co giãn dữ liệu bằng <code class="docutils literal notranslate"><span class="pre">MinMaxScaler</span></code> trước khi khớp <code class="docutils literal notranslate"><span class="pre">SVC</span></code>:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># tiền xử lý bằng co giãn 0-1</span>
<span class="n">scaler</span> <span class="o">=</span> <span class="n">MinMaxScaler</span><span class="p">()</span>
<span class="n">scaler</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X_train</span><span class="p">)</span>
<span class="n">X_train_scaled</span> <span class="o">=</span> <span class="n">scaler</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">X_train</span><span class="p">)</span>
<span class="n">X_test_scaled</span> <span class="o">=</span> <span class="n">scaler</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">X_test</span><span class="p">)</span>

<span class="c1"># học một SVM trên dữ liệu huấn luyện đã co giãn</span>
<span class="n">svm</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X_train_scaled</span><span class="p">,</span> <span class="n">y_train</span><span class="p">)</span>

<span class="c1"># chấm điểm trên tập kiểm tra đã co giãn</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Scaled test set accuracy: </span><span class="si">{:.2f}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
    <span class="n">svm</span><span class="o">.</span><span class="n">score</span><span class="p">(</span><span class="n">X_test_scaled</span><span class="p">,</span> <span class="n">y_test</span><span class="p">)))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Scaled test set accuracy: 0.97
</pre></div>
</div>
</div>
</div>
<p>Như chúng ta đã thấy trước đây, ảnh hưởng của việc co giãn dữ liệu là khá đáng kể.  Mặc dù việc co giãn dữ liệu không liên quan đến bất kỳ phép toán phức tạp nào, nhưng vẫn là một thực hành tốt để sử dụng các cơ chế co giãn do scikit-learn cung cấp thay vì tự triển khai lại chúng, vì rất dễ mắc lỗi ngay cả trong những phép tính đơn giản này.</p>
<p>Bạn cũng có thể dễ dàng thay thế một giải thuật tiền xử lý bằng một giải thuật khác bằng cách thay đổi lớp bạn sử dụng, vì tất cả các lớp tiền xử lý đều có cùng một giao diện, bao gồm các phương thức <code class="docutils literal notranslate"><span class="pre">fit</span></code> và <code class="docutils literal notranslate"><span class="pre">transform</span></code>:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># tiền xử lý bằng co giãn trung bình bằng không và phương sai đơn vị</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">sklearn.preprocessing</span><span class="w"> </span><span class="kn">import</span> <span class="n">StandardScaler</span>
<span class="n">scaler</span> <span class="o">=</span> <span class="n">StandardScaler</span><span class="p">()</span>
<span class="n">scaler</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X_train</span><span class="p">)</span>
<span class="n">X_train_scaled</span> <span class="o">=</span> <span class="n">scaler</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">X_train</span><span class="p">)</span>
<span class="n">X_test_scaled</span> <span class="o">=</span> <span class="n">scaler</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">X_test</span><span class="p">)</span>
<span class="c1"># học một SVM trên dữ liệu huấn luyện đã co giãn</span>
<span class="n">svm</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X_train_scaled</span><span class="p">,</span> <span class="n">y_train</span><span class="p">)</span>
<span class="c1"># chấm điểm trên tập kiểm tra đã co giãn</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;SVM test accuracy: </span><span class="si">{:.2f}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">svm</span><span class="o">.</span><span class="n">score</span><span class="p">(</span><span class="n">X_test_scaled</span><span class="p">,</span> <span class="n">y_test</span><span class="p">)))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>SVM test accuracy: 0.96
</pre></div>
</div>
</div>
</div>
<p>Bây giờ chúng ta đã thấy cách các phép biến đổi dữ liệu đơn giản để tiền xử lý hoạt động, hãy chuyển sang các phép biến đổi thú vị hơn bằng cách sử dụng học không giám sát.</p>
</section>
</section>
<section id="giam-chieu-trich-xuat-dac-trung-va-hoc-da-tap-manifold-learning">
<h2>Giảm chiều, Trích xuất Đặc trưng, và Học Đa tạp (Manifold Learning)<a class="headerlink" href="#giam-chieu-trich-xuat-dac-trung-va-hoc-da-tap-manifold-learning" title="Link to this heading">#</a></h2>
<p>Như chúng ta đã thảo luận trước đó, việc biến đổi dữ liệu bằng học không giám sát có thể có nhiều động cơ.  Các động cơ phổ biến nhất là trực quan hóa, nén dữ liệu, và tìm một biểu diễn nhiều thông tin hơn cho quá trình xử lý tiếp theo.  Một trong những giải thuật đơn giản và được sử dụng rộng rãi nhất cho tất cả những điều này là phân tích thành phần chính.  Chúng ta cũng sẽ xem xét hai giải thuật khác: phân rã ma trận không âm (NMF), thường được sử dụng để trích xuất đặc trưng, và t-SNE, thường được sử dụng để trực quan hóa bằng biểu đồ phân tán hai chiều.</p>
<section id="phan-tich-thanh-phan-chinh-pca">
<h3>Phân tích Thành phần Chính (PCA)<a class="headerlink" href="#phan-tich-thanh-phan-chinh-pca" title="Link to this heading">#</a></h3>
<p>Phân tích thành phần chính là một phương pháp xoay tập dữ liệu sao cho các đặc trưng đã xoay không tương quan thống kê với nhau.  Phép xoay này thường được theo sau bởi việc chỉ chọn một tập hợp con của các đặc trưng mới, tùy thuộc vào tầm quan trọng của chúng trong việc giải thích dữ liệu.  Ví dụ sau (Hình 3-3) minh họa ảnh hưởng của PCA trên một tập dữ liệu hai chiều tổng hợp:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">mglearn</span><span class="o">.</span><span class="n">plots</span><span class="o">.</span><span class="n">plot_pca_illustration</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../_images/01686c0b6794c15ea4461406c60e77793b9dc36374bc65c4a5aaad594c96c3a2.png" src="../_images/01686c0b6794c15ea4461406c60e77793b9dc36374bc65c4a5aaad594c96c3a2.png" />
</div>
</div>
<p><strong>Hình 3-3. Biến đổi dữ liệu bằng PCA</strong></p>
<p>Biểu đồ đầu tiên (trên cùng bên trái) hiển thị các điểm dữ liệu ban đầu, được tô màu để phân biệt chúng.  Giải thuật tiến hành bằng cách đầu tiên tìm hướng có phương sai lớn nhất, được gắn nhãn “Thành phần 1”.  Đây là hướng (hoặc vector) trong dữ liệu chứa nhiều thông tin nhất, hoặc nói cách khác, là hướng mà dọc theo đó các đặc trưng tương quan với nhau nhiều nhất.  Sau đó, giải thuật tìm hướng chứa nhiều thông tin nhất trong khi vẫn trực giao (vuông góc) với hướng đầu tiên.  Trong không gian hai chiều, chỉ có một hướng khả dĩ duy nhất là vuông góc, nhưng trong không gian nhiều chiều hơn sẽ có (vô số) các hướng trực giao.  Mặc dù hai thành phần được vẽ dưới dạng mũi tên, nhưng đầu và đuôi của chúng không thực sự quan trọng;  chúng ta có thể đã vẽ thành phần thứ nhất từ trung tâm lên trên bên trái thay vì xuống dưới bên phải.  Các hướng được tìm thấy bằng quy trình này được gọi là các thành phần chính, vì chúng là các hướng phương sai chính trong dữ liệu.  Nói chung, có bao nhiêu thành phần chính thì có bấy nhiêu đặc trưng ban đầu.</p>
<p>Biểu đồ thứ hai (trên cùng bên phải) hiển thị cùng một dữ liệu, nhưng bây giờ được xoay sao cho thành phần chính thứ nhất thẳng hàng với trục x và thành phần chính thứ hai thẳng hàng với trục y.  Trước khi xoay, giá trị trung bình đã được trừ khỏi dữ liệu, do đó dữ liệu đã biến đổi được căn giữa quanh số không.  Trong biểu diễn đã xoay được tìm thấy bởi PCA, hai trục không tương quan, có nghĩa là ma trận tương quan của dữ liệu trong biểu diễn này bằng không ngoại trừ đường chéo.</p>
<p>Chúng ta có thể sử dụng PCA để giảm chiều bằng cách chỉ giữ lại một số thành phần chính.  Trong ví dụ này, chúng ta có thể chỉ giữ lại thành phần chính thứ nhất, như được hiển thị trong bảng điều khiển thứ ba trong Hình 3-3 (dưới cùng bên trái).  Điều này làm giảm dữ liệu từ một tập dữ liệu hai chiều thành một tập dữ liệu một chiều.  Tuy nhiên, lưu ý rằng thay vì chỉ giữ lại một trong các đặc trưng ban đầu, chúng ta đã tìm thấy hướng thú vị nhất (từ trên cùng bên trái đến dưới cùng bên phải trong bảng điều khiển đầu tiên) và giữ lại hướng này, thành phần chính thứ nhất.</p>
<p>Cuối cùng, chúng ta có thể hoàn tác phép xoay và cộng lại giá trị trung bình vào dữ liệu.  Điều này sẽ dẫn đến dữ liệu được hiển thị trong bảng điều khiển cuối cùng trong Hình 3-3.  Những điểm này nằm trong không gian đặc trưng ban đầu, nhưng chúng ta chỉ giữ lại thông tin chứa trong thành phần chính thứ nhất.  Phép biến đổi này đôi khi được sử dụng để loại bỏ hiệu ứng nhiễu từ dữ liệu hoặc trực quan hóa phần thông tin nào được giữ lại bằng cách sử dụng các thành phần chính.</p>
<section id="ap-dung-pca-cho-tap-du-lieu-ung-thu-de-truc-quan-hoa">
<h4>Áp dụng PCA cho tập dữ liệu ung thư để trực quan hóa<a class="headerlink" href="#ap-dung-pca-cho-tap-du-lieu-ung-thu-de-truc-quan-hoa" title="Link to this heading">#</a></h4>
<p>Một trong những ứng dụng phổ biến nhất của PCA là trực quan hóa các tập dữ liệu nhiều chiều.  Như chúng ta đã thấy trong Chương 1, rất khó để tạo biểu đồ phân tán của dữ liệu có nhiều hơn hai đặc trưng.  Đối với tập dữ liệu Iris, chúng ta đã có thể tạo một biểu đồ cặp (Hình 1-3 trong Chương 1) đã cho chúng ta một bức tranh một phần của dữ liệu bằng cách hiển thị tất cả các kết hợp có thể có của hai đặc trưng.  Nhưng nếu chúng ta muốn xem xét tập dữ liệu Ung thư vú, ngay cả việc sử dụng biểu đồ cặp cũng rất khó khăn.  Tập dữ liệu này có 30 đặc trưng, sẽ dẫn đến 30 * 14 = 420 biểu đồ phân tán!  Chúng ta sẽ không bao giờ có thể xem xét tất cả các biểu đồ này một cách chi tiết, chứ đừng nói đến việc cố gắng hiểu chúng.</p>
<p>Tuy nhiên, có một cách trực quan hóa thậm chí còn đơn giản hơn mà chúng ta có thể sử dụng—tính toán biểu đồ tần suất của mỗi đặc trưng cho hai lớp, ung thư lành tính và ác tính (Hình 3-4):</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">fig</span><span class="p">,</span> <span class="n">axes</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">15</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">20</span><span class="p">))</span>
<span class="n">malignant</span> <span class="o">=</span> <span class="n">cancer</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">cancer</span><span class="o">.</span><span class="n">target</span> <span class="o">==</span> <span class="mi">0</span><span class="p">]</span>
<span class="n">benign</span> <span class="o">=</span> <span class="n">cancer</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">cancer</span><span class="o">.</span><span class="n">target</span> <span class="o">==</span> <span class="mi">1</span><span class="p">]</span>

<span class="n">ax</span> <span class="o">=</span> <span class="n">axes</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">30</span><span class="p">):</span>
    <span class="n">_</span><span class="p">,</span> <span class="n">bins</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">histogram</span><span class="p">(</span><span class="n">cancer</span><span class="o">.</span><span class="n">data</span><span class="p">[:,</span> <span class="n">i</span><span class="p">],</span> <span class="n">bins</span><span class="o">=</span><span class="mi">50</span><span class="p">)</span>
    <span class="n">ax</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">hist</span><span class="p">(</span><span class="n">malignant</span><span class="p">[:,</span> <span class="n">i</span><span class="p">],</span> <span class="n">bins</span><span class="o">=</span><span class="n">bins</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="n">mglearn</span><span class="o">.</span><span class="n">cm3</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">.5</span><span class="p">)</span>
    <span class="n">ax</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">hist</span><span class="p">(</span><span class="n">benign</span><span class="p">[:,</span> <span class="n">i</span><span class="p">],</span> <span class="n">bins</span><span class="o">=</span><span class="n">bins</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="n">mglearn</span><span class="o">.</span><span class="n">cm3</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">.5</span><span class="p">)</span>
    <span class="n">ax</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="n">cancer</span><span class="o">.</span><span class="n">feature_names</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
    <span class="n">ax</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">set_yticks</span><span class="p">(())</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s2">&quot;Độ lớn đặc trưng&quot;</span><span class="p">)</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s2">&quot;Tần suất&quot;</span><span class="p">)</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">legend</span><span class="p">([</span><span class="s2">&quot;ác tính&quot;</span><span class="p">,</span> <span class="s2">&quot;lành tính&quot;</span><span class="p">],</span> <span class="n">loc</span><span class="o">=</span><span class="s2">&quot;best&quot;</span><span class="p">)</span>
<span class="n">fig</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../_images/7ac6f94e5be8fabd40ffcfb1c7890179f8b57f69ee368a36fd1187dfe4822427.png" src="../_images/7ac6f94e5be8fabd40ffcfb1c7890179f8b57f69ee368a36fd1187dfe4822427.png" />
</div>
</div>
<p><strong>Hình 3-4. Biểu đồ tần suất đặc trưng theo lớp trên tập dữ liệu Ung thư vú</strong></p>
<p>Ở đây chúng ta tạo một biểu đồ tần suất cho mỗi đặc trưng, đếm số lần một điểm dữ liệu xuất hiện với một đặc trưng trong một phạm vi nhất định (gọi là một bin).  Mỗi biểu đồ chồng hai biểu đồ tần suất lên nhau, một cho tất cả các điểm trong lớp lành tính (màu xanh) và một cho tất cả các điểm trong lớp ác tính (màu đỏ).  Điều này cho chúng ta một số ý tưởng về cách mỗi đặc trưng được phân phối trên hai lớp, và cho phép chúng ta đoán xem đặc trưng nào tốt hơn trong việc phân biệt các mẫu ác tính và lành tính.  Ví dụ, đặc trưng “smoothness error” có vẻ khá ít thông tin, vì hai biểu đồ tần suất hầu như chồng chéo lên nhau, trong khi đặc trưng “worst concave points” có vẻ khá nhiều thông tin, vì các biểu đồ tần suất khá rời rạc.</p>
<p>Tuy nhiên, biểu đồ này không cho chúng ta thấy bất cứ điều gì về sự tương tác giữa các biến và cách chúng liên quan đến các lớp.  Sử dụng PCA, chúng ta có thể nắm bắt các tương tác chính và có được một bức tranh hoàn chỉnh hơn một chút.  Chúng ta có thể tìm thấy hai thành phần chính đầu tiên, và trực quan hóa dữ liệu trong không gian hai chiều mới này bằng một biểu đồ phân tán duy nhất.</p>
<p>Trước khi áp dụng PCA, chúng ta co giãn dữ liệu sao cho mỗi đặc trưng có phương sai đơn vị bằng cách sử dụng <code class="docutils literal notranslate"><span class="pre">StandardScaler</span></code>:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">scaler</span> <span class="o">=</span> <span class="n">StandardScaler</span><span class="p">()</span>
<span class="n">scaler</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">cancer</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>
<span class="n">X_scaled</span> <span class="o">=</span> <span class="n">scaler</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">cancer</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>Học phép biến đổi PCA và áp dụng nó đơn giản như áp dụng một phép biến đổi tiền xử lý.  Chúng ta khởi tạo đối tượng <code class="docutils literal notranslate"><span class="pre">PCA</span></code>, tìm các thành phần chính bằng cách gọi phương thức <code class="docutils literal notranslate"><span class="pre">fit</span></code>, sau đó áp dụng phép xoay và giảm chiều bằng cách gọi <code class="docutils literal notranslate"><span class="pre">transform</span></code>.  Theo mặc định, PCA chỉ xoay (và dịch chuyển) dữ liệu, nhưng giữ lại tất cả các thành phần chính.  Để giảm chiều của dữ liệu, chúng ta cần chỉ định số lượng thành phần chúng ta muốn giữ lại khi tạo đối tượng <code class="docutils literal notranslate"><span class="pre">PCA</span></code>:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span><span class="w"> </span><span class="nn">sklearn.decomposition</span><span class="w"> </span><span class="kn">import</span> <span class="n">PCA</span>

<span class="c1"># giữ hai thành phần chính đầu tiên của dữ liệu</span>
<span class="n">pca</span> <span class="o">=</span> <span class="n">PCA</span><span class="p">(</span><span class="n">n_components</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="c1"># khớp mô hình PCA với dữ liệu ung thư vú</span>
<span class="n">pca</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X_scaled</span><span class="p">)</span>

<span class="c1"># biến đổi dữ liệu lên hai thành phần chính đầu tiên</span>
<span class="n">X_pca</span> <span class="o">=</span> <span class="n">pca</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">X_scaled</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Original shape: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">X_scaled</span><span class="o">.</span><span class="n">shape</span><span class="p">)))</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Reduced shape: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">X_pca</span><span class="o">.</span><span class="n">shape</span><span class="p">)))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Original shape: (569, 30)
Reduced shape: (569, 2)
</pre></div>
</div>
</div>
</div>
<p>Bây giờ chúng ta có thể vẽ hai thành phần chính đầu tiên (Hình 3-5):</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># vẽ thành phần chính thứ nhất so với thứ hai, được tô màu theo lớp</span>
<span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="mi">8</span><span class="p">))</span>
<span class="n">mglearn</span><span class="o">.</span><span class="n">discrete_scatter</span><span class="p">(</span><span class="n">X_pca</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">X_pca</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">cancer</span><span class="o">.</span><span class="n">target</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">(</span><span class="n">cancer</span><span class="o">.</span><span class="n">target_names</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="s2">&quot;best&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">gca</span><span class="p">()</span><span class="o">.</span><span class="n">set_aspect</span><span class="p">(</span><span class="s2">&quot;equal&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s2">&quot;Thành phần chính thứ nhất&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s2">&quot;Thành phần chính thứ hai&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../_images/ed96c50d59ad094d43f2ffe8e5102da8e412ac0479e0446311e9bd2e4acf28f8.png" src="../_images/ed96c50d59ad094d43f2ffe8e5102da8e412ac0479e0446311e9bd2e4acf28f8.png" />
</div>
</div>
<p><strong>Hình 3-5. Biểu đồ phân tán hai chiều của tập dữ liệu Ung thư vú sử dụng hai thành phần chính đầu tiên</strong></p>
<p>Điều quan trọng cần lưu ý là PCA là một phương pháp không giám sát và không sử dụng bất kỳ thông tin lớp nào khi tìm phép xoay.  Nó chỉ đơn giản là xem xét các mối tương quan trong dữ liệu.  Đối với biểu đồ phân tán được hiển thị ở đây, chúng ta đã vẽ thành phần chính thứ nhất so với thành phần chính thứ hai, sau đó sử dụng thông tin lớp để tô màu các điểm.  Bạn có thể thấy rằng hai lớp phân tách khá tốt trong không gian hai chiều này.  Điều này khiến chúng ta tin rằng ngay cả một bộ phân loại tuyến tính (sẽ học một đường thẳng trong không gian này) cũng có thể làm khá tốt trong việc phân biệt hai lớp.  Chúng ta cũng có thể thấy rằng các điểm ác tính (màu đỏ) phân tán rộng hơn các điểm lành tính (màu xanh)—một điều mà chúng ta đã có thể thấy một chút từ các biểu đồ tần suất trong Hình 3-4.</p>
<p>Một nhược điểm của PCA là hai trục trong biểu đồ thường không dễ diễn giải.  Các thành phần chính tương ứng với các hướng trong dữ liệu gốc, vì vậy chúng là sự kết hợp của các đặc trưng ban đầu.  Tuy nhiên, những sự kết hợp này thường rất phức tạp, như chúng ta sẽ thấy ngay sau đây.  Các thành phần chính được lưu trữ trong thuộc tính <code class="docutils literal notranslate"><span class="pre">components_</span></code> của đối tượng PCA trong quá trình khớp:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="s2">&quot;PCA component shape: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">pca</span><span class="o">.</span><span class="n">components_</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>PCA component shape: (2, 30)
</pre></div>
</div>
</div>
</div>
<p>Mỗi hàng trong <code class="docutils literal notranslate"><span class="pre">components_</span></code> tương ứng với một thành phần chính, và chúng được sắp xếp theo tầm quan trọng của chúng (thành phần chính thứ nhất đứng đầu, v.v.).  Các cột tương ứng với thuộc tính đặc trưng ban đầu của PCA trong ví dụ này, “mean radius,” “mean texture,” v.v.  Hãy xem nội dung của <code class="docutils literal notranslate"><span class="pre">components_</span></code>:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="s2">&quot;PCA components:</span><span class="se">\n</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">pca</span><span class="o">.</span><span class="n">components_</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>PCA components:
[[ 0.21890244  0.10372458  0.22753729  0.22099499  0.14258969  0.23928535
   0.25840048  0.26085376  0.13816696  0.06436335  0.20597878  0.01742803
   0.21132592  0.20286964  0.01453145  0.17039345  0.15358979  0.1834174
   0.04249842  0.10256832  0.22799663  0.10446933  0.23663968  0.22487053
   0.12795256  0.21009588  0.22876753  0.25088597  0.12290456  0.13178394]
 [-0.23385713 -0.05970609 -0.21518136 -0.23107671  0.18611302  0.15189161
   0.06016536 -0.0347675   0.19034877  0.36657547 -0.10555215  0.08997968
  -0.08945723 -0.15229263  0.20443045  0.2327159   0.19720728  0.13032156
   0.183848    0.28009203 -0.21986638 -0.0454673  -0.19987843 -0.21935186
   0.17230435  0.14359317  0.09796411 -0.00825724  0.14188335  0.27533947]]
</pre></div>
</div>
</div>
</div>
<p>Chúng ta cũng có thể trực quan hóa các hệ số bằng cách sử dụng bản đồ nhiệt (Hình 3-6), có thể dễ hiểu hơn:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">plt</span><span class="o">.</span><span class="n">matshow</span><span class="p">(</span><span class="n">pca</span><span class="o">.</span><span class="n">components_</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="s1">&#39;viridis&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">yticks</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="s2">&quot;Thành phần thứ nhất&quot;</span><span class="p">,</span> <span class="s2">&quot;Thành phần thứ hai&quot;</span><span class="p">])</span>
<span class="n">plt</span><span class="o">.</span><span class="n">colorbar</span><span class="p">()</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xticks</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">cancer</span><span class="o">.</span><span class="n">feature_names</span><span class="p">)),</span>
           <span class="n">cancer</span><span class="o">.</span><span class="n">feature_names</span><span class="p">,</span> <span class="n">rotation</span><span class="o">=</span><span class="mi">60</span><span class="p">,</span> <span class="n">ha</span><span class="o">=</span><span class="s1">&#39;left&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s2">&quot;Đặc trưng&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s2">&quot;Thành phần chính&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../_images/0e1b12b196ea2221aadfb8a3153646dd51e150ef90a39681273a0fc328b90e50.png" src="../_images/0e1b12b196ea2221aadfb8a3153646dd51e150ef90a39681273a0fc328b90e50.png" />
</div>
</div>
<p><strong>Hình 3-6. Bản đồ nhiệt của hai thành phần chính đầu tiên trên tập dữ liệu Ung thư vú</strong></p>
<p>Bạn có thể thấy rằng trong thành phần thứ nhất, tất cả các đặc trưng đều có cùng dấu (nó là âm, nhưng như chúng ta đã đề cập trước đó, hướng của mũi tên không quan trọng).  Điều đó có nghĩa là có một mối tương quan chung giữa tất cả các đặc trưng.  Khi một phép đo cao, các phép đo khác cũng có khả năng cao.  Thành phần thứ hai có các dấu hỗn hợp, và cả hai thành phần đều liên quan đến tất cả 30 đặc trưng.  Sự pha trộn của tất cả các đặc trưng này là điều làm cho việc giải thích các trục trong Hình 3-6 trở nên khó khăn.</p>
</section>
<section id="cac-khuon-mat-dac-trung-eigenfaces-de-trich-xuat-dac-trung">
<h4>Các khuôn mặt đặc trưng (Eigenfaces) để trích xuất đặc trưng<a class="headerlink" href="#cac-khuon-mat-dac-trung-eigenfaces-de-trich-xuat-dac-trung" title="Link to this heading">#</a></h4>
<p>Một ứng dụng khác của PCA mà chúng ta đã đề cập trước đó là trích xuất đặc trưng. Ý tưởng đằng sau việc trích xuất đặc trưng là có thể tìm ra một biểu diễn dữ liệu của bạn phù hợp hơn cho việc phân tích so với biểu diễn thô mà bạn được cung cấp. Một ví dụ tuyệt vời về một ứng dụng mà việc trích xuất đặc trưng hữu ích là với hình ảnh. Hình ảnh được tạo thành từ các pixel, thường được lưu trữ dưới dạng cường độ đỏ, xanh lá cây và xanh lam (RGB). Các đối tượng trong hình ảnh thường được tạo thành từ hàng nghìn pixel, và chỉ khi kết hợp lại chúng mới có ý nghĩa. Chúng ta sẽ đưa ra một ứng dụng rất đơn giản về trích xuất đặc trưng trên hình ảnh bằng PCA, bằng cách làm việc với các hình ảnh khuôn mặt từ tập dữ liệu Labeled Faces in the Wild. Tập dữ liệu này chứa các hình ảnh khuôn mặt của những người nổi tiếng được tải xuống từ Internet, và nó bao gồm các khuôn mặt của các chính trị gia, ca sĩ, diễn viên và vận động viên từ đầu những năm 2000. Chúng ta sử dụng các phiên bản thang độ xám của những hình ảnh này, và thu nhỏ chúng để xử lý nhanh hơn. Bạn có thể thấy một số hình ảnh trong Hình 3-7:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span><span class="w"> </span><span class="nn">sklearn.datasets</span><span class="w"> </span><span class="kn">import</span> <span class="n">fetch_lfw_people</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">matplotlib.pyplot</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">plt</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">mglearn</span>

<span class="n">people</span> <span class="o">=</span> <span class="n">fetch_lfw_people</span><span class="p">(</span><span class="n">min_faces_per_person</span><span class="o">=</span><span class="mi">20</span><span class="p">,</span> <span class="n">resize</span><span class="o">=</span><span class="mf">0.7</span><span class="p">)</span>
<span class="n">image_shape</span> <span class="o">=</span> <span class="n">people</span><span class="o">.</span><span class="n">images</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span>

<span class="n">fix</span><span class="p">,</span> <span class="n">axes</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">15</span><span class="p">,</span> <span class="mi">8</span><span class="p">),</span>
                       <span class="n">subplot_kw</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;xticks&#39;</span><span class="p">:</span> <span class="p">(),</span> <span class="s1">&#39;yticks&#39;</span><span class="p">:</span> <span class="p">()})</span>
<span class="k">for</span> <span class="n">target</span><span class="p">,</span> <span class="n">image</span><span class="p">,</span> <span class="n">ax</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">people</span><span class="o">.</span><span class="n">target</span><span class="p">,</span> <span class="n">people</span><span class="o">.</span><span class="n">images</span><span class="p">,</span> <span class="n">axes</span><span class="o">.</span><span class="n">ravel</span><span class="p">()):</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="s1">&#39;gray&#39;</span><span class="p">)</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="n">people</span><span class="o">.</span><span class="n">target_names</span><span class="p">[</span><span class="n">target</span><span class="p">])</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
</div>
<p>**Hình 3-7. Một số hình ảnh từ tập dữ liệu Labeled Faces in the Wild **</p>
<p>Có 3.023 hình ảnh, mỗi hình có kích thước 87x65 pixel, thuộc về 62 người khác nhau:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="s2">&quot;people.images.shape: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">people</span><span class="o">.</span><span class="n">images</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Number of classes: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">people</span><span class="o">.</span><span class="n">target_names</span><span class="p">)))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>people.images.shape: (3023, 87, 65)
Number of classes: 62
</pre></div>
</div>
</div>
</div>
<p>Tuy nhiên, tập dữ liệu có một chút sai lệch, chứa rất nhiều hình ảnh của George W. Bush và Colin Powell, như bạn có thể thấy ở đây:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># đếm số lần mỗi mục tiêu xuất hiện</span>
<span class="n">counts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">bincount</span><span class="p">(</span><span class="n">people</span><span class="o">.</span><span class="n">target</span><span class="p">)</span>
<span class="c1"># in số đếm bên cạnh tên mục tiêu</span>
<span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="n">count</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">counts</span><span class="p">,</span> <span class="n">people</span><span class="o">.</span><span class="n">target_names</span><span class="p">)):</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">{0:25}</span><span class="s2"> </span><span class="si">{1:3}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">count</span><span class="p">),</span> <span class="n">end</span><span class="o">=</span><span class="s1">&#39;   &#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="mi">3</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Alejandro Toledo           39   Alvaro Uribe               35   Amelie Mauresmo            21   
Andre Agassi               36   Angelina Jolie             20   Ariel Sharon               77   
Arnold Schwarzenegger      42   Atal Bihari Vajpayee       24   Bill Clinton               29   
Carlos Menem               21   Colin Powell              236   David Beckham              31   
Donald Rumsfeld           121   George Robertson           22   George W Bush             530   
Gerhard Schroeder         109   Gloria Macapagal Arroyo    44   Gray Davis                 26   
Guillermo Coria            30   Hamid Karzai               22   Hans Blix                  39   
Hugo Chavez                71   Igor Ivanov                20   Jack Straw                 28   
Jacques Chirac             52   Jean Chretien              55   Jennifer Aniston           21   
Jennifer Capriati          42   Jennifer Lopez             21   Jeremy Greenstock          24   
Jiang Zemin                20   John Ashcroft              53   John Negroponte            31   
Jose Maria Aznar           23   Juan Carlos Ferrero        28   Junichiro Koizumi          60   
Kofi Annan                 32   Laura Bush                 41   Lindsay Davenport          22   
Lleyton Hewitt             41   Luiz Inacio Lula da Silva  48   Mahmoud Abbas              29   
Megawati Sukarnoputri      33   Michael Bloomberg          20   Naomi Watts                22   
Nestor Kirchner            37   Paul Bremer                20   Pete Sampras               22   
Recep Tayyip Erdogan       30   Ricardo Lagos              27   Roh Moo-hyun               32   
Rudolph Giuliani           26   Saddam Hussein             23   Serena Williams            52   
Silvio Berlusconi          33   Tiger Woods                23   Tom Daschle                25   
Tom Ridge                  33   Tony Blair                144   Vicente Fox                32   
Vladimir Putin             49   Winona Ryder               24   
</pre></div>
</div>
</div>
</div>
<p>Để làm cho dữ liệu ít sai lệch hơn, chúng ta sẽ chỉ lấy tối đa 50 hình ảnh của mỗi người (nếu không, việc trích xuất đặc trưng sẽ bị lấn át bởi khả năng xuất hiện của George W. Bush):</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">people</span><span class="o">.</span><span class="n">target</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
<span class="k">for</span> <span class="n">target</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">people</span><span class="o">.</span><span class="n">target</span><span class="p">):</span>
    <span class="n">mask</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">people</span><span class="o">.</span><span class="n">target</span> <span class="o">==</span> <span class="n">target</span><span class="p">)[</span><span class="mi">0</span><span class="p">][:</span><span class="mi">50</span><span class="p">]]</span> <span class="o">=</span> <span class="mi">1</span>

<span class="n">X_people</span> <span class="o">=</span> <span class="n">people</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span>
<span class="n">y_people</span> <span class="o">=</span> <span class="n">people</span><span class="o">.</span><span class="n">target</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span>

<span class="c1"># co giãn các giá trị thang độ xám để nằm trong khoảng từ 0 đến 1</span>
<span class="c1"># thay vì từ 0 đến 255 để ổn định số học tốt hơn</span>
<span class="n">X_people</span> <span class="o">=</span> <span class="n">X_people</span> <span class="o">/</span> <span class="mf">255.</span>
</pre></div>
</div>
</div>
</div>
<p>Một nhiệm vụ phổ biến trong nhận dạng khuôn mặt là hỏi xem một khuôn mặt chưa từng thấy trước đây có thuộc về một người đã biết trong cơ sở dữ liệu hay không. Điều này có ứng dụng trong các bộ sưu tập ảnh, phương tiện truyền thông xã hội và các ứng dụng bảo mật. Một cách để giải quyết vấn đề này là xây dựng một bộ phân loại trong đó mỗi người là một lớp riêng biệt. Tuy nhiên, thường có rất nhiều người khác nhau trong cơ sở dữ liệu khuôn mặt, và rất ít hình ảnh của cùng một người (tức là, rất ít ví dụ huấn luyện cho mỗi lớp). Điều đó làm cho việc huấn luyện hầu hết các bộ phân loại trở nên khó khăn. Ngoài ra, bạn thường muốn có thể thêm người mới một cách dễ dàng mà không cần phải huấn luyện lại một mô hình lớn.</p>
<p>Một giải pháp đơn giản là sử dụng một bộ phân loại k láng giềng gần nhất (one-nearest-neighbor) tìm kiếm hình ảnh khuôn mặt tương tự nhất với khuôn mặt bạn đang phân loại. Bộ phân loại này về nguyên tắc có thể hoạt động chỉ với một ví dụ huấn luyện cho mỗi lớp. Hãy xem <code class="docutils literal notranslate"><span class="pre">KNeighborsClassifier</span></code> hoạt động tốt như thế nào ở đây:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span><span class="w"> </span><span class="nn">sklearn.model_selection</span><span class="w"> </span><span class="kn">import</span> <span class="n">train_test_split</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">sklearn.neighbors</span><span class="w"> </span><span class="kn">import</span> <span class="n">KNeighborsClassifier</span>
<span class="c1"># chia dữ liệu thành tập huấn luyện và tập kiểm tra</span>
<span class="n">X_train</span><span class="p">,</span> <span class="n">X_test</span><span class="p">,</span> <span class="n">y_train</span><span class="p">,</span> <span class="n">y_test</span> <span class="o">=</span> <span class="n">train_test_split</span><span class="p">(</span>
    <span class="n">X_people</span><span class="p">,</span> <span class="n">y_people</span><span class="p">,</span> <span class="n">stratify</span><span class="o">=</span><span class="n">y_people</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="c1"># xây dựng một KNeighborsClassifier sử dụng một láng giềng</span>
<span class="n">knn</span> <span class="o">=</span> <span class="n">KNeighborsClassifier</span><span class="p">(</span><span class="n">n_neighbors</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="n">knn</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X_train</span><span class="p">,</span> <span class="n">y_train</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Test set score of 1-nn: </span><span class="si">{:.2f}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">knn</span><span class="o">.</span><span class="n">score</span><span class="p">(</span><span class="n">X_test</span><span class="p">,</span> <span class="n">y_test</span><span class="p">)))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Test set score of 1-nn: 0.14
</pre></div>
</div>
</div>
</div>
<p>Chúng ta đạt được độ chính xác 27%, thực ra không tệ đối với một bài toán phân loại 62 lớp (đoán ngẫu nhiên sẽ cho bạn độ chính xác khoảng 1/62 = 1.6%), nhưng cũng không tuyệt vời. Chúng ta chỉ nhận dạng đúng một người sau mỗi bốn lần thử.</p>
<p>Đây là lúc PCA phát huy tác dụng. Việc tính toán khoảng cách trong không gian pixel ban đầu là một cách khá tồi để đo lường sự tương đồng giữa các khuôn mặt. Khi sử dụng biểu diễn pixel để so sánh hai hình ảnh, chúng ta so sánh giá trị thang độ xám của từng pixel riêng lẻ với giá trị của pixel ở vị trí tương ứng trong hình ảnh kia. Biểu diễn này khá khác so với cách con người giải thích hình ảnh của một khuôn mặt, và rất khó để nắm bắt các đặc điểm trên khuôn mặt bằng cách sử dụng biểu diễn thô này. Ví dụ, sử dụng khoảng cách pixel có nghĩa là việc dịch chuyển một khuôn mặt sang phải một pixel tương ứng với một sự thay đổi mạnh mẽ, với một biểu diễn hoàn toàn khác. Chúng tôi hy vọng rằng việc sử dụng khoảng cách dọc theo các thành phần chính có thể cải thiện độ chính xác của chúng ta. Ở đây, chúng tôi kích hoạt tùy chọn <code class="docutils literal notranslate"><span class="pre">whitening</span></code> của PCA, giúp co giãn lại các thành phần chính để có cùng một thang đo. Điều này tương tự như việc sử dụng <code class="docutils literal notranslate"><span class="pre">StandardScaler</span></code> sau khi biến đổi. Sử dụng lại dữ liệu từ Hình 3-3, whitening không chỉ tương ứng với việc xoay dữ liệu mà còn co giãn lại nó để bảng điều khiển trung tâm là một vòng tròn thay vì một hình elip (xem Hình 3-8):</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">mglearn</span><span class="o">.</span><span class="n">plots</span><span class="o">.</span><span class="n">plot_pca_whitening</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../_images/f0e421a5f10cb78d74e192e1090768c1ad217c42201a533a3579f433ca306233.png" src="../_images/f0e421a5f10cb78d74e192e1090768c1ad217c42201a533a3579f433ca306233.png" />
</div>
</div>
<p>**Hình 3-8. Biến đổi dữ liệu bằng PCA sử dụng whitening **</p>
<p>Chúng tôi khớp đối tượng PCA với dữ liệu huấn luyện và trích xuất 100 thành phần chính đầu tiên. Sau đó, chúng tôi biến đổi dữ liệu huấn luyện và kiểm tra:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span><span class="w"> </span><span class="nn">sklearn.decomposition</span><span class="w"> </span><span class="kn">import</span> <span class="n">PCA</span>
<span class="n">pca</span> <span class="o">=</span> <span class="n">PCA</span><span class="p">(</span><span class="n">n_components</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">whiten</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X_train</span><span class="p">)</span>
<span class="n">X_train_pca</span> <span class="o">=</span> <span class="n">pca</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">X_train</span><span class="p">)</span>
<span class="n">X_test_pca</span> <span class="o">=</span> <span class="n">pca</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">X_test</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;X_train_pca.shape: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">X_train_pca</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>X_train_pca.shape: (1547, 100)
</pre></div>
</div>
</div>
</div>
<p>Dữ liệu mới có 100 đặc trưng, là 100 thành phần chính đầu tiên. Bây giờ, chúng ta có thể sử dụng biểu diễn mới để phân loại hình ảnh của mình bằng bộ phân loại một láng giềng gần nhất:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">knn</span> <span class="o">=</span> <span class="n">KNeighborsClassifier</span><span class="p">(</span><span class="n">n_neighbors</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="n">knn</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X_train_pca</span><span class="p">,</span> <span class="n">y_train</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Test set accuracy: </span><span class="si">{:.2f}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">knn</span><span class="o">.</span><span class="n">score</span><span class="p">(</span><span class="n">X_test_pca</span><span class="p">,</span> <span class="n">y_test</span><span class="p">)))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Test set accuracy: 0.15
</pre></div>
</div>
</div>
</div>
<p>Độ chính xác của chúng ta đã cải thiện khá đáng kể, từ 26.6% lên 31.3%, xác nhận trực giác của chúng ta rằng các thành phần chính có thể cung cấp một biểu diễn tốt hơn cho dữ liệu.</p>
<p>Đối với dữ liệu hình ảnh, chúng ta cũng có thể dễ dàng trực quan hóa các thành phần chính được tìm thấy. Hãy nhớ rằng các thành phần tương ứng với các hướng trong không gian đầu vào. Không gian đầu vào ở đây là các hình ảnh thang độ xám có kích thước 87x65 pixel, vì vậy các hướng trong không gian này cũng là các hình ảnh thang độ xám 87x65 pixel. Hãy xem xét một vài thành phần chính đầu tiên (Hình 3-9):</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="s2">&quot;pca.components_.shape: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">pca</span><span class="o">.</span><span class="n">components_</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>pca.components_.shape: (100, 5655)
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">fix</span><span class="p">,</span> <span class="n">axes</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">15</span><span class="p">,</span> <span class="mi">12</span><span class="p">),</span>
                       <span class="n">subplot_kw</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;xticks&#39;</span><span class="p">:</span> <span class="p">(),</span> <span class="s1">&#39;yticks&#39;</span><span class="p">:</span> <span class="p">()})</span>
<span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="n">component</span><span class="p">,</span> <span class="n">ax</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">pca</span><span class="o">.</span><span class="n">components_</span><span class="p">,</span> <span class="n">axes</span><span class="o">.</span><span class="n">ravel</span><span class="p">())):</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">component</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">image_shape</span><span class="p">),</span>
              <span class="n">cmap</span><span class="o">=</span><span class="s1">&#39;viridis&#39;</span><span class="p">)</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">{}</span><span class="s2">. component&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">((</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)))</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../_images/6dc7611e08a8f52edb51d77fbb11bd1d934197ce69850d4849b30f9dedd749d3.png" src="../_images/6dc7611e08a8f52edb51d77fbb11bd1d934197ce69850d4849b30f9dedd749d3.png" />
</div>
</div>
<p>**Hình 3-9. Các vector thành phần của 15 thành phần chính đầu tiên của tập dữ liệu khuôn mặt **</p>
<p>Mặc dù chúng ta chắc chắn không thể hiểu hết tất cả các khía cạnh của những thành phần này, chúng ta có thể đoán được một số khía cạnh của hình ảnh khuôn mặt mà một số thành phần đang nắm bắt. Thành phần đầu tiên dường như chủ yếu mã hóa sự tương phản giữa khuôn mặt và nền, thành phần thứ hai mã hóa sự khác biệt về ánh sáng giữa nửa bên phải và nửa bên trái của khuôn mặt, v.v.. Mặc dù biểu diễn này có phần ngữ nghĩa hơn so với các giá trị pixel thô, nó vẫn còn khá xa so với cách con người có thể cảm nhận một khuôn mặt. Vì mô hình PCA dựa trên pixel, việc căn chỉnh khuôn mặt (vị trí của mắt, cằm và mũi) và ánh sáng đều có ảnh hưởng mạnh mẽ đến mức độ tương tự của hai hình ảnh trong biểu diễn pixel của chúng. Nhưng việc căn chỉnh và ánh sáng có lẽ không phải là những gì con người sẽ cảm nhận đầu tiên. Khi yêu cầu mọi người đánh giá sự tương đồng của các khuôn mặt, họ có nhiều khả năng sử dụng các thuộc tính như tuổi tác, giới tính, biểu cảm khuôn mặt và kiểu tóc, là những thuộc tính khó suy ra từ cường độ pixel. Điều quan trọng cần ghi nhớ là các thuật toán thường diễn giải dữ liệu (đặc biệt là dữ liệu trực quan, chẳng hạn như hình ảnh, mà con người rất quen thuộc) hoàn toàn khác với cách con người làm.</p>
<p>Tuy nhiên, hãy quay lại trường hợp cụ thể của PCA. Chúng ta đã giới thiệu phép biến đổi PCA là xoay dữ liệu và sau đó loại bỏ các thành phần có phương sai thấp. Một cách diễn giải hữu ích khác là cố gắng tìm một số con số (các giá trị đặc trưng mới sau khi xoay PCA) để chúng ta có thể biểu diễn các điểm kiểm tra dưới dạng tổng có trọng số của các thành phần chính (xem Hình 3-10).</p>
<p>Ở đây, x₀, x₁, v.v. là các hệ số của các thành phần chính cho điểm dữ liệu này; nói cách khác, chúng là biểu diễn của hình ảnh trong không gian đã xoay.</p>
<p>**Hình 3-10. Sơ đồ PCA dưới dạng phân tách một hình ảnh thành tổng có trọng số của các thành phần **</p>
<p>Một cách khác chúng ta có thể cố gắng hiểu một mô hình PCA đang làm gì là bằng cách xem xét các tái tạo của dữ liệu gốc chỉ sử dụng một số thành phần. Trong Hình 3-3, sau khi loại bỏ thành phần thứ hai và đến bảng điều khiển thứ ba, chúng ta đã hoàn tác phép xoay và cộng lại giá trị trung bình để thu được các điểm mới trong không gian ban đầu với thành phần thứ hai bị loại bỏ, như được hiển thị trong bảng điều khiển cuối cùng. Chúng ta có thể thực hiện một phép biến đổi tương tự cho các khuôn mặt bằng cách giảm dữ liệu xuống chỉ còn một số thành phần chính và sau đó xoay trở lại không gian ban đầu. Việc quay trở lại không gian đặc trưng ban đầu này có thể được thực hiện bằng phương thức <code class="docutils literal notranslate"><span class="pre">inverse_transform</span></code>. Ở đây, chúng ta trực quan hóa việc tái tạo một số khuôn mặt bằng cách sử dụng 10, 50, 100, hoặc 2.000 thành phần (Hình 3-11):</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Tái tạo lại X_train, X_test từ phiên bản đã giảm chiều để minh họa</span>
<span class="n">pca_for_plot</span> <span class="o">=</span> <span class="n">PCA</span><span class="p">(</span><span class="n">n_components</span><span class="o">=</span><span class="mi">150</span><span class="p">,</span> <span class="n">whiten</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X_train</span><span class="p">)</span>
<span class="n">X_train_pca_for_plot</span> <span class="o">=</span> <span class="n">pca_for_plot</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">X_train</span><span class="p">)</span>
<span class="n">X_test_pca_for_plot</span> <span class="o">=</span> <span class="n">pca_for_plot</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">X_test</span><span class="p">)</span>

<span class="n">mglearn</span><span class="o">.</span><span class="n">plots</span><span class="o">.</span><span class="n">plot_pca_faces</span><span class="p">(</span><span class="n">X_train</span><span class="p">,</span> <span class="n">X_test</span><span class="p">,</span> <span class="n">image_shape</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>________________________________________________________________________________
[Memory] Calling mglearn.plot_pca.pca_faces...
pca_faces(array([[3.183391e-03, ..., 7.689351e-05],
       ...,
       [1.896706e-04, ..., 0.000000e+00]], dtype=float32), 
array([[0.000000e+00, ..., 0.000000e+00],
       ...,
       [2.050493e-05, ..., 3.019352e-03]], dtype=float32))
________________________________________________________pca_faces - 1.2s, 0.0min
</pre></div>
</div>
<img alt="../_images/e0a64fc54bb86ff1e5d8ca1e3e88a0f24d4ff1276da61d8f4aefdfa61369f5a4.png" src="../_images/e0a64fc54bb86ff1e5d8ca1e3e88a0f24d4ff1276da61d8f4aefdfa61369f5a4.png" />
</div>
</div>
<p>**Hình 3-11. Tái tạo ba hình ảnh khuôn mặt bằng cách sử dụng số lượng thành phần chính ngày càng tăng **</p>
<p>Bạn có thể thấy rằng khi chúng ta chỉ sử dụng 10 thành phần chính đầu tiên, chỉ có bản chất của bức ảnh, như hướng khuôn mặt và ánh sáng, được ghi lại. Bằng cách sử dụng ngày càng nhiều thành phần chính, ngày càng nhiều chi tiết trong hình ảnh được bảo toàn. Điều này tương ứng với việc mở rộng tổng trong Hình 3-10 để bao gồm ngày càng nhiều số hạng. Sử dụng số lượng thành phần bằng số lượng pixel có nghĩa là chúng ta sẽ không loại bỏ bất kỳ thông tin nào sau khi xoay, và chúng ta sẽ tái tạo lại hình ảnh một cách hoàn hảo.</p>
<p>Chúng ta cũng có thể thử sử dụng PCA để trực quan hóa tất cả các khuôn mặt trong tập dữ liệu trong một biểu đồ phân tán bằng cách sử dụng hai thành phần chính đầu tiên (Hình 3-12), với các lớp được đưa ra bởi người được hiển thị trong hình ảnh, tương tự như những gì chúng ta đã làm cho tập dữ liệu ung thư:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">mglearn</span><span class="o">.</span><span class="n">discrete_scatter</span><span class="p">(</span><span class="n">X_train_pca</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">X_train_pca</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">y_train</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s2">&quot;Thành phần chính thứ nhất&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s2">&quot;Thành phần chính thứ hai&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../_images/5470a0d40cd5daec5aa958276be20df40e992fbb76885cbd64aa00a5aa2b405d.png" src="../_images/5470a0d40cd5daec5aa958276be20df40e992fbb76885cbd64aa00a5aa2b405d.png" />
</div>
</div>
<p>**Hình 3-12. Biểu đồ phân tán của tập dữ liệu khuôn mặt sử dụng hai thành phần chính đầu tiên (xem Hình 3-5 để biết hình ảnh tương ứng cho tập dữ liệu ung thư) **</p>
<p>Như bạn có thể thấy, khi chúng ta chỉ sử dụng hai thành phần chính đầu tiên, toàn bộ dữ liệu chỉ là một khối lớn, không có sự phân tách các lớp nào có thể nhìn thấy. Điều này không có gì đáng ngạc nhiên, vì ngay cả với 10 thành phần, như đã trình bày trước đó trong Hình 3-11, PCA chỉ nắm bắt được các đặc điểm rất thô của khuôn mặt.</p>
</section>
</section>
<section id="phan-ra-ma-tran-khong-am-nmf">
<h3>Phân rã Ma trận không âm (NMF)<a class="headerlink" href="#phan-ra-ma-tran-khong-am-nmf" title="Link to this heading">#</a></h3>
<p>Phân rã ma trận không âm là một thuật toán học không giám sát khác nhằm mục đích trích xuất các đặc trưng hữu ích. Nó hoạt động tương tự như PCA và cũng có thể được sử dụng để giảm chiều. Giống như trong PCA, chúng ta đang cố gắng viết mỗi điểm dữ liệu dưới dạng tổng có trọng số của một số thành phần, như được minh họa trong Hình 3-10. Nhưng trong khi ở PCA, chúng ta muốn các thành phần trực giao và giải thích càng nhiều phương sai của dữ liệu càng tốt, thì trong NMF, chúng ta muốn các thành phần và hệ số là không âm; tức là, chúng ta muốn cả thành phần và hệ số đều lớn hơn hoặc bằng không. Do đó, phương pháp này chỉ có thể được áp dụng cho dữ liệu mà mỗi đặc trưng là không âm, vì một tổng không âm của các thành phần không âm không thể trở thành âm.</p>
<p>Quá trình phân rã dữ liệu thành một tổng có trọng số không âm đặc biệt hữu ích cho dữ liệu được tạo ra dưới dạng phép cộng (hoặc chồng chéo) của một số nguồn độc lập, chẳng hạn như một bản âm thanh của nhiều người nói, hoặc âm nhạc có nhiều nhạc cụ. Trong những tình huống này, NMF có thể xác định các thành phần ban đầu tạo nên dữ liệu kết hợp. Nhìn chung, NMF dẫn đến các thành phần dễ diễn giải hơn PCA, vì các thành phần và hệ số âm có thể dẫn đến các hiệu ứng triệt tiêu khó diễn giải. Ví dụ, các eigenfaces trong Hình 3-9 chứa cả phần dương và phần âm, và như chúng ta đã đề cập trong mô tả về PCA, dấu thực sự là tùy ý. Trước khi chúng ta áp dụng NMF cho tập dữ liệu khuôn mặt, hãy xem lại ngắn gọn dữ liệu tổng hợp.</p>
<section id="ap-dung-nmf-cho-du-lieu-tong-hop">
<h4>Áp dụng NMF cho dữ liệu tổng hợp<a class="headerlink" href="#ap-dung-nmf-cho-du-lieu-tong-hop" title="Link to this heading">#</a></h4>
<p>Trái ngược với khi sử dụng PCA, chúng ta cần đảm bảo rằng dữ liệu của chúng ta là dương để NMF có thể hoạt động trên dữ liệu. Điều này có nghĩa là vị trí dữ liệu so với gốc tọa độ (0, 0) thực sự quan trọng đối với NMF. Do đó, bạn có thể nghĩ về các thành phần không âm được trích xuất là các hướng từ (0, 0) về phía dữ liệu.</p>
<p>Ví dụ sau (Hình 3-13) cho thấy kết quả của NMF trên dữ liệu đồ chơi hai chiều:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">mglearn</span><span class="o">.</span><span class="n">plots</span><span class="o">.</span><span class="n">plot_nmf_illustration</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stderr highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>c:\Users\Admin\anaconda3\envs\tf-gpu\lib\site-packages\sklearn\decomposition\_nmf.py:1692: ConvergenceWarning: Maximum number of iterations 200 reached. Increase it to improve convergence.
  warnings.warn(
</pre></div>
</div>
<img alt="../_images/f7d7f066d9d96406e2e06ff4e321564928992cd3f46a2ac97d39998f5e75c92a.png" src="../_images/f7d7f066d9d96406e2e06ff4e321564928992cd3f46a2ac97d39998f5e75c92a.png" />
</div>
</div>
<p>**Hình 3-13. Các thành phần được tìm thấy bởi phân rã ma trận không âm với hai thành phần (trái) và một thành phần (phải) **</p>
<p>Đối với NMF có hai thành phần, như hình bên trái, rõ ràng là tất cả các điểm trong dữ liệu có thể được viết dưới dạng một tổ hợp dương của hai thành phần. Nếu có đủ thành phần để tái tạo hoàn hảo dữ liệu (số lượng thành phần bằng số lượng đặc trưng), thuật toán sẽ chọn các hướng chỉ về các điểm cực trị của dữ liệu. Nếu chúng ta chỉ sử dụng một thành phần, NMF sẽ tạo ra một thành phần chỉ về phía trung bình, vì việc chỉ về đó giải thích dữ liệu tốt nhất. Bạn có thể thấy rằng trái ngược với PCA, việc giảm số lượng thành phần không chỉ loại bỏ một số hướng mà còn tạo ra một tập hợp các thành phần hoàn toàn khác!  Các thành phần trong NMF cũng không được sắp xếp theo bất kỳ thứ tự cụ thể nào, vì vậy không có “thành phần không âm thứ nhất”: tất cả các thành phần đều đóng một vai trò như nhau. NMF sử dụng một khởi tạo ngẫu nhiên, có thể dẫn đến các kết quả khác nhau tùy thuộc vào hạt giống ngẫu nhiên. Trong các trường hợp tương đối đơn giản như dữ liệu tổng hợp có hai thành phần, nơi tất cả dữ liệu có thể được giải thích một cách hoàn hảo, tính ngẫu nhiên có ít ảnh hưởng (mặc dù nó có thể thay đổi thứ tự hoặc thang đo của các thành phần). Trong các tình huống phức tạp hơn, có thể có những thay đổi mạnh mẽ hơn.</p>
</section>
<section id="ap-dung-nmf-cho-hinh-anh-khuon-mat">
<h4>Áp dụng NMF cho hình ảnh khuôn mặt<a class="headerlink" href="#ap-dung-nmf-cho-hinh-anh-khuon-mat" title="Link to this heading">#</a></h4>
<p>Bây giờ, hãy áp dụng NMF cho tập dữ liệu Labeled Faces in the Wild mà chúng ta đã sử dụng trước đó. Tham số chính của NMF là số lượng thành phần chúng ta muốn trích xuất. Thường thì con số này thấp hơn số lượng đặc trưng đầu vào (nếu không, dữ liệu có thể được giải thích bằng cách coi mỗi pixel là một thành phần riêng biệt). Đầu tiên, hãy kiểm tra xem số lượng thành phần ảnh hưởng như thế nào đến khả năng tái tạo dữ liệu bằng NMF (Hình 3-14):</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Code from the previous part to have the necessary variables</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">sklearn.datasets</span><span class="w"> </span><span class="kn">import</span> <span class="n">fetch_lfw_people</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="n">people</span> <span class="o">=</span> <span class="n">fetch_lfw_people</span><span class="p">(</span><span class="n">min_faces_per_person</span><span class="o">=</span><span class="mi">20</span><span class="p">,</span> <span class="n">resize</span><span class="o">=</span><span class="mf">0.7</span><span class="p">)</span>
<span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">people</span><span class="o">.</span><span class="n">target</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
<span class="k">for</span> <span class="n">target</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">people</span><span class="o">.</span><span class="n">target</span><span class="p">):</span>
    <span class="n">mask</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">people</span><span class="o">.</span><span class="n">target</span> <span class="o">==</span> <span class="n">target</span><span class="p">)[</span><span class="mi">0</span><span class="p">][:</span><span class="mi">50</span><span class="p">]]</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">X_people</span> <span class="o">=</span> <span class="n">people</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span>
<span class="n">y_people</span> <span class="o">=</span> <span class="n">people</span><span class="o">.</span><span class="n">target</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span>
<span class="n">X_people</span> <span class="o">=</span> <span class="n">X_people</span> <span class="o">/</span> <span class="mf">255.</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">sklearn.model_selection</span><span class="w"> </span><span class="kn">import</span> <span class="n">train_test_split</span>
<span class="n">X_train</span><span class="p">,</span> <span class="n">X_test</span><span class="p">,</span> <span class="n">y_train</span><span class="p">,</span> <span class="n">y_test</span> <span class="o">=</span> <span class="n">train_test_split</span><span class="p">(</span>
    <span class="n">X_people</span><span class="p">,</span> <span class="n">y_people</span><span class="p">,</span> <span class="n">stratify</span><span class="o">=</span><span class="n">y_people</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="n">image_shape</span> <span class="o">=</span> <span class="n">people</span><span class="o">.</span><span class="n">images</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">mglearn</span>
<span class="n">mglearn</span><span class="o">.</span><span class="n">plots</span><span class="o">.</span><span class="n">plot_nmf_faces</span><span class="p">(</span><span class="n">X_train</span><span class="p">,</span> <span class="n">X_test</span><span class="p">,</span> <span class="n">image_shape</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>________________________________________________________________________________
[Memory] Calling mglearn.plot_nmf.nmf_faces...
nmf_faces(array([[3.183391e-03, ..., 7.689351e-05],
       ...,
       [1.896706e-04, ..., 0.000000e+00]], dtype=float32), 
array([[0.000000e+00, ..., 0.000000e+00],
       ...,
       [2.050493e-05, ..., 3.019352e-03]], dtype=float32))
</pre></div>
</div>
<div class="output stderr highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>c:\Users\Admin\anaconda3\envs\tf-gpu\lib\site-packages\sklearn\decomposition\_nmf.py:1692: ConvergenceWarning: Maximum number of iterations 200 reached. Increase it to improve convergence.
  warnings.warn(
c:\Users\Admin\anaconda3\envs\tf-gpu\lib\site-packages\sklearn\decomposition\_nmf.py:1692: ConvergenceWarning: Maximum number of iterations 200 reached. Increase it to improve convergence.
  warnings.warn(
c:\Users\Admin\anaconda3\envs\tf-gpu\lib\site-packages\sklearn\decomposition\_nmf.py:1692: ConvergenceWarning: Maximum number of iterations 200 reached. Increase it to improve convergence.
  warnings.warn(
c:\Users\Admin\anaconda3\envs\tf-gpu\lib\site-packages\sklearn\decomposition\_nmf.py:1692: ConvergenceWarning: Maximum number of iterations 200 reached. Increase it to improve convergence.
  warnings.warn(
</pre></div>
</div>
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>______________________________________________________nmf_faces - 444.5s, 7.4min
</pre></div>
</div>
<img alt="../_images/860f310294c97e9c3682291e4714d7da8b7bbc756e6f39e9cc2e0956879e037b.png" src="../_images/860f310294c97e9c3682291e4714d7da8b7bbc756e6f39e9cc2e0956879e037b.png" />
</div>
</div>
<p><strong>Hình 3-14. Tái tạo ba hình ảnh khuôn mặt bằng cách sử dụng số lượng thành phần tăng dần được tìm thấy bởi NMF</strong></p>
<p>Chất lượng của dữ liệu được biến đổi ngược lại tương tự như khi sử dụng PCA, nhưng hơi tệ hơn một chút. Điều này là có thể dự đoán được, vì PCA tìm ra các hướng tối ưu về mặt tái tạo. NMF thường không được sử dụng vì khả năng tái tạo hoặc mã hóa dữ liệu, mà là để tìm ra các mẫu thú vị trong dữ liệu.</p>
<p>Để có cái nhìn đầu tiên về dữ liệu, hãy thử trích xuất chỉ một vài thành phần (ví dụ: 15). Hình 3-15 cho thấy kết quả:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span><span class="w"> </span><span class="nn">sklearn.decomposition</span><span class="w"> </span><span class="kn">import</span> <span class="n">NMF</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">matplotlib.pyplot</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">plt</span>

<span class="n">nmf</span> <span class="o">=</span> <span class="n">NMF</span><span class="p">(</span><span class="n">n_components</span><span class="o">=</span><span class="mi">15</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">max_iter</span><span class="o">=</span><span class="mi">1000</span><span class="p">,</span> <span class="n">tol</span><span class="o">=</span><span class="mf">1e-2</span><span class="p">)</span> <span class="c1"># Added max_iter and tol for convergence</span>
<span class="n">nmf</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X_train</span><span class="p">)</span>
<span class="n">X_train_nmf</span> <span class="o">=</span> <span class="n">nmf</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">X_train</span><span class="p">)</span>
<span class="n">X_test_nmf</span> <span class="o">=</span> <span class="n">nmf</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">X_test</span><span class="p">)</span>

<span class="n">fix</span><span class="p">,</span> <span class="n">axes</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">15</span><span class="p">,</span> <span class="mi">12</span><span class="p">),</span>
                       <span class="n">subplot_kw</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;xticks&#39;</span><span class="p">:</span> <span class="p">(),</span> <span class="s1">&#39;yticks&#39;</span><span class="p">:</span> <span class="p">()})</span>
<span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="n">component</span><span class="p">,</span> <span class="n">ax</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">nmf</span><span class="o">.</span><span class="n">components_</span><span class="p">,</span> <span class="n">axes</span><span class="o">.</span><span class="n">ravel</span><span class="p">())):</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">component</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">image_shape</span><span class="p">),</span> <span class="n">cmap</span><span class="o">=</span><span class="s1">&#39;gray&#39;</span><span class="p">)</span> <span class="c1"># Changed cmap for better visualization</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">{}</span><span class="s2">. component&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">i</span><span class="p">))</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../_images/09ea55a4f46177e19132a2dd607685f0762d4f0314034e7e649e832db4c8a989.png" src="../_images/09ea55a4f46177e19132a2dd607685f0762d4f0314034e7e649e832db4c8a989.png" />
</div>
</div>
<p><strong>Hình 3-15. Các thành phần được tìm thấy bởi NMF trên tập dữ liệu khuôn mặt khi sử dụng 15 thành phần</strong></p>
<p>Các thành phần này đều là dương, và do đó giống với các nguyên mẫu của khuôn mặt hơn nhiều so với các thành phần được hiển thị cho PCA trong Hình 3-9. Ví dụ, người ta có thể thấy rõ rằng thành phần 3 cho thấy một khuôn mặt xoay hơi sang phải, trong khi thành phần 7 cho thấy một khuôn mặt hơi xoay sang trái. Hãy xem các hình ảnh mà các thành phần này đặc biệt mạnh, được hiển thị trong Hình 3-16 và 3-17:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Hình 3-16</span>
<span class="n">compn</span> <span class="o">=</span> <span class="mi">3</span>
<span class="c1"># sắp xếp theo thành phần thứ 3, vẽ 10 hình ảnh đầu tiên</span>
<span class="n">inds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">X_train_nmf</span><span class="p">[:,</span> <span class="n">compn</span><span class="p">])[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
<span class="n">fig</span><span class="p">,</span> <span class="n">axes</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">15</span><span class="p">,</span> <span class="mi">8</span><span class="p">),</span>
                       <span class="n">subplot_kw</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;xticks&#39;</span><span class="p">:</span> <span class="p">(),</span> <span class="s1">&#39;yticks&#39;</span><span class="p">:</span> <span class="p">()})</span>
<span class="n">fig</span><span class="o">.</span><span class="n">suptitle</span><span class="p">(</span><span class="s2">&quot;Các khuôn mặt có hệ số lớn cho thành phần 3&quot;</span><span class="p">)</span>
<span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="n">ind</span><span class="p">,</span> <span class="n">ax</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">inds</span><span class="p">,</span> <span class="n">axes</span><span class="o">.</span><span class="n">ravel</span><span class="p">())):</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">X_train</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">image_shape</span><span class="p">),</span> <span class="n">cmap</span><span class="o">=</span><span class="s1">&#39;gray&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>

<span class="c1"># Hình 3-17</span>
<span class="n">compn</span> <span class="o">=</span> <span class="mi">7</span>
<span class="c1"># sắp xếp theo thành phần thứ 7, vẽ 10 hình ảnh đầu tiên</span>
<span class="n">inds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">X_train_nmf</span><span class="p">[:,</span> <span class="n">compn</span><span class="p">])[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
<span class="n">fig</span><span class="p">,</span> <span class="n">axes</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">15</span><span class="p">,</span> <span class="mi">8</span><span class="p">),</span>
                       <span class="n">subplot_kw</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;xticks&#39;</span><span class="p">:</span> <span class="p">(),</span> <span class="s1">&#39;yticks&#39;</span><span class="p">:</span> <span class="p">()})</span>
<span class="n">fig</span><span class="o">.</span><span class="n">suptitle</span><span class="p">(</span><span class="s2">&quot;Các khuôn mặt có hệ số lớn cho thành phần 7&quot;</span><span class="p">)</span>
<span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="n">ind</span><span class="p">,</span> <span class="n">ax</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">inds</span><span class="p">,</span> <span class="n">axes</span><span class="o">.</span><span class="n">ravel</span><span class="p">())):</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">X_train</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">image_shape</span><span class="p">),</span> <span class="n">cmap</span><span class="o">=</span><span class="s1">&#39;gray&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../_images/efcb772f09961f8fa04bb2f1fc7ddac0757ae981b4c82ff6309d11dc5e4e3600.png" src="../_images/efcb772f09961f8fa04bb2f1fc7ddac0757ae981b4c82ff6309d11dc5e4e3600.png" />
<img alt="../_images/1f834f2d91c2248e5d6ab75cb6ab3b1dbbc2ef0380e670d0e0dd2ad7ec7bfd33.png" src="../_images/1f834f2d91c2248e5d6ab75cb6ab3b1dbbc2ef0380e670d0e0dd2ad7ec7bfd33.png" />
</div>
</div>
<p><strong>Hình 3-16. Các khuôn mặt có hệ số lớn cho thành phần 3</strong></p>
<p><strong>Hình 3-17. Các khuôn mặt có hệ số lớn cho thành phần 7</strong></p>
<p>Như mong đợi, các khuôn mặt có hệ số cao cho thành phần 3 là các khuôn mặt nhìn sang phải (Hình 3-16), trong khi các khuôn mặt có hệ số cao cho thành phần 7 là nhìn sang trái (Hình 3-17). Như đã đề cập trước đó, việc trích xuất các mẫu như thế này hoạt động tốt nhất cho dữ liệu có cấu trúc cộng, bao gồm dữ liệu âm thanh, biểu hiện gen và văn bản. Hãy xem qua một ví dụ trên dữ liệu tổng hợp để xem nó có thể trông như thế nào. Giả sử chúng ta quan tâm đến một tín hiệu là sự kết hợp của ba nguồn khác nhau (Hình 3-18):</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">S</span> <span class="o">=</span> <span class="n">mglearn</span><span class="o">.</span><span class="n">datasets</span><span class="o">.</span><span class="n">make_signals</span><span class="p">()</span>
<span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">S</span><span class="p">,</span> <span class="s1">&#39;-&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s2">&quot;Thời gian&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s2">&quot;Tín hiệu&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../_images/bc98b894d0f3fd72bc527ef132ec20e84612a8bd4bc2d9675f6d33898ddcf2c3.png" src="../_images/bc98b894d0f3fd72bc527ef132ec20e84612a8bd4bc2d9675f6d33898ddcf2c3.png" />
</div>
</div>
<p><strong>Hình 3-18. Các nguồn tín hiệu gốc</strong></p>
<p>Thật không may, chúng ta không thể quan sát các tín hiệu gốc, mà chỉ có một hỗn hợp cộng của cả ba tín hiệu. Chúng ta muốn khôi phục lại sự phân rã của tín hiệu hỗn hợp thành các thành phần gốc. Chúng ta giả định rằng chúng ta có nhiều cách khác nhau để quan sát hỗn hợp (giả sử 100 thiết bị đo lường), mỗi thiết bị cung cấp cho chúng ta một chuỗi các phép đo:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># trộn dữ liệu vào một trạng thái 100 chiều</span>
<span class="n">A</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">RandomState</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
<span class="n">X</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">S</span><span class="p">,</span> <span class="n">A</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Shape of measurements: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Shape of measurements: (2000, 100)
</pre></div>
</div>
</div>
</div>
<p>Chúng ta có thể sử dụng NMF để khôi phục ba tín hiệu:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">nmf</span> <span class="o">=</span> <span class="n">NMF</span><span class="p">(</span><span class="n">n_components</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="mi">42</span><span class="p">)</span>
<span class="n">S_</span> <span class="o">=</span> <span class="n">nmf</span><span class="o">.</span><span class="n">fit_transform</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Recovered signal shape: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">S_</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Recovered signal shape: (2000, 3)
</pre></div>
</div>
</div>
</div>
<p>Để so sánh, chúng ta cũng áp dụng PCA:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">pca</span> <span class="o">=</span> <span class="n">PCA</span><span class="p">(</span><span class="n">n_components</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
<span class="n">H</span> <span class="o">=</span> <span class="n">pca</span><span class="o">.</span><span class="n">fit_transform</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>Hình 3-19 cho thấy hoạt động tín hiệu được phát hiện bởi NMF và PCA:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">models</span> <span class="o">=</span> <span class="p">[</span><span class="n">X</span><span class="p">,</span> <span class="n">S</span><span class="p">,</span> <span class="n">S_</span><span class="p">,</span> <span class="n">H</span><span class="p">]</span>
<span class="n">names</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;Các quan sát (ba phép đo đầu tiên)&#39;</span><span class="p">,</span>
         <span class="s1">&#39;Nguồn thực&#39;</span><span class="p">,</span>
         <span class="s1">&#39;Tín hiệu được khôi phục bởi NMF&#39;</span><span class="p">,</span>
         <span class="s1">&#39;Tín hiệu được khôi phục bởi PCA&#39;</span><span class="p">]</span>

<span class="n">fig</span><span class="p">,</span> <span class="n">axes</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="mi">4</span><span class="p">),</span> <span class="n">gridspec_kw</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;hspace&#39;</span><span class="p">:</span> <span class="mf">.5</span><span class="p">},</span>
                       <span class="n">subplot_kw</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;xticks&#39;</span><span class="p">:</span> <span class="p">(),</span> <span class="s1">&#39;yticks&#39;</span><span class="p">:</span> <span class="p">()})</span>
<span class="k">for</span> <span class="n">model</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">ax</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">models</span><span class="p">,</span> <span class="n">names</span><span class="p">,</span> <span class="n">axes</span><span class="p">):</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">model</span><span class="p">[:,</span> <span class="p">:</span><span class="mi">3</span><span class="p">],</span> <span class="s1">&#39;-&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../_images/03dc5a26ffff630072339be0e781d3fdffb1f39043befa2e508f35b35a514ee7.png" src="../_images/03dc5a26ffff630072339be0e781d3fdffb1f39043befa2e508f35b35a514ee7.png" />
</div>
</div>
<p><strong>Hình 3-19. Khôi phục các nguồn hỗn hợp bằng NMF và PCA</strong></p>
<p>Hình vẽ bao gồm 3 trong số 100 phép đo từ X để tham khảo. Như bạn có thể thấy, NMF đã làm khá tốt trong việc khám phá các nguồn gốc, trong khi PCA đã thất bại và sử dụng thành phần đầu tiên để giải thích phần lớn sự biến đổi trong dữ liệu. Hãy nhớ rằng các thành phần được tạo ra bởi NMF không có thứ tự tự nhiên. Trong ví dụ này, thứ tự của các thành phần NMF giống như trong tín hiệu gốc (xem màu của ba đường cong), nhưng điều này hoàn toàn là tình cờ.</p>
<p>Có nhiều thuật toán khác có thể được sử dụng để phân rã mỗi điểm dữ liệu thành một tổng có trọng số của một tập hợp các thành phần cố định, như PCA và NMF đã làm. Thảo luận về tất cả chúng nằm ngoài phạm vi của cuốn sách này, và mô tả các ràng buộc được đặt ra cho các thành phần và hệ số thường liên quan đến lý thuyết xác suất. Nếu bạn quan tâm đến loại trích xuất mẫu này, chúng tôi khuyên bạn nên nghiên cứu các phần của hướng dẫn sử dụng scikit-learn về phân tích thành phần độc lập (ICA), phân tích nhân tố (FA), và mã hóa thưa (học từ điển), tất cả đều có thể tìm thấy trên trang về các phương pháp phân rã.</p>
</section>
</section>
<section id="hoc-da-tap-manifold-learning-voi-t-sne">
<h3>Học Đa tạp (Manifold Learning) với t-SNE<a class="headerlink" href="#hoc-da-tap-manifold-learning-voi-t-sne" title="Link to this heading">#</a></h3>
<p>Mặc dù PCA thường là một phương pháp tiếp cận đầu tiên tốt để biến đổi dữ liệu của bạn để bạn có thể trực quan hóa nó bằng biểu đồ phân tán, bản chất của phương pháp (áp dụng một phép xoay và sau đó loại bỏ các hướng) giới hạn tính hữu dụng của nó, như chúng ta đã thấy với biểu đồ phân tán của tập dữ liệu Labeled Faces in the Wild. Có một lớp các thuật toán để trực quan hóa được gọi là các thuật toán học đa tạp cho phép các ánh xạ phức tạp hơn nhiều, và thường cung cấp các trực quan hóa tốt hơn. Một thuật toán đặc biệt hữu ích là thuật toán t-SNE.</p>
<p>Các thuật toán học đa tạp chủ yếu nhằm mục đích trực quan hóa, và do đó hiếm khi được sử dụng để tạo ra nhiều hơn hai đặc trưng mới. Một số trong số chúng, bao gồm t-SNE, tính toán một biểu diễn mới của dữ liệu huấn luyện, nhưng không cho phép biến đổi dữ liệu mới. Điều này có nghĩa là các thuật toán này không thể được áp dụng cho một tập kiểm tra: thay vào đó, chúng chỉ có thể biến đổi dữ liệu mà chúng đã được huấn luyện. Học đa tạp có thể hữu ích cho phân tích dữ liệu khám phá, nhưng hiếm khi được sử dụng nếu mục tiêu cuối cùng là học có giám sát.</p>
<p>Ý tưởng đằng sau t-SNE là tìm một biểu diễn hai chiều của dữ liệu mà bảo toàn khoảng cách giữa các điểm một cách tốt nhất có thể. t-SNE bắt đầu với một biểu diễn hai chiều ngẫu nhiên cho mỗi điểm dữ liệu, và sau đó cố gắng làm cho các điểm gần nhau trong không gian đặc trưng ban đầu gần nhau hơn, và các điểm xa nhau trong không gian đặc trưng ban đầu xa nhau hơn. t-SNE nhấn mạnh nhiều hơn vào các điểm gần nhau, thay vì bảo toàn khoảng cách giữa các điểm xa nhau. Nói cách khác, nó cố gắng bảo toàn thông tin cho biết điểm nào là láng giềng của nhau.</p>
<p>Chúng ta sẽ áp dụng thuật toán học đa tạp t-SNE trên một tập dữ liệu chữ số viết tay² được bao gồm trong scikit-learn. Mỗi điểm dữ liệu trong tập dữ liệu này là một hình ảnh thang độ xám 8x8 của một chữ số viết tay từ 0 đến 9. Hình 3-20 cho thấy một hình ảnh ví dụ cho mỗi lớp:</p>
<hr class="docutils" />
<p>² Không nên nhầm lẫn với tập dữ liệu MNIST lớn hơn nhiều.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span><span class="w"> </span><span class="nn">sklearn.datasets</span><span class="w"> </span><span class="kn">import</span> <span class="n">load_digits</span>
<span class="n">digits</span> <span class="o">=</span> <span class="n">load_digits</span><span class="p">()</span>

<span class="n">fig</span><span class="p">,</span> <span class="n">axes</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">5</span><span class="p">),</span>
                       <span class="n">subplot_kw</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;xticks&#39;</span><span class="p">:</span> <span class="p">(),</span> <span class="s1">&#39;yticks&#39;</span><span class="p">:</span> <span class="p">()})</span>
<span class="k">for</span> <span class="n">ax</span><span class="p">,</span> <span class="n">img</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">axes</span><span class="o">.</span><span class="n">ravel</span><span class="p">(),</span> <span class="n">digits</span><span class="o">.</span><span class="n">images</span><span class="p">):</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="s1">&#39;gray&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../_images/76a3ec7d1547abba9c75bda4f61ebd1fedd46425ab63b0618b9bfd08d9afd83b.png" src="../_images/76a3ec7d1547abba9c75bda4f61ebd1fedd46425ab63b0618b9bfd08d9afd83b.png" />
</div>
</div>
<p><strong>Hình 3-20. Hình ảnh ví dụ từ tập dữ liệu digits</strong></p>
<p>Hãy sử dụng PCA để trực quan hóa dữ liệu được giảm xuống hai chiều. Chúng ta vẽ hai thành phần chính đầu tiên, và tô màu mỗi chấm theo lớp của nó (xem Hình 3-21):</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># xây dựng một mô hình PCA</span>
<span class="n">pca</span> <span class="o">=</span> <span class="n">PCA</span><span class="p">(</span><span class="n">n_components</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="n">pca</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">digits</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>
<span class="c1"># biến đổi dữ liệu digits lên hai thành phần chính đầu tiên</span>
<span class="n">digits_pca</span> <span class="o">=</span> <span class="n">pca</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">digits</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>
<span class="n">colors</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;#476A2A&quot;</span><span class="p">,</span> <span class="s2">&quot;#7851B8&quot;</span><span class="p">,</span> <span class="s2">&quot;#BD3430&quot;</span><span class="p">,</span> <span class="s2">&quot;#4A2D4E&quot;</span><span class="p">,</span> <span class="s2">&quot;#875525&quot;</span><span class="p">,</span>
          <span class="s2">&quot;#A83683&quot;</span><span class="p">,</span> <span class="s2">&quot;#4E655E&quot;</span><span class="p">,</span> <span class="s2">&quot;#853541&quot;</span><span class="p">,</span> <span class="s2">&quot;#3A3120&quot;</span><span class="p">,</span> <span class="s2">&quot;#535D8E&quot;</span><span class="p">]</span>
<span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">))</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlim</span><span class="p">(</span><span class="n">digits_pca</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">min</span><span class="p">(),</span> <span class="n">digits_pca</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">max</span><span class="p">())</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylim</span><span class="p">(</span><span class="n">digits_pca</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">min</span><span class="p">(),</span> <span class="n">digits_pca</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">max</span><span class="p">())</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">digits</span><span class="o">.</span><span class="n">data</span><span class="p">)):</span>
    <span class="c1"># thực sự vẽ các chữ số dưới dạng văn bản thay vì sử dụng scatter</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">text</span><span class="p">(</span><span class="n">digits_pca</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">digits_pca</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="nb">str</span><span class="p">(</span><span class="n">digits</span><span class="o">.</span><span class="n">target</span><span class="p">[</span><span class="n">i</span><span class="p">]),</span>
             <span class="n">color</span><span class="o">=</span><span class="n">colors</span><span class="p">[</span><span class="n">digits</span><span class="o">.</span><span class="n">target</span><span class="p">[</span><span class="n">i</span><span class="p">]],</span>
             <span class="n">fontdict</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;weight&#39;</span><span class="p">:</span> <span class="s1">&#39;bold&#39;</span><span class="p">,</span> <span class="s1">&#39;size&#39;</span><span class="p">:</span> <span class="mi">9</span><span class="p">})</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s2">&quot;Thành phần chính thứ nhất&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s2">&quot;Thành phần chính thứ hai&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../_images/9f6d20b69b6a16c13abd72d0270c204c443a1426ed54a0ffdcbd79fe120abad5.png" src="../_images/9f6d20b69b6a16c13abd72d0270c204c443a1426ed54a0ffdcbd79fe120abad5.png" />
</div>
</div>
<p><strong>Hình 3-21. Biểu đồ phân tán của tập dữ liệu digits sử dụng hai thành phần chính đầu tiên</strong></p>
<p>Ở đây, chúng ta thực sự đã sử dụng các lớp chữ số thực làm ký tự, để hiển thị lớp nào ở đâu. Các chữ số không, sáu và bốn được phân tách tương đối tốt bằng hai thành phần chính đầu tiên, mặc dù chúng vẫn chồng chéo. Hầu hết các chữ số khác chồng chéo đáng kể.</p>
<p>Hãy áp dụng t-SNE cho cùng một tập dữ liệu, và so sánh kết quả. Vì t-SNE không hỗ trợ biến đổi dữ liệu mới, lớp <code class="docutils literal notranslate"><span class="pre">TSNE</span></code> không có phương thức <code class="docutils literal notranslate"><span class="pre">transform</span></code>. Thay vào đó, chúng ta có thể gọi phương thức <code class="docutils literal notranslate"><span class="pre">fit_transform</span></code>, sẽ xây dựng mô hình và trả về ngay lập tức dữ liệu đã biến đổi (xem Hình 3-22):</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span><span class="w"> </span><span class="nn">sklearn.manifold</span><span class="w"> </span><span class="kn">import</span> <span class="n">TSNE</span>
<span class="n">tsne</span> <span class="o">=</span> <span class="n">TSNE</span><span class="p">(</span><span class="n">random_state</span><span class="o">=</span><span class="mi">42</span><span class="p">)</span>
<span class="c1"># sử dụng fit_transform thay vì fit, vì TSNE không có phương thức transform</span>
<span class="n">digits_tsne</span> <span class="o">=</span> <span class="n">tsne</span><span class="o">.</span><span class="n">fit_transform</span><span class="p">(</span><span class="n">digits</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stderr highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>c:\Users\Admin\anaconda3\envs\tf-gpu\lib\site-packages\sklearn\manifold\_t_sne.py:800: FutureWarning: The default initialization in TSNE will change from &#39;random&#39; to &#39;pca&#39; in 1.2.
  warnings.warn(
c:\Users\Admin\anaconda3\envs\tf-gpu\lib\site-packages\sklearn\manifold\_t_sne.py:810: FutureWarning: The default learning rate in TSNE will change from 200.0 to &#39;auto&#39; in 1.2.
  warnings.warn(
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">))</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlim</span><span class="p">(</span><span class="n">digits_tsne</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">min</span><span class="p">(),</span> <span class="n">digits_tsne</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylim</span><span class="p">(</span><span class="n">digits_tsne</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">min</span><span class="p">(),</span> <span class="n">digits_tsne</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">digits</span><span class="o">.</span><span class="n">data</span><span class="p">)):</span>
    <span class="c1"># thực sự vẽ các chữ số dưới dạng văn bản thay vì sử dụng scatter</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">text</span><span class="p">(</span><span class="n">digits_tsne</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">digits_tsne</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="nb">str</span><span class="p">(</span><span class="n">digits</span><span class="o">.</span><span class="n">target</span><span class="p">[</span><span class="n">i</span><span class="p">]),</span>
             <span class="n">color</span><span class="o">=</span><span class="n">colors</span><span class="p">[</span><span class="n">digits</span><span class="o">.</span><span class="n">target</span><span class="p">[</span><span class="n">i</span><span class="p">]],</span>
             <span class="n">fontdict</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;weight&#39;</span><span class="p">:</span> <span class="s1">&#39;bold&#39;</span><span class="p">,</span> <span class="s1">&#39;size&#39;</span><span class="p">:</span> <span class="mi">9</span><span class="p">})</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s2">&quot;t-SNE feature 0&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s2">&quot;t-SNE feature 1&quot;</span><span class="p">)</span> <span class="c1"># Mistake in original book, should be ylabel</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../_images/df8c0bc094064876966ec4606b78384568759c8de47111760ec9395dcc71391b.png" src="../_images/df8c0bc094064876966ec4606b78384568759c8de47111760ec9395dcc71391b.png" />
</div>
</div>
<p><strong>Hình 3-22. Biểu đồ phân tán của tập dữ liệu digits sử dụng hai thành phần được tìm thấy bởi t-SNE</strong></p>
<p>Kết quả của t-SNE khá đáng chú ý. Tất cả các lớp đều được phân tách khá rõ ràng. Các chữ số một và chín có phần bị chia cắt, nhưng hầu hết các lớp tạo thành một nhóm dày đặc duy nhất. Hãy nhớ rằng phương pháp này không có kiến thức về nhãn lớp: nó hoàn toàn không giám sát. Tuy nhiên, nó có thể tìm thấy một biểu diễn của dữ liệu trong không gian hai chiều mà phân tách rõ ràng các lớp, chỉ dựa trên mức độ gần của các điểm trong không gian ban đầu.</p>
<p>Thuật toán t-SNE có một số tham số điều chỉnh, mặc dù nó thường hoạt động tốt với các cài đặt mặc định. Bạn có thể thử chơi với <code class="docutils literal notranslate"><span class="pre">perplexity</span></code> và <code class="docutils literal notranslate"><span class="pre">early_exaggeration</span></code>, nhưng hiệu ứng thường là nhỏ.</p>
</section>
</section>
<section id="phan-cum">
<h2>Phân cụm<a class="headerlink" href="#phan-cum" title="Link to this heading">#</a></h2>
<p>Như chúng ta đã mô tả trước đó, phân cụm là nhiệm vụ phân chia tập dữ liệu thành các nhóm, được gọi là các cụm. Mục tiêu là phân chia dữ liệu sao cho các điểm trong một cụm duy nhất rất giống nhau và các điểm trong các cụm khác nhau thì khác nhau. Tương tự như các thuật toán phân loại, các thuật toán phân cụm gán (hoặc dự đoán) một số cho mỗi điểm dữ liệu, cho biết một điểm cụ thể thuộc về cụm nào.</p>
<section id="phan-cum-k-means">
<h3>Phân cụm k-Means<a class="headerlink" href="#phan-cum-k-means" title="Link to this heading">#</a></h3>
<p>Phân cụm k-means là một trong những thuật toán phân cụm đơn giản và được sử dụng phổ biến nhất. Nó cố gắng tìm các tâm cụm đại diện cho các vùng nhất định của dữ liệu. Thuật toán xen kẽ giữa hai bước: gán mỗi điểm dữ liệu cho tâm cụm gần nhất, và sau đó đặt mỗi tâm cụm là trung bình của các điểm dữ liệu được gán cho nó. Thuật toán kết thúc khi việc gán các thể hiện cho các cụm không còn thay đổi. Ví dụ sau (Hình 3-23) minh họa thuật toán trên một tập dữ liệu tổng hợp:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span><span class="w"> </span><span class="nn">mglearn</span>
<span class="n">mglearn</span><span class="o">.</span><span class="n">plots</span><span class="o">.</span><span class="n">plot_kmeans_algorithm</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stderr highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>c:\Users\Admin\anaconda3\envs\tf-gpu\lib\site-packages\sklearn\cluster\_kmeans.py:1334: UserWarning: KMeans is known to have a memory leak on Windows with MKL, when there are less chunks than available threads. You can avoid it by setting the environment variable OMP_NUM_THREADS=1.
  warnings.warn(
c:\Users\Admin\anaconda3\envs\tf-gpu\lib\site-packages\sklearn\cluster\_kmeans.py:1334: UserWarning: KMeans is known to have a memory leak on Windows with MKL, when there are less chunks than available threads. You can avoid it by setting the environment variable OMP_NUM_THREADS=1.
  warnings.warn(
c:\Users\Admin\anaconda3\envs\tf-gpu\lib\site-packages\sklearn\cluster\_kmeans.py:1334: UserWarning: KMeans is known to have a memory leak on Windows with MKL, when there are less chunks than available threads. You can avoid it by setting the environment variable OMP_NUM_THREADS=1.
  warnings.warn(
c:\Users\Admin\anaconda3\envs\tf-gpu\lib\site-packages\sklearn\cluster\_kmeans.py:1334: UserWarning: KMeans is known to have a memory leak on Windows with MKL, when there are less chunks than available threads. You can avoid it by setting the environment variable OMP_NUM_THREADS=1.
  warnings.warn(
</pre></div>
</div>
<img alt="../_images/9babb4730db6010d3f13e84d30b2a2dce30d786fffdc9965536443d365f2b48d.png" src="../_images/9babb4730db6010d3f13e84d30b2a2dce30d786fffdc9965536443d365f2b48d.png" />
</div>
</div>
<p><strong>Hình 3-23. Dữ liệu đầu vào và ba bước của thuật toán k-means</strong></p>
<p>Các tâm cụm được hiển thị dưới dạng hình tam giác, trong khi các điểm dữ liệu được hiển thị dưới dạng hình tròn. Màu sắc cho biết tư cách thành viên của cụm. Chúng ta đã chỉ định rằng chúng ta đang tìm kiếm ba cụm, vì vậy thuật toán được khởi tạo bằng cách khai báo ngẫu nhiên ba điểm dữ liệu làm tâm cụm (xem “Khởi tạo”). Sau đó, thuật toán lặp bắt đầu. Đầu tiên, mỗi điểm dữ liệu được gán cho tâm cụm gần nhất (xem “Gán điểm (1)”). Tiếp theo, các tâm cụm được cập nhật thành trung bình của các điểm được gán (xem “Tính toán lại tâm (1)”). Sau đó, quá trình được lặp lại thêm hai lần nữa. Sau lần lặp thứ ba, việc gán điểm cho các tâm cụm không thay đổi, vì vậy thuật toán dừng lại.</p>
<p>Với các điểm dữ liệu mới, k-means sẽ gán mỗi điểm cho tâm cụm gần nhất. Ví dụ tiếp theo (Hình 3-24) cho thấy các ranh giới của các tâm cụm đã được học trong Hình 3-23:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">mglearn</span><span class="o">.</span><span class="n">plots</span><span class="o">.</span><span class="n">plot_kmeans_boundaries</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stderr highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>c:\Users\Admin\anaconda3\envs\tf-gpu\lib\site-packages\sklearn\cluster\_kmeans.py:1334: UserWarning: KMeans is known to have a memory leak on Windows with MKL, when there are less chunks than available threads. You can avoid it by setting the environment variable OMP_NUM_THREADS=1.
  warnings.warn(
</pre></div>
</div>
<img alt="../_images/e89da734edd89ec5cc467d31e7d3586b3d78e0ed8c6b1ef3c7671d41d4763c1e.png" src="../_images/e89da734edd89ec5cc467d31e7d3586b3d78e0ed8c6b1ef3c7671d41d4763c1e.png" />
</div>
</div>
<p><strong>Hình 3-24. Các tâm cụm và ranh giới cụm được tìm thấy bởi thuật toán k-means</strong></p>
<p>Áp dụng k-means với scikit-learn khá đơn giản. Ở đây, chúng ta áp dụng nó cho dữ liệu tổng hợp mà chúng ta đã sử dụng cho các biểu đồ trước đó. Chúng ta khởi tạo lớp <code class="docutils literal notranslate"><span class="pre">KMeans</span></code> và đặt số lượng cụm chúng ta đang tìm kiếm³. Sau đó, chúng ta gọi phương thức <code class="docutils literal notranslate"><span class="pre">fit</span></code> với dữ liệu:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span><span class="w"> </span><span class="nn">sklearn.datasets</span><span class="w"> </span><span class="kn">import</span> <span class="n">make_blobs</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">sklearn.cluster</span><span class="w"> </span><span class="kn">import</span> <span class="n">KMeans</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">matplotlib.pyplot</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">plt</span>

<span class="c1"># tạo dữ liệu hai chiều tổng hợp</span>
<span class="n">X</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">make_blobs</span><span class="p">(</span><span class="n">random_state</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

<span class="c1"># xây dựng mô hình phân cụm</span>
<span class="n">kmeans</span> <span class="o">=</span> <span class="n">KMeans</span><span class="p">(</span><span class="n">n_clusters</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">n_init</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span> <span class="c1"># Set n_init to avoid FutureWarning</span>
<span class="n">kmeans</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stderr highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>c:\Users\Admin\anaconda3\envs\tf-gpu\lib\site-packages\sklearn\cluster\_kmeans.py:1334: UserWarning: KMeans is known to have a memory leak on Windows with MKL, when there are less chunks than available threads. You can avoid it by setting the environment variable OMP_NUM_THREADS=1.
  warnings.warn(
</pre></div>
</div>
<div class="output text_html"><style>#sk-container-id-3 {color: black;background-color: white;}#sk-container-id-3 pre{padding: 0;}#sk-container-id-3 div.sk-toggleable {background-color: white;}#sk-container-id-3 label.sk-toggleable__label {cursor: pointer;display: block;width: 100%;margin-bottom: 0;padding: 0.3em;box-sizing: border-box;text-align: center;}#sk-container-id-3 label.sk-toggleable__label-arrow:before {content: "▸";float: left;margin-right: 0.25em;color: #696969;}#sk-container-id-3 label.sk-toggleable__label-arrow:hover:before {color: black;}#sk-container-id-3 div.sk-estimator:hover label.sk-toggleable__label-arrow:before {color: black;}#sk-container-id-3 div.sk-toggleable__content {max-height: 0;max-width: 0;overflow: hidden;text-align: left;background-color: #f0f8ff;}#sk-container-id-3 div.sk-toggleable__content pre {margin: 0.2em;color: black;border-radius: 0.25em;background-color: #f0f8ff;}#sk-container-id-3 input.sk-toggleable__control:checked~div.sk-toggleable__content {max-height: 200px;max-width: 100%;overflow: auto;}#sk-container-id-3 input.sk-toggleable__control:checked~label.sk-toggleable__label-arrow:before {content: "▾";}#sk-container-id-3 div.sk-estimator input.sk-toggleable__control:checked~label.sk-toggleable__label {background-color: #d4ebff;}#sk-container-id-3 div.sk-label input.sk-toggleable__control:checked~label.sk-toggleable__label {background-color: #d4ebff;}#sk-container-id-3 input.sk-hidden--visually {border: 0;clip: rect(1px 1px 1px 1px);clip: rect(1px, 1px, 1px, 1px);height: 1px;margin: -1px;overflow: hidden;padding: 0;position: absolute;width: 1px;}#sk-container-id-3 div.sk-estimator {font-family: monospace;background-color: #f0f8ff;border: 1px dotted black;border-radius: 0.25em;box-sizing: border-box;margin-bottom: 0.5em;}#sk-container-id-3 div.sk-estimator:hover {background-color: #d4ebff;}#sk-container-id-3 div.sk-parallel-item::after {content: "";width: 100%;border-bottom: 1px solid gray;flex-grow: 1;}#sk-container-id-3 div.sk-label:hover label.sk-toggleable__label {background-color: #d4ebff;}#sk-container-id-3 div.sk-serial::before {content: "";position: absolute;border-left: 1px solid gray;box-sizing: border-box;top: 0;bottom: 0;left: 50%;z-index: 0;}#sk-container-id-3 div.sk-serial {display: flex;flex-direction: column;align-items: center;background-color: white;padding-right: 0.2em;padding-left: 0.2em;position: relative;}#sk-container-id-3 div.sk-item {position: relative;z-index: 1;}#sk-container-id-3 div.sk-parallel {display: flex;align-items: stretch;justify-content: center;background-color: white;position: relative;}#sk-container-id-3 div.sk-item::before, #sk-container-id-3 div.sk-parallel-item::before {content: "";position: absolute;border-left: 1px solid gray;box-sizing: border-box;top: 0;bottom: 0;left: 50%;z-index: -1;}#sk-container-id-3 div.sk-parallel-item {display: flex;flex-direction: column;z-index: 1;position: relative;background-color: white;}#sk-container-id-3 div.sk-parallel-item:first-child::after {align-self: flex-end;width: 50%;}#sk-container-id-3 div.sk-parallel-item:last-child::after {align-self: flex-start;width: 50%;}#sk-container-id-3 div.sk-parallel-item:only-child::after {width: 0;}#sk-container-id-3 div.sk-dashed-wrapped {border: 1px dashed gray;margin: 0 0.4em 0.5em 0.4em;box-sizing: border-box;padding-bottom: 0.4em;background-color: white;}#sk-container-id-3 div.sk-label label {font-family: monospace;font-weight: bold;display: inline-block;line-height: 1.2em;}#sk-container-id-3 div.sk-label-container {text-align: center;}#sk-container-id-3 div.sk-container {/* jupyter's `normalize.less` sets `[hidden] { display: none; }` but bootstrap.min.css set `[hidden] { display: none !important; }` so we also need the `!important` here to be able to override the default hidden behavior on the sphinx rendered scikit-learn.org. See: https://github.com/scikit-learn/scikit-learn/issues/21755 */display: inline-block !important;position: relative;}#sk-container-id-3 div.sk-text-repr-fallback {display: none;}</style><div id="sk-container-id-3" class="sk-top-container"><div class="sk-text-repr-fallback"><pre>KMeans(n_clusters=3)</pre><b>In a Jupyter environment, please rerun this cell to show the HTML representation or trust the notebook. <br />On GitHub, the HTML representation is unable to render, please try loading this page with nbviewer.org.</b></div><div class="sk-container" hidden><div class="sk-item"><div class="sk-estimator sk-toggleable"><input class="sk-toggleable__control sk-hidden--visually" id="sk-estimator-id-3" type="checkbox" checked><label for="sk-estimator-id-3" class="sk-toggleable__label sk-toggleable__label-arrow">KMeans</label><div class="sk-toggleable__content"><pre>KMeans(n_clusters=3)</pre></div></div></div></div></div></div></div>
</div>
<p>Trong quá trình thuật toán, mỗi điểm dữ liệu huấn luyện trong X được gán một nhãn cụm. Bạn có thể tìm thấy các nhãn này trong thuộc tính <code class="docutils literal notranslate"><span class="pre">kmeans.labels_</span></code>:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Cluster memberships:</span><span class="se">\n</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">kmeans</span><span class="o">.</span><span class="n">labels_</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Cluster memberships:
[1 0 0 0 2 2 2 0 1 1 0 0 2 1 2 2 2 1 0 0 2 0 2 1 0 2 2 1 1 2 1 1 2 1 0 2 0
 0 0 2 2 0 1 0 0 2 1 1 1 1 0 2 2 2 1 2 0 0 1 1 0 2 2 0 0 2 1 2 1 0 0 0 2 1
 1 0 2 2 1 0 1 0 0 2 1 1 1 1 0 1 2 1 1 0 0 2 2 1 2 1]
</pre></div>
</div>
</div>
</div>
<p>Vì chúng ta yêu cầu ba cụm, các cụm được đánh số từ 0 đến 2.</p>
<p>Bạn cũng có thể gán nhãn cụm cho các điểm mới, bằng cách sử dụng phương thức <code class="docutils literal notranslate"><span class="pre">predict</span></code>. Mỗi điểm mới được gán cho tâm cụm gần nhất khi dự đoán, nhưng mô hình hiện có không thay đổi. Chạy <code class="docutils literal notranslate"><span class="pre">predict</span></code> trên tập huấn luyện trả về kết quả giống như <code class="docutils literal notranslate"><span class="pre">labels_</span></code>:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="n">kmeans</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">X</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>[1 0 0 0 2 2 2 0 1 1 0 0 2 1 2 2 2 1 0 0 2 0 2 1 0 2 2 1 1 2 1 1 2 1 0 2 0
 0 0 2 2 0 1 0 0 2 1 1 1 1 0 2 2 2 1 2 0 0 1 1 0 2 2 0 0 2 1 2 1 0 0 0 2 1
 1 0 2 2 1 0 1 0 0 2 1 1 1 1 0 1 2 1 1 0 0 2 2 1 2 1]
</pre></div>
</div>
</div>
</div>
<p>Bạn có thể thấy rằng phân cụm có phần tương tự như phân loại, ở chỗ mỗi mục được gán một nhãn. Tuy nhiên, không có sự thật ngầm định (ground truth), và do đó các nhãn tự chúng không có ý nghĩa tiên nghiệm. Hãy quay lại ví dụ về phân cụm hình ảnh khuôn mặt mà chúng ta đã thảo luận trước đó. Có thể cụm 3 được tìm thấy bởi thuật toán chỉ chứa khuôn mặt của bạn bè Bela của bạn. Tuy nhiên, bạn chỉ có thể biết điều đó sau khi bạn xem các bức ảnh, và con số 3 là tùy ý. Thông tin duy nhất mà thuật toán cung cấp cho bạn là tất cả các khuôn mặt được dán nhãn 3 đều tương tự nhau.</p>
<p>Đối với việc phân cụm mà chúng ta vừa tính toán trên tập dữ liệu đồ chơi hai chiều, điều đó có nghĩa là chúng ta không nên gán bất kỳ ý nghĩa nào cho việc một nhóm được dán nhãn 0 và một nhóm khác được dán nhãn 1. Chạy lại thuật toán có thể dẫn đến một cách đánh số cụm khác do tính chất ngẫu nhiên của việc khởi tạo.</p>
<p>Đây là một biểu đồ của dữ liệu này một lần nữa (Hình 3-25). Các tâm cụm được lưu trữ trong thuộc tính <code class="docutils literal notranslate"><span class="pre">cluster_centers_</span></code>, và chúng ta vẽ chúng dưới dạng hình tam giác:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">mglearn</span><span class="o">.</span><span class="n">discrete_scatter</span><span class="p">(</span><span class="n">X</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">X</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">kmeans</span><span class="o">.</span><span class="n">labels_</span><span class="p">,</span> <span class="n">markers</span><span class="o">=</span><span class="s1">&#39;o&#39;</span><span class="p">)</span>
<span class="n">mglearn</span><span class="o">.</span><span class="n">discrete_scatter</span><span class="p">(</span>
    <span class="n">kmeans</span><span class="o">.</span><span class="n">cluster_centers_</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">kmeans</span><span class="o">.</span><span class="n">cluster_centers_</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span>
    <span class="n">markers</span><span class="o">=</span><span class="s1">&#39;^&#39;</span><span class="p">,</span> <span class="n">markeredgewidth</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../_images/2921ca653b435cd03efd796a591ace79463059b0549726dd88293d78f2fe2fab.png" src="../_images/2921ca653b435cd03efd796a591ace79463059b0549726dd88293d78f2fe2fab.png" />
</div>
</div>
<p><strong>Hình 3-25. Các gán cụm và tâm cụm được tìm thấy bởi k-means với ba cụm</strong></p>
<p>Chúng ta cũng có thể sử dụng nhiều hoặc ít tâm cụm hơn (Hình 3-26):</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">fig</span><span class="p">,</span> <span class="n">axes</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">5</span><span class="p">))</span>

<span class="c1"># sử dụng hai tâm cụm:</span>
<span class="n">kmeans</span> <span class="o">=</span> <span class="n">KMeans</span><span class="p">(</span><span class="n">n_clusters</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">n_init</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span> <span class="c1"># Set n_init to avoid FutureWarning</span>
<span class="n">kmeans</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
<span class="n">assignments</span> <span class="o">=</span> <span class="n">kmeans</span><span class="o">.</span><span class="n">labels_</span>
<span class="n">mglearn</span><span class="o">.</span><span class="n">discrete_scatter</span><span class="p">(</span><span class="n">X</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">X</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">assignments</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="n">axes</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

<span class="c1"># sử dụng năm tâm cụm:</span>
<span class="n">kmeans</span> <span class="o">=</span> <span class="n">KMeans</span><span class="p">(</span><span class="n">n_clusters</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">n_init</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span> <span class="c1"># Set n_init to avoid FutureWarning</span>
<span class="n">kmeans</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
<span class="n">assignments</span> <span class="o">=</span> <span class="n">kmeans</span><span class="o">.</span><span class="n">labels_</span>
<span class="n">mglearn</span><span class="o">.</span><span class="n">discrete_scatter</span><span class="p">(</span><span class="n">X</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">X</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">assignments</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="n">axes</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stderr highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>c:\Users\Admin\anaconda3\envs\tf-gpu\lib\site-packages\sklearn\cluster\_kmeans.py:1334: UserWarning: KMeans is known to have a memory leak on Windows with MKL, when there are less chunks than available threads. You can avoid it by setting the environment variable OMP_NUM_THREADS=1.
  warnings.warn(
c:\Users\Admin\anaconda3\envs\tf-gpu\lib\site-packages\sklearn\cluster\_kmeans.py:1334: UserWarning: KMeans is known to have a memory leak on Windows with MKL, when there are less chunks than available threads. You can avoid it by setting the environment variable OMP_NUM_THREADS=1.
  warnings.warn(
</pre></div>
</div>
<img alt="../_images/14fc0c11e7576a88bc626e2f902949e6b6d8968b686412e7defcbf4d0076e378.png" src="../_images/14fc0c11e7576a88bc626e2f902949e6b6d8968b686412e7defcbf4d0076e378.png" />
</div>
</div>
<p><strong>Hình 3-26. Các gán cụm được tìm thấy bởi k-means sử dụng hai cụm (trái) và năm cụm (phải)</strong></p>
<section id="cac-truong-hop-that-bai-cua-k-means">
<h4>Các trường hợp thất bại của k-means<a class="headerlink" href="#cac-truong-hop-that-bai-cua-k-means" title="Link to this heading">#</a></h4>
<p>Ngay cả khi bạn biết số lượng cụm “đúng” cho một tập dữ liệu nhất định, k-means có thể không phải lúc nào cũng có thể khôi phục chúng. Mỗi cụm được xác định duy nhất bởi tâm của nó, điều này có nghĩa là mỗi cụm là một hình lồi. Do đó, k-means chỉ có thể nắm bắt các hình dạng tương đối đơn giản. k-means cũng giả định rằng tất cả các cụm có cùng “đường kính” theo một nghĩa nào đó; nó luôn vẽ ranh giới giữa các cụm chính xác ở giữa các tâm cụm. Điều đó đôi khi có thể dẫn đến những kết quả đáng ngạc nhiên, như được hiển thị trong Hình 3-27:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">X_varied</span><span class="p">,</span> <span class="n">y_varied</span> <span class="o">=</span> <span class="n">make_blobs</span><span class="p">(</span><span class="n">n_samples</span><span class="o">=</span><span class="mi">200</span><span class="p">,</span>
                                <span class="n">cluster_std</span><span class="o">=</span><span class="p">[</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">2.5</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">],</span>
                                <span class="n">random_state</span><span class="o">=</span><span class="mi">170</span><span class="p">)</span>
<span class="n">y_pred</span> <span class="o">=</span> <span class="n">KMeans</span><span class="p">(</span><span class="n">n_clusters</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">n_init</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span><span class="o">.</span><span class="n">fit_predict</span><span class="p">(</span><span class="n">X_varied</span><span class="p">)</span>

<span class="n">mglearn</span><span class="o">.</span><span class="n">discrete_scatter</span><span class="p">(</span><span class="n">X_varied</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">X_varied</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">y_pred</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">([</span><span class="s2">&quot;cụm 0&quot;</span><span class="p">,</span> <span class="s2">&quot;cụm 1&quot;</span><span class="p">,</span> <span class="s2">&quot;cụm 2&quot;</span><span class="p">],</span> <span class="n">loc</span><span class="o">=</span><span class="s1">&#39;best&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s2">&quot;Đặc trưng 0&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s2">&quot;Đặc trưng 1&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stderr highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>c:\Users\Admin\anaconda3\envs\tf-gpu\lib\site-packages\sklearn\cluster\_kmeans.py:1334: UserWarning: KMeans is known to have a memory leak on Windows with MKL, when there are less chunks than available threads. You can avoid it by setting the environment variable OMP_NUM_THREADS=1.
  warnings.warn(
</pre></div>
</div>
<img alt="../_images/e43c5cf32b37595cfd34f2a882b6ff24d7a22f027047906844baeb19ab8eb95f.png" src="../_images/e43c5cf32b37595cfd34f2a882b6ff24d7a22f027047906844baeb19ab8eb95f.png" />
</div>
</div>
<p><strong>Hình 3-27. Các gán cụm được tìm thấy bởi k-means khi các cụm có mật độ khác nhau</strong></p>
<p>Người ta có thể đã mong đợi vùng dày đặc ở phía dưới bên trái là cụm thứ nhất, vùng dày đặc ở phía trên bên phải là cụm thứ hai, và vùng ít dày đặc hơn ở trung tâm là cụm thứ ba. Thay vào đó, cả cụm 0 và cụm 1 đều có một số điểm ở xa tất cả các điểm khác trong các cụm này mà “vươn” về phía trung tâm.</p>
<p>k-means cũng giả định rằng tất cả các hướng đều quan trọng như nhau đối với mỗi cụm. Biểu đồ sau (Hình 3-28) cho thấy một tập dữ liệu hai chiều nơi có ba phần được phân tách rõ ràng trong dữ liệu. Tuy nhiên, các nhóm này bị kéo dài về phía đường chéo. Vì k-means chỉ xem xét khoảng cách đến tâm cụm gần nhất, nó không thể xử lý loại dữ liệu này:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>

<span class="c1"># tạo một số dữ liệu cụm ngẫu nhiên</span>
<span class="n">X</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">make_blobs</span><span class="p">(</span><span class="n">random_state</span><span class="o">=</span><span class="mi">170</span><span class="p">,</span> <span class="n">n_samples</span><span class="o">=</span><span class="mi">600</span><span class="p">)</span>
<span class="n">rng</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">RandomState</span><span class="p">(</span><span class="mi">74</span><span class="p">)</span>
<span class="c1"># biến đổi dữ liệu để bị kéo dài</span>
<span class="n">transformation</span> <span class="o">=</span> <span class="n">rng</span><span class="o">.</span><span class="n">normal</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
<span class="n">X</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">transformation</span><span class="p">)</span>

<span class="c1"># phân cụm dữ liệu thành ba cụm</span>
<span class="n">kmeans</span> <span class="o">=</span> <span class="n">KMeans</span><span class="p">(</span><span class="n">n_clusters</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">n_init</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
<span class="n">kmeans</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
<span class="n">y_pred</span> <span class="o">=</span> <span class="n">kmeans</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>

<span class="c1"># vẽ các gán cụm và tâm cụm</span>
<span class="n">plt</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">X</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">X</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">c</span><span class="o">=</span><span class="n">y_pred</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="n">mglearn</span><span class="o">.</span><span class="n">cm3</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">kmeans</span><span class="o">.</span><span class="n">cluster_centers_</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">kmeans</span><span class="o">.</span><span class="n">cluster_centers_</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span>
            <span class="n">marker</span><span class="o">=</span><span class="s1">&#39;^&#39;</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="n">s</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">linewidth</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="n">mglearn</span><span class="o">.</span><span class="n">cm3</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s2">&quot;Đặc trưng 0&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s2">&quot;Đặc trưng 1&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stderr highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>c:\Users\Admin\anaconda3\envs\tf-gpu\lib\site-packages\sklearn\cluster\_kmeans.py:1334: UserWarning: KMeans is known to have a memory leak on Windows with MKL, when there are less chunks than available threads. You can avoid it by setting the environment variable OMP_NUM_THREADS=3.
  warnings.warn(
</pre></div>
</div>
<img alt="../_images/ee30afe197b6b9605002880111fe7c9f3800ce41be3ec790be40918d7853a10c.png" src="../_images/ee30afe197b6b9605002880111fe7c9f3800ce41be3ec790be40918d7853a10c.png" />
</div>
</div>
<p><strong>Hình 3-28. k-means thất bại trong việc xác định các cụm không có dạng hình cầu</strong></p>
<p>k-means cũng hoạt động kém nếu các cụm có hình dạng phức tạp hơn, như dữ liệu two_moons mà chúng ta đã gặp trong Chương 2 (xem Hình 3-29):</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># tạo dữ liệu two_moons tổng hợp (lần này có ít nhiễu hơn)</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">sklearn.datasets</span><span class="w"> </span><span class="kn">import</span> <span class="n">make_moons</span>
<span class="n">X</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">make_moons</span><span class="p">(</span><span class="n">n_samples</span><span class="o">=</span><span class="mi">200</span><span class="p">,</span> <span class="n">noise</span><span class="o">=</span><span class="mf">0.05</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

<span class="c1"># phân cụm dữ liệu thành hai cụm</span>
<span class="n">kmeans</span> <span class="o">=</span> <span class="n">KMeans</span><span class="p">(</span><span class="n">n_clusters</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">n_init</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
<span class="n">kmeans</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
<span class="n">y_pred</span> <span class="o">=</span> <span class="n">kmeans</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>

<span class="c1"># vẽ các gán cụm và tâm cụm</span>
<span class="n">plt</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">X</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">X</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">c</span><span class="o">=</span><span class="n">y_pred</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="n">mglearn</span><span class="o">.</span><span class="n">cm2</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="mi">60</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">kmeans</span><span class="o">.</span><span class="n">cluster_centers_</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">kmeans</span><span class="o">.</span><span class="n">cluster_centers_</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span>
            <span class="n">marker</span><span class="o">=</span><span class="s1">&#39;^&#39;</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="p">[</span><span class="n">mglearn</span><span class="o">.</span><span class="n">cm2</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">mglearn</span><span class="o">.</span><span class="n">cm2</span><span class="p">(</span><span class="mi">1</span><span class="p">)],</span> <span class="n">s</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">linewidth</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s2">&quot;Đặc trưng 0&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s2">&quot;Đặc trưng 1&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stderr highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>c:\Users\Admin\anaconda3\envs\tf-gpu\lib\site-packages\sklearn\cluster\_kmeans.py:1334: UserWarning: KMeans is known to have a memory leak on Windows with MKL, when there are less chunks than available threads. You can avoid it by setting the environment variable OMP_NUM_THREADS=1.
  warnings.warn(
</pre></div>
</div>
<img alt="../_images/d33848c2c1d41f9ea78f2c6950966f615d9fc9e857a8813e38944c73392f6b2d.png" src="../_images/d33848c2c1d41f9ea78f2c6950966f615d9fc9e857a8813e38944c73392f6b2d.png" />
</div>
</div>
<p><strong>Hình 3-29. k-means thất bại trong việc xác định các cụm có hình dạng phức tạp</strong></p>
<p>Ở đây, chúng ta hy vọng rằng thuật toán phân cụm có thể khám phá ra hai hình nửa vầng trăng. Tuy nhiên, điều này không thể thực hiện được bằng thuật toán k-means.</p>
</section>
<section id="luong-tu-hoa-vector-hay-xem-k-means-nhu-la-mot-phuong-phap-phan-ra">
<h4>Lượng tử hóa vector, hay xem k-means như là một phương pháp phân rã<a class="headerlink" href="#luong-tu-hoa-vector-hay-xem-k-means-nhu-la-mot-phuong-phap-phan-ra" title="Link to this heading">#</a></h4>
<p>Mặc dù k-means là một thuật toán phân cụm, có những điểm tương đồng thú vị giữa k-means và các phương pháp phân rã như PCA và NMF mà chúng ta đã thảo luận trước đó. Bạn có thể nhớ rằng PCA cố gắng tìm các hướng có phương sai lớn nhất trong dữ liệu, trong khi NMF cố gắng tìm các thành phần cộng, thường tương ứng với các “cực” hoặc “phần” của dữ liệu (xem Hình 3-13). Cả hai phương pháp đều cố gắng biểu diễn các điểm dữ liệu dưới dạng tổng của một số thành phần. Mặt khác, k-means cố gắng biểu diễn mỗi điểm dữ liệu bằng một tâm cụm. Bạn có thể nghĩ rằng mỗi điểm được biểu diễn chỉ bằng một thành phần duy nhất, được cho bởi tâm cụm. Quan điểm này của k-means như một phương pháp phân rã, trong đó mỗi điểm được biểu diễn bằng một thành phần duy nhất, được gọi là lượng tử hóa vector.</p>
<p>Hãy thực hiện một so sánh song song giữa PCA, NMF và k-means, hiển thị các thành phần được trích xuất (Hình 3-30), cũng như các tái tạo của các khuôn mặt từ tập kiểm tra sử dụng 100 thành phần (Hình 3-31). Đối với k-means, việc tái tạo là tâm cụm gần nhất được tìm thấy trên tập huấn luyện:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Code from the previous part to have the necessary variables</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">sklearn.datasets</span><span class="w"> </span><span class="kn">import</span> <span class="n">fetch_lfw_people</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">sklearn.model_selection</span><span class="w"> </span><span class="kn">import</span> <span class="n">train_test_split</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">sklearn.decomposition</span><span class="w"> </span><span class="kn">import</span> <span class="n">PCA</span><span class="p">,</span> <span class="n">NMF</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">sklearn.cluster</span><span class="w"> </span><span class="kn">import</span> <span class="n">KMeans</span>

<span class="n">people</span> <span class="o">=</span> <span class="n">fetch_lfw_people</span><span class="p">(</span><span class="n">min_faces_per_person</span><span class="o">=</span><span class="mi">20</span><span class="p">,</span> <span class="n">resize</span><span class="o">=</span><span class="mf">0.7</span><span class="p">)</span>
<span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">people</span><span class="o">.</span><span class="n">target</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
<span class="k">for</span> <span class="n">target</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">people</span><span class="o">.</span><span class="n">target</span><span class="p">):</span>
    <span class="n">mask</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">people</span><span class="o">.</span><span class="n">target</span> <span class="o">==</span> <span class="n">target</span><span class="p">)[</span><span class="mi">0</span><span class="p">][:</span><span class="mi">50</span><span class="p">]]</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">X_people</span> <span class="o">=</span> <span class="n">people</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span>
<span class="n">y_people</span> <span class="o">=</span> <span class="n">people</span><span class="o">.</span><span class="n">target</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span>
<span class="n">X_people</span> <span class="o">=</span> <span class="n">X_people</span> <span class="o">/</span> <span class="mf">255.</span>
<span class="n">image_shape</span> <span class="o">=</span> <span class="n">people</span><span class="o">.</span><span class="n">images</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span>
<span class="n">X_train</span><span class="p">,</span> <span class="n">X_test</span><span class="p">,</span> <span class="n">y_train</span><span class="p">,</span> <span class="n">y_test</span> <span class="o">=</span> <span class="n">train_test_split</span><span class="p">(</span>
    <span class="n">X_people</span><span class="p">,</span> <span class="n">y_people</span><span class="p">,</span> <span class="n">stratify</span><span class="o">=</span><span class="n">y_people</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

<span class="c1"># Actual code for this section</span>
<span class="n">nmf</span> <span class="o">=</span> <span class="n">NMF</span><span class="p">(</span><span class="n">n_components</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">max_iter</span><span class="o">=</span><span class="mi">1000</span><span class="p">,</span> <span class="n">tol</span><span class="o">=</span><span class="mf">1e-2</span><span class="p">)</span>
<span class="n">nmf</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X_train</span><span class="p">)</span>
<span class="n">pca</span> <span class="o">=</span> <span class="n">PCA</span><span class="p">(</span><span class="n">n_components</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="n">pca</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X_train</span><span class="p">)</span>
<span class="n">kmeans</span> <span class="o">=</span> <span class="n">KMeans</span><span class="p">(</span><span class="n">n_clusters</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">n_init</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
<span class="n">kmeans</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X_train</span><span class="p">)</span>

<span class="n">X_reconstructed_pca</span> <span class="o">=</span> <span class="n">pca</span><span class="o">.</span><span class="n">inverse_transform</span><span class="p">(</span><span class="n">pca</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">X_test</span><span class="p">))</span>
<span class="n">X_reconstructed_kmeans</span> <span class="o">=</span> <span class="n">kmeans</span><span class="o">.</span><span class="n">cluster_centers_</span><span class="p">[</span><span class="n">kmeans</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">X_test</span><span class="p">)]</span>
<span class="n">X_reconstructed_nmf</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">nmf</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">X_test</span><span class="p">),</span> <span class="n">nmf</span><span class="o">.</span><span class="n">components_</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stderr highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>c:\Users\Admin\anaconda3\envs\tf-gpu\lib\site-packages\sklearn\cluster\_kmeans.py:1334: UserWarning: KMeans is known to have a memory leak on Windows with MKL, when there are less chunks than available threads. You can avoid it by setting the environment variable OMP_NUM_THREADS=7.
  warnings.warn(
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span><span class="w"> </span><span class="nn">matplotlib.pyplot</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">plt</span>
<span class="n">fig</span><span class="p">,</span> <span class="n">axes</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="mi">8</span><span class="p">),</span>
                       <span class="n">subplot_kw</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;xticks&#39;</span><span class="p">:</span> <span class="p">(),</span> <span class="s1">&#39;yticks&#39;</span><span class="p">:</span> <span class="p">()})</span>
<span class="n">fig</span><span class="o">.</span><span class="n">suptitle</span><span class="p">(</span><span class="s2">&quot;Các thành phần được trích xuất&quot;</span><span class="p">)</span>
<span class="k">for</span> <span class="n">ax</span><span class="p">,</span> <span class="n">comp_kmeans</span><span class="p">,</span> <span class="n">comp_pca</span><span class="p">,</span> <span class="n">comp_nmf</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span>
    <span class="n">axes</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">kmeans</span><span class="o">.</span><span class="n">cluster_centers_</span><span class="p">,</span> <span class="n">pca</span><span class="o">.</span><span class="n">components_</span><span class="p">,</span> <span class="n">nmf</span><span class="o">.</span><span class="n">components_</span><span class="p">):</span>
    <span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">comp_kmeans</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">image_shape</span><span class="p">),</span> <span class="n">cmap</span><span class="o">=</span><span class="s1">&#39;gray&#39;</span><span class="p">)</span>
    <span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">comp_pca</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">image_shape</span><span class="p">),</span> <span class="n">cmap</span><span class="o">=</span><span class="s1">&#39;viridis&#39;</span><span class="p">)</span>
    <span class="n">ax</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">comp_nmf</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">image_shape</span><span class="p">),</span> <span class="n">cmap</span><span class="o">=</span><span class="s1">&#39;gray&#39;</span><span class="p">)</span>

<span class="n">axes</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s2">&quot;kmeans&quot;</span><span class="p">)</span>
<span class="n">axes</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s2">&quot;pca&quot;</span><span class="p">)</span>
<span class="n">axes</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s2">&quot;nmf&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>

<span class="n">fig</span><span class="p">,</span> <span class="n">axes</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="n">subplot_kw</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;xticks&#39;</span><span class="p">:</span> <span class="p">(),</span> <span class="s1">&#39;yticks&#39;</span><span class="p">:</span> <span class="p">()},</span>
                       <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="mi">8</span><span class="p">))</span>
<span class="n">fig</span><span class="o">.</span><span class="n">suptitle</span><span class="p">(</span><span class="s2">&quot;Tái tạo&quot;</span><span class="p">)</span>
<span class="k">for</span> <span class="n">ax</span><span class="p">,</span> <span class="n">orig</span><span class="p">,</span> <span class="n">rec_kmeans</span><span class="p">,</span> <span class="n">rec_pca</span><span class="p">,</span> <span class="n">rec_nmf</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span>
    <span class="n">axes</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">X_test</span><span class="p">,</span> <span class="n">X_reconstructed_kmeans</span><span class="p">,</span> <span class="n">X_reconstructed_pca</span><span class="p">,</span>
    <span class="n">X_reconstructed_nmf</span><span class="p">):</span>
    <span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">orig</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">image_shape</span><span class="p">),</span> <span class="n">cmap</span><span class="o">=</span><span class="s1">&#39;gray&#39;</span><span class="p">)</span>
    <span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">rec_kmeans</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">image_shape</span><span class="p">),</span> <span class="n">cmap</span><span class="o">=</span><span class="s1">&#39;gray&#39;</span><span class="p">)</span>
    <span class="n">ax</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">rec_pca</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">image_shape</span><span class="p">),</span> <span class="n">cmap</span><span class="o">=</span><span class="s1">&#39;gray&#39;</span><span class="p">)</span>
    <span class="n">ax</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">rec_nmf</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">image_shape</span><span class="p">),</span> <span class="n">cmap</span><span class="o">=</span><span class="s1">&#39;gray&#39;</span><span class="p">)</span>

<span class="n">axes</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s2">&quot;gốc&quot;</span><span class="p">)</span>
<span class="n">axes</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s2">&quot;kmeans&quot;</span><span class="p">)</span>
<span class="n">axes</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s2">&quot;pca&quot;</span><span class="p">)</span>
<span class="n">axes</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s2">&quot;nmf&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../_images/3c918f62bd15577883574824eabba7049111f717b230323cb3c8dee9b0b64c13.png" src="../_images/3c918f62bd15577883574824eabba7049111f717b230323cb3c8dee9b0b64c13.png" />
<img alt="../_images/eb910b0633e53341cc6a346c8be6e7583f9356fc9369feaf3bb34089e225c579.png" src="../_images/eb910b0633e53341cc6a346c8be6e7583f9356fc9369feaf3bb34089e225c579.png" />
</div>
</div>
<p><strong>Hình 3-30. So sánh các tâm cụm k-means với các thành phần được tìm thấy bởi PCA và NMF</strong></p>
<p><strong>Hình 3-31. So sánh tái tạo hình ảnh bằng k-means, PCA, và NMF với 100 thành phần (hoặc tâm cụm)—k-means chỉ sử dụng một tâm cụm duy nhất cho mỗi hình ảnh</strong></p>
<p>Một khía cạnh thú vị của lượng tử hóa vector bằng k-means là chúng ta có thể sử dụng nhiều cụm hơn so với số chiều đầu vào để mã hóa dữ liệu. Hãy quay lại dữ liệu <code class="docutils literal notranslate"><span class="pre">two_moons</span></code>. Sử dụng PCA hoặc NMF, chúng ta không thể làm gì nhiều với dữ liệu này, vì nó chỉ tồn tại trong hai chiều. Giảm nó xuống một chiều bằng PCA hoặc NMF sẽ phá hủy hoàn toàn cấu trúc của dữ liệu. Nhưng chúng ta có thể tìm thấy một biểu diễn biểu cảm hơn với k-means, bằng cách sử dụng nhiều tâm cụm hơn (xem Hình 3-32):</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span><span class="w"> </span><span class="nn">sklearn.datasets</span><span class="w"> </span><span class="kn">import</span> <span class="n">make_moons</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">mglearn</span>

<span class="n">X</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">make_moons</span><span class="p">(</span><span class="n">n_samples</span><span class="o">=</span><span class="mi">200</span><span class="p">,</span> <span class="n">noise</span><span class="o">=</span><span class="mf">0.05</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="n">kmeans</span> <span class="o">=</span> <span class="n">KMeans</span><span class="p">(</span><span class="n">n_clusters</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">n_init</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
<span class="n">kmeans</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
<span class="n">y_pred</span> <span class="o">=</span> <span class="n">kmeans</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>

<span class="n">plt</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">X</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">X</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">c</span><span class="o">=</span><span class="n">y_pred</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="mi">60</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="s1">&#39;Paired&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">kmeans</span><span class="o">.</span><span class="n">cluster_centers_</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">kmeans</span><span class="o">.</span><span class="n">cluster_centers_</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">s</span><span class="o">=</span><span class="mi">60</span><span class="p">,</span>
            <span class="n">marker</span><span class="o">=</span><span class="s1">&#39;^&#39;</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="nb">range</span><span class="p">(</span><span class="n">kmeans</span><span class="o">.</span><span class="n">n_clusters</span><span class="p">),</span> <span class="n">linewidth</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="s1">&#39;Paired&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s2">&quot;Đặc trưng 0&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s2">&quot;Đặc trưng 1&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Cluster memberships:</span><span class="se">\n</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">y_pred</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stderr highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>c:\Users\Admin\anaconda3\envs\tf-gpu\lib\site-packages\sklearn\cluster\_kmeans.py:1334: UserWarning: KMeans is known to have a memory leak on Windows with MKL, when there are less chunks than available threads. You can avoid it by setting the environment variable OMP_NUM_THREADS=1.
  warnings.warn(
</pre></div>
</div>
<img alt="../_images/3f4b9421723ade2b622b9f58ef0b87250d5e1da7723800b132d10279964d254d.png" src="../_images/3f4b9421723ade2b622b9f58ef0b87250d5e1da7723800b132d10279964d254d.png" />
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Cluster memberships:
[9 2 5 4 2 7 9 6 9 6 1 0 2 6 1 9 3 0 3 1 7 6 8 6 8 5 2 7 5 8 9 8 6 5 3 7 0
 9 4 5 0 1 3 5 2 8 9 1 5 6 1 0 7 4 6 3 3 6 3 8 0 4 2 9 6 4 8 2 8 4 0 4 0 5
 6 4 5 9 3 0 7 8 0 7 5 8 9 8 0 7 3 9 7 1 7 2 2 0 4 5 6 7 8 9 4 5 4 1 2 3 1
 8 8 4 9 2 3 7 0 9 9 1 5 8 5 1 9 5 6 7 9 1 4 0 6 2 6 4 7 9 5 5 3 8 1 9 5 6
 3 5 0 2 9 3 0 8 6 0 3 3 5 6 3 2 0 2 3 0 2 6 3 4 4 1 5 6 7 1 1 3 2 4 7 2 7
 3 8 6 4 1 4 3 9 9 5 1 7 5 8 2]
</pre></div>
</div>
</div>
</div>
<p><strong>Hình 3-32. Sử dụng nhiều cụm k-means để bao phủ sự biến thiên trong một tập dữ liệu phức tạp</strong></p>
<p>Chúng ta đã sử dụng 10 tâm cụm, điều này có nghĩa là mỗi điểm bây giờ được gán một số từ 0 đến 9. Chúng ta có thể xem đây là dữ liệu được biểu diễn bằng 10 thành phần (tức là, chúng ta có 10 đặc trưng mới), với tất cả các đặc trưng đều bằng 0, ngoại trừ đặc trưng đại diện cho tâm cụm mà điểm đó được gán vào. Sử dụng biểu diễn 10 chiều này, bây giờ có thể tách hai hình nửa vầng trăng bằng một mô hình tuyến tính, điều mà không thể thực hiện được bằng hai đặc trưng ban đầu. Cũng có thể có được một biểu diễn biểu cảm hơn của dữ liệu bằng cách sử dụng khoảng cách đến mỗi tâm cụm làm đặc trưng. Điều này có thể được thực hiện bằng cách sử dụng phương thức <code class="docutils literal notranslate"><span class="pre">transform</span></code> của <code class="docutils literal notranslate"><span class="pre">kmeans</span></code>:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">distance_features</span> <span class="o">=</span> <span class="n">kmeans</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Distance feature shape: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">distance_features</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Distance features:</span><span class="se">\n</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">distance_features</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Distance feature shape: (200, 10)
Distance features:
[[0.9220768  1.46553151 1.13956805 ... 1.16559918 1.03852189 0.23340263]
 [1.14159679 2.51721597 0.1199124  ... 0.70700803 2.20414144 0.98271691]
 [0.78786246 0.77354687 1.74914157 ... 1.97061341 0.71561277 0.94399739]
 ...
 [0.44639122 1.10631579 1.48991975 ... 1.79125448 1.03195812 0.81205971]
 [1.38951924 0.79790385 1.98056306 ... 1.97788956 0.23892095 1.05774337]
 [1.14920754 2.4536383  0.04506731 ... 0.57163262 2.11331394 0.88166689]]
</pre></div>
</div>
</div>
</div>
<p>k-means là một thuật toán rất phổ biến để phân cụm, không chỉ vì nó tương đối dễ hiểu và dễ triển khai, mà còn vì nó chạy tương đối nhanh. k-means dễ dàng mở rộng cho các tập dữ liệu lớn, và scikit-learn thậm chí còn bao gồm một biến thể có khả năng mở rộng hơn trong lớp <code class="docutils literal notranslate"><span class="pre">MiniBatchKMeans</span></code>, có thể xử lý các tập dữ liệu rất lớn.</p>
<p>Một trong những nhược điểm của k-means là nó dựa vào một khởi tạo ngẫu nhiên, điều này có nghĩa là kết quả của thuật toán phụ thuộc vào một hạt giống ngẫu nhiên. Theo mặc định, scikit-learn chạy thuật toán 10 lần với 10 khởi tạo ngẫu nhiên khác nhau, và trả về kết quả tốt nhất⁴.</p>
<p>Những nhược điểm khác của k-means là các giả định tương đối hạn chế về hình dạng của các cụm, và yêu cầu phải chỉ định số lượng cụm bạn đang tìm kiếm (có thể không được biết trong một ứng dụng thực tế). Tiếp theo, chúng ta sẽ xem xét hai thuật toán phân cụm khác cải thiện những thuộc tính này theo một số cách.</p>
<hr class="docutils" />
<p>⁴ Trong trường hợp này, “tốt nhất” có nghĩa là tổng phương sai của các cụm là nhỏ.</p>
</section>
</section>
<section id="phan-cum-gop-agglomerative-clustering">
<h3>Phân cụm Gộp (Agglomerative Clustering)<a class="headerlink" href="#phan-cum-gop-agglomerative-clustering" title="Link to this heading">#</a></h3>
<p>Phân cụm gộp đề cập đến một tập hợp các thuật toán phân cụm đều được xây dựng dựa trên cùng một nguyên tắc: thuật toán bắt đầu bằng cách tuyên bố mỗi điểm là một cụm riêng, sau đó hợp nhất hai cụm giống nhau nhất cho đến khi một tiêu chí dừng nào đó được thỏa mãn. Tiêu chí dừng được triển khai trong scikit-learn là số lượng cụm, vì vậy các cụm tương tự được hợp nhất cho đến khi chỉ còn lại số lượng cụm được chỉ định. Có một số tiêu chí liên kết (linkage criteria) chỉ định chính xác cách đo lường “cụm giống nhau nhất”. Phép đo này luôn được xác định giữa hai cụm hiện có.</p>
<p>Ba lựa chọn sau đây được triển khai trong scikit-learn:</p>
<p><strong>ward</strong>
Lựa chọn mặc định, <code class="docutils literal notranslate"><span class="pre">ward</span></code> chọn hai cụm để hợp nhất sao cho phương sai trong tất cả các cụm tăng ít nhất. Điều này thường dẫn đến các cụm có kích thước tương đối bằng nhau.</p>
<p><strong>average</strong>
Liên kết <code class="docutils literal notranslate"><span class="pre">average</span></code> hợp nhất hai cụm có khoảng cách trung bình nhỏ nhất giữa tất cả các điểm của chúng.</p>
<p><strong>complete</strong>
Liên kết <code class="docutils literal notranslate"><span class="pre">complete</span></code> (còn được gọi là liên kết tối đa) hợp nhất hai cụm có khoảng cách tối đa nhỏ nhất giữa các điểm của chúng.</p>
<p><code class="docutils literal notranslate"><span class="pre">ward</span></code> hoạt động trên hầu hết các tập dữ liệu, và chúng ta sẽ sử dụng nó trong các ví dụ của mình. Nếu các cụm có số lượng thành viên rất khác nhau (ví dụ, nếu một cụm lớn hơn nhiều so với tất cả các cụm khác), <code class="docutils literal notranslate"><span class="pre">average</span></code> hoặc <code class="docutils literal notranslate"><span class="pre">complete</span></code> có thể hoạt động tốt hơn.</p>
<p>Biểu đồ sau (Hình 3-33) minh họa quá trình tiến triển của phân cụm gộp trên một tập dữ liệu hai chiều, tìm kiếm ba cụm:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">mglearn</span><span class="o">.</span><span class="n">plots</span><span class="o">.</span><span class="n">plot_agglomerative_algorithm</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../_images/bd41468f34c8da6dc4a567cd9a5636c8ee84bbcc5a88aa6aec56c2083c0c674e.png" src="../_images/bd41468f34c8da6dc4a567cd9a5636c8ee84bbcc5a88aa6aec56c2083c0c674e.png" />
</div>
</div>
<p><strong>Hình 3-33. Phân cụm gộp lặp đi lặp lại việc kết hợp hai cụm gần nhất</strong></p>
<p>Ban đầu, mỗi điểm là một cụm riêng. Sau đó, trong mỗi bước, hai cụm gần nhất được hợp nhất. Trong bốn bước đầu tiên, hai cụm một điểm được chọn và chúng được nối thành các cụm hai điểm. Ở bước 5, một trong các cụm hai điểm được mở rộng thành điểm thứ ba, và cứ thế. Ở bước 9, chỉ còn lại ba cụm. Vì chúng ta đã chỉ định rằng chúng ta đang tìm kiếm ba cụm, thuật toán sau đó dừng lại.</p>
<p>Hãy xem phân cụm gộp hoạt động như thế nào trên dữ liệu ba cụm đơn giản mà chúng ta đã sử dụng ở đây. Do cách thuật toán hoạt động, phân cụm gộp không thể đưa ra dự đoán cho các điểm dữ liệu mới. Do đó, <code class="docutils literal notranslate"><span class="pre">AgglomerativeClustering</span></code> không có phương thức <code class="docutils literal notranslate"><span class="pre">predict</span></code>. Để xây dựng mô hình và nhận tư cách thành viên cụm trên tập huấn luyện, hãy sử dụng phương thức <code class="docutils literal notranslate"><span class="pre">fit_predict</span></code> thay thế. Kết quả được hiển thị trong Hình 3-34:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span><span class="w"> </span><span class="nn">sklearn.cluster</span><span class="w"> </span><span class="kn">import</span> <span class="n">AgglomerativeClustering</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">sklearn.datasets</span><span class="w"> </span><span class="kn">import</span> <span class="n">make_blobs</span>

<span class="n">X</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">make_blobs</span><span class="p">(</span><span class="n">random_state</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

<span class="n">agg</span> <span class="o">=</span> <span class="n">AgglomerativeClustering</span><span class="p">(</span><span class="n">n_clusters</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
<span class="n">assignment</span> <span class="o">=</span> <span class="n">agg</span><span class="o">.</span><span class="n">fit_predict</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>

<span class="n">mglearn</span><span class="o">.</span><span class="n">discrete_scatter</span><span class="p">(</span><span class="n">X</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">X</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">assignment</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s2">&quot;Đặc trưng 0&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s2">&quot;Đặc trưng 1&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">([</span><span class="s2">&quot;Cụm 0&quot;</span><span class="p">,</span> <span class="s2">&quot;Cụm 1&quot;</span><span class="p">,</span> <span class="s2">&quot;Cụm 2&quot;</span><span class="p">])</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../_images/b557d9085ddae5664662b1480f68c107188ddf603cc178ebad6e9b2f19cc3f27.png" src="../_images/b557d9085ddae5664662b1480f68c107188ddf603cc178ebad6e9b2f19cc3f27.png" />
</div>
</div>
<p><strong>Hình 3-34. Gán cụm bằng phân cụm gộp với ba cụm</strong></p>
<p>Như mong đợi, thuật toán khôi phục phân cụm một cách hoàn hảo. Mặc dù việc triển khai phân cụm gộp của scikit-learn yêu cầu bạn chỉ định số lượng cụm bạn muốn thuật toán tìm, các phương pháp phân cụm gộp cung cấp một số trợ giúp trong việc chọn đúng số lượng, mà chúng ta sẽ thảo luận tiếp theo.</p>
<section id="phan-cum-phan-cap-va-bieu-do-cay-dendrogram">
<h4>Phân cụm phân cấp và biểu đồ cây (dendrogram)<a class="headerlink" href="#phan-cum-phan-cap-va-bieu-do-cay-dendrogram" title="Link to this heading">#</a></h4>
<p>Phân cụm gộp tạo ra cái được gọi là phân cụm phân cấp. Quá trình phân cụm tiến hành lặp đi lặp lại, và mỗi điểm thực hiện một hành trình từ việc là một cụm một điểm đến việc thuộc về một cụm cuối cùng nào đó. Mỗi bước trung gian cung cấp một phân cụm của dữ liệu (với một số lượng cụm khác nhau). Đôi khi hữu ích khi xem xét tất cả các phân cụm có thể có cùng nhau. Ví dụ tiếp theo (Hình 3-35) cho thấy một sự chồng chéo của tất cả các phân cụm có thể có được hiển thị trong Hình 3-33, cung cấp một số cái nhìn sâu sắc về cách mỗi cụm chia nhỏ thành các cụm nhỏ hơn:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">mglearn</span><span class="o">.</span><span class="n">plots</span><span class="o">.</span><span class="n">plot_agglomerative</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../_images/6670148b639de7927633145ca15f08c7b651d3f395bc332dafffca12126e6e0e.png" src="../_images/6670148b639de7927633145ca15f08c7b651d3f395bc332dafffca12126e6e0e.png" />
</div>
</div>
<p><strong>Hình 3-35. Gán cụm phân cấp (hiển thị dưới dạng các đường) được tạo ra bằng phân cụm gộp, với các điểm dữ liệu được đánh số (xem Hình 3-36)</strong></p>
<p>Mặc dù trực quan hóa này cung cấp một cái nhìn rất chi tiết về phân cụm phân cấp, nó phụ thuộc vào bản chất hai chiều của dữ liệu và do đó không thể được sử dụng trên các tập dữ liệu có nhiều hơn hai đặc trưng. Tuy nhiên, có một công cụ khác để trực quan hóa phân cụm phân cấp, được gọi là biểu đồ cây (dendrogram), có thể xử lý các tập dữ liệu đa chiều.</p>
<p>Thật không may, scikit-learn hiện tại không có chức năng vẽ biểu đồ cây. Tuy nhiên, bạn có thể tạo chúng dễ dàng bằng cách sử dụng SciPy. Các thuật toán phân cụm của SciPy có giao diện hơi khác so với các thuật toán phân cụm của scikit-learn. SciPy cung cấp một hàm nhận một mảng dữ liệu X và tính toán một mảng liên kết (linkage array), mã hóa sự tương đồng của cụm phân cấp. Sau đó, chúng ta có thể đưa mảng liên kết này vào hàm <code class="docutils literal notranslate"><span class="pre">dendrogram</span></code> của SciPy để vẽ biểu đồ cây (Hình 3-36):</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Import hàm dendrogram và hàm phân cụm ward từ SciPy</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">scipy.cluster.hierarchy</span><span class="w"> </span><span class="kn">import</span> <span class="n">dendrogram</span><span class="p">,</span> <span class="n">ward</span>

<span class="n">X</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">make_blobs</span><span class="p">(</span><span class="n">random_state</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">n_samples</span><span class="o">=</span><span class="mi">12</span><span class="p">)</span>
<span class="c1"># Áp dụng phân cụm ward cho mảng dữ liệu X</span>
<span class="c1"># Hàm ward của SciPy trả về một mảng chỉ định các khoảng cách</span>
<span class="c1"># được bắc cầu khi thực hiện phân cụm gộp</span>
<span class="n">linkage_array</span> <span class="o">=</span> <span class="n">ward</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
<span class="c1"># Bây giờ chúng ta vẽ biểu đồ cây cho linkage_array chứa các khoảng cách</span>
<span class="c1"># giữa các cụm</span>
<span class="n">dendrogram</span><span class="p">(</span><span class="n">linkage_array</span><span class="p">)</span>

<span class="c1"># Đánh dấu các vết cắt trong cây biểu thị hai hoặc ba cụm</span>
<span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">gca</span><span class="p">()</span>
<span class="n">bounds</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">get_xbound</span><span class="p">()</span>
<span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">bounds</span><span class="p">,</span> <span class="p">[</span><span class="mf">7.25</span><span class="p">,</span> <span class="mf">7.25</span><span class="p">],</span> <span class="s1">&#39;--&#39;</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="s1">&#39;k&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">bounds</span><span class="p">,</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span> <span class="s1">&#39;--&#39;</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="s1">&#39;k&#39;</span><span class="p">)</span>

<span class="n">ax</span><span class="o">.</span><span class="n">text</span><span class="p">(</span><span class="n">bounds</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="mf">7.25</span><span class="p">,</span> <span class="s1">&#39; hai cụm&#39;</span><span class="p">,</span> <span class="n">va</span><span class="o">=</span><span class="s1">&#39;center&#39;</span><span class="p">,</span> <span class="n">fontdict</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;size&#39;</span><span class="p">:</span> <span class="mi">15</span><span class="p">})</span>
<span class="n">ax</span><span class="o">.</span><span class="n">text</span><span class="p">(</span><span class="n">bounds</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="mi">4</span><span class="p">,</span> <span class="s1">&#39; ba cụm&#39;</span><span class="p">,</span> <span class="n">va</span><span class="o">=</span><span class="s1">&#39;center&#39;</span><span class="p">,</span> <span class="n">fontdict</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;size&#39;</span><span class="p">:</span> <span class="mi">15</span><span class="p">})</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s2">&quot;Chỉ số mẫu&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s2">&quot;Khoảng cách cụm&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../_images/81c67270566902588a41d401ecac11e63ee02b1334bd30c88ce5ac933c90b28e.png" src="../_images/81c67270566902588a41d401ecac11e63ee02b1334bd30c88ce5ac933c90b28e.png" />
</div>
</div>
<p><strong>Hình 3-36. Biểu đồ cây của phân cụm được hiển thị trong Hình 3-35 với các đường chỉ ra sự phân chia thành hai và ba cụm</strong></p>
<p>Biểu đồ cây hiển thị các điểm dữ liệu dưới dạng các điểm ở dưới cùng (được đánh số từ 0 đến 11). Sau đó, một cây được vẽ với các điểm này (đại diện cho các cụm một điểm) là các lá, và một nút cha mới được thêm vào cho mỗi hai cụm được nối. Đọc từ dưới lên trên, các điểm dữ liệu 1 và 4 được nối đầu tiên (như bạn có thể thấy trong Hình 3-33). Tiếp theo, các điểm 6 và 9 được nối thành một cụm, và cứ thế. Ở cấp cao nhất, có hai nhánh, một nhánh bao gồm các điểm 11, 0, 5, 10, 7, 6, và 9, và nhánh kia bao gồm các điểm 1, 4, 3, 2, và 8. Chúng tương ứng với hai cụm lớn nhất ở phía bên trái của biểu đồ.</p>
<p>Trục y trong biểu đồ cây không chỉ chỉ định khi nào trong thuật toán gộp hai cụm được hợp nhất. Độ dài của mỗi nhánh cũng cho thấy hai cụm được hợp nhất cách nhau bao xa. Các nhánh dài nhất trong biểu đồ cây này là ba đường được đánh dấu bằng đường đứt nét có nhãn “ba cụm”. Việc đây là các nhánh dài nhất cho thấy rằng việc đi từ ba đến hai cụm có nghĩa là hợp nhất một số điểm rất xa nhau. Chúng ta thấy điều này một lần nữa ở đầu biểu đồ, nơi việc hợp nhất hai cụm còn lại thành một cụm duy nhất lại bắc cầu một khoảng cách tương đối lớn.</p>
<p>Thật không may, phân cụm gộp vẫn thất bại trong việc tách các hình dạng phức tạp như tập dữ liệu <code class="docutils literal notranslate"><span class="pre">two_moons</span></code>. Nhưng điều tương tự không đúng với thuật toán tiếp theo mà chúng ta sẽ xem xét, DBSCAN.</p>
</section>
</section>
<section id="dbscan">
<h3>DBSCAN<a class="headerlink" href="#dbscan" title="Link to this heading">#</a></h3>
<p>Một thuật toán phân cụm rất hữu ích khác là DBSCAN (viết tắt của “density-based spatial clustering of applications with noise” - phân cụm không gian dựa trên mật độ của các ứng dụng có nhiễu). Lợi ích chính của DBSCAN là nó không yêu cầu người dùng đặt trước số lượng cụm, nó có thể nắm bắt các cụm có hình dạng phức tạp, và nó có thể xác định các điểm không thuộc bất kỳ cụm nào. DBSCAN chậm hơn một chút so với phân cụm gộp và k-means, nhưng vẫn có thể mở rộng cho các tập dữ liệu tương đối lớn.</p>
<p>DBSCAN hoạt động bằng cách xác định các điểm nằm trong các vùng “đông đúc” của không gian đặc trưng, nơi có nhiều điểm dữ liệu gần nhau. Những vùng này được gọi là các vùng dày đặc trong không gian đặc trưng. Ý tưởng đằng sau DBSCAN là các cụm hình thành các vùng dữ liệu dày đặc, được ngăn cách bởi các vùng tương đối trống rỗng.</p>
<p>Các điểm nằm trong một vùng dày đặc được gọi là các mẫu lõi (hoặc điểm lõi), và chúng được định nghĩa như sau. Có hai tham số trong DBSCAN: <code class="docutils literal notranslate"><span class="pre">min_samples</span></code> và <code class="docutils literal notranslate"><span class="pre">eps</span></code>. Nếu có ít nhất <code class="docutils literal notranslate"><span class="pre">min_samples</span></code> điểm dữ liệu trong khoảng cách <code class="docutils literal notranslate"><span class="pre">eps</span></code> đến một điểm dữ liệu nhất định, điểm dữ liệu đó được phân loại là một mẫu lõi. Các mẫu lõi gần nhau hơn khoảng cách <code class="docutils literal notranslate"><span class="pre">eps</span></code> được DBSCAN đặt vào cùng một cụm.</p>
<p>Thuật toán hoạt động bằng cách chọn một điểm tùy ý để bắt đầu. Sau đó, nó tìm tất cả các điểm có khoảng cách <code class="docutils literal notranslate"><span class="pre">eps</span></code> hoặc nhỏ hơn từ điểm đó. Nếu có ít hơn <code class="docutils literal notranslate"><span class="pre">min_samples</span></code> điểm trong khoảng cách <code class="docutils literal notranslate"><span class="pre">eps</span></code> của điểm bắt đầu, điểm này được gắn nhãn là nhiễu, có nghĩa là nó không thuộc bất kỳ cụm nào. Nếu có nhiều hơn <code class="docutils literal notranslate"><span class="pre">min_samples</span></code> điểm trong khoảng cách <code class="docutils literal notranslate"><span class="pre">eps</span></code>, điểm đó được gắn nhãn là một mẫu lõi và được gán một nhãn cụm mới. Sau đó, tất cả các láng giềng (trong phạm vi <code class="docutils literal notranslate"><span class="pre">eps</span></code>) của điểm được duyệt qua. Nếu chúng chưa được gán một cụm, chúng được gán nhãn cụm mới vừa được tạo. Nếu chúng là các mẫu lõi, các láng giềng của chúng lần lượt được duyệt qua, và cứ thế. Cụm phát triển cho đến khi không còn mẫu lõi nào trong khoảng cách <code class="docutils literal notranslate"><span class="pre">eps</span></code> của cụm. Sau đó, một điểm khác chưa được duyệt qua được chọn, và quy trình tương tự được lặp lại.</p>
<p>Cuối cùng, có ba loại điểm: điểm lõi, điểm nằm trong khoảng cách <code class="docutils literal notranslate"><span class="pre">eps</span></code> của điểm lõi (gọi là điểm biên), và nhiễu. Khi thuật toán DBSCAN được chạy trên một tập dữ liệu cụ thể nhiều lần, việc phân cụm các điểm lõi luôn giống nhau, và các điểm giống nhau sẽ luôn được gắn nhãn là nhiễu. Tuy nhiên, một điểm biên có thể là láng giềng của các mẫu lõi của nhiều hơn một cụm. Do đó, tư cách thành viên cụm của các điểm biên phụ thuộc vào thứ tự các điểm được duyệt qua. Thường chỉ có ít điểm biên, và sự phụ thuộc nhỏ này vào thứ tự các điểm không quan trọng.</p>
<p>Hãy áp dụng DBSCAN trên tập dữ liệu tổng hợp mà chúng ta đã sử dụng để minh họa phân cụm gộp. Giống như phân cụm gộp, DBSCAN không cho phép dự đoán trên dữ liệu kiểm tra mới, vì vậy chúng ta sẽ sử dụng phương thức <code class="docutils literal notranslate"><span class="pre">fit_predict</span></code> để thực hiện phân cụm và trả về các nhãn cụm trong một bước:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span><span class="w"> </span><span class="nn">sklearn.cluster</span><span class="w"> </span><span class="kn">import</span> <span class="n">DBSCAN</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">sklearn.datasets</span><span class="w"> </span><span class="kn">import</span> <span class="n">make_blobs</span>

<span class="n">X</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">make_blobs</span><span class="p">(</span><span class="n">random_state</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">n_samples</span><span class="o">=</span><span class="mi">12</span><span class="p">)</span>
<span class="n">dbscan</span> <span class="o">=</span> <span class="n">DBSCAN</span><span class="p">()</span>
<span class="n">clusters</span> <span class="o">=</span> <span class="n">dbscan</span><span class="o">.</span><span class="n">fit_predict</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Cluster memberships:</span><span class="se">\n</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">clusters</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Cluster memberships:
[-1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1]
</pre></div>
</div>
</div>
</div>
<p>Như bạn có thể thấy, tất cả các điểm dữ liệu đều được gán nhãn -1, có nghĩa là nhiễu. Đây là hệ quả của các cài đặt tham số mặc định cho <code class="docutils literal notranslate"><span class="pre">eps</span></code> và <code class="docutils literal notranslate"><span class="pre">min_samples</span></code>, không được điều chỉnh cho các tập dữ liệu đồ chơi nhỏ. Các gán cụm cho các giá trị khác nhau của <code class="docutils literal notranslate"><span class="pre">min_samples</span></code> và <code class="docutils literal notranslate"><span class="pre">eps</span></code> được hiển thị bên dưới, và được trực quan hóa trong Hình 3-37:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span><span class="w"> </span><span class="nn">mglearn</span>
<span class="n">mglearn</span><span class="o">.</span><span class="n">plots</span><span class="o">.</span><span class="n">plot_dbscan</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>min_samples: 2 eps: 1.000000  cluster: [-1  0  0 -1  0 -1  1  1  0  1 -1 -1]
min_samples: 2 eps: 1.500000  cluster: [0 1 1 1 1 0 2 2 1 2 2 0]
min_samples: 2 eps: 2.000000  cluster: [0 1 1 1 1 0 0 0 1 0 0 0]
min_samples: 2 eps: 3.000000  cluster: [0 0 0 0 0 0 0 0 0 0 0 0]
min_samples: 3 eps: 1.000000  cluster: [-1  0  0 -1  0 -1  1  1  0  1 -1 -1]
min_samples: 3 eps: 1.500000  cluster: [0 1 1 1 1 0 2 2 1 2 2 0]
min_samples: 3 eps: 2.000000  cluster: [0 1 1 1 1 0 0 0 1 0 0 0]
min_samples: 3 eps: 3.000000  cluster: [0 0 0 0 0 0 0 0 0 0 0 0]
min_samples: 5 eps: 1.000000  cluster: [-1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1]
min_samples: 5 eps: 1.500000  cluster: [-1  0  0  0  0 -1 -1 -1  0 -1 -1 -1]
min_samples: 5 eps: 2.000000  cluster: [-1  0  0  0  0 -1 -1 -1  0 -1 -1 -1]
min_samples: 5 eps: 3.000000  cluster: [0 0 0 0 0 0 0 0 0 0 0 0]
</pre></div>
</div>
<img alt="../_images/2931bdff5611ee3f70fe1c44e7c80a5ae5b303913dc0ca2d00d44d9248c69ff7.png" src="../_images/2931bdff5611ee3f70fe1c44e7c80a5ae5b303913dc0ca2d00d44d9248c69ff7.png" />
</div>
</div>
<p><strong>Hình 3-37. Các gán cụm được tìm thấy bởi DBSCAN với các cài đặt thay đổi cho các tham số <code class="docutils literal notranslate"><span class="pre">min_samples</span></code> và <code class="docutils literal notranslate"><span class="pre">eps</span></code></strong></p>
<p>Trong biểu đồ này, các điểm thuộc về các cụm là liền khối, trong khi các điểm nhiễu được hiển thị màu trắng. Các mẫu lõi được hiển thị dưới dạng các dấu lớn, trong khi các điểm biên được hiển thị dưới dạng các dấu nhỏ hơn. Tăng <code class="docutils literal notranslate"><span class="pre">eps</span></code> (đi từ trái sang phải trong hình) có nghĩa là nhiều điểm hơn sẽ được bao gồm trong một cụm. Điều này làm cho các cụm phát triển, nhưng cũng có thể dẫn đến việc nhiều cụm hợp nhất thành một. Tăng <code class="docutils literal notranslate"><span class="pre">min_samples</span></code> (đi từ trên xuống dưới trong hình) có nghĩa là ít điểm hơn sẽ là điểm lõi, và nhiều điểm hơn sẽ được gắn nhãn là nhiễu.</p>
<p>Tham số <code class="docutils literal notranslate"><span class="pre">eps</span></code> quan trọng hơn một chút, vì nó xác định ý nghĩa của việc các điểm “gần nhau”. Đặt <code class="docutils literal notranslate"><span class="pre">eps</span></code> rất nhỏ sẽ có nghĩa là không có điểm nào là mẫu lõi, và có thể dẫn đến tất cả các điểm được gắn nhãn là nhiễu. Đặt <code class="docutils literal notranslate"><span class="pre">eps</span></code> rất lớn sẽ dẫn đến tất cả các điểm tạo thành một cụm duy nhất. Cài đặt <code class="docutils literal notranslate"><span class="pre">min_samples</span></code> chủ yếu xác định xem các điểm trong các vùng ít dày đặc hơn sẽ được gắn nhãn là ngoại lai hay là các cụm riêng của chúng. Nếu bạn giảm <code class="docutils literal notranslate"><span class="pre">min_samples</span></code>, bất cứ thứ gì đã là một cụm với ít hơn <code class="docutils literal notranslate"><span class="pre">min_samples</span></code> mẫu bây giờ sẽ được gắn nhãn là nhiễu. Do đó, <code class="docutils literal notranslate"><span class="pre">min_samples</span></code> xác định kích thước cụm tối thiểu. Bạn có thể thấy điều này rất rõ ràng trong Hình 3-37, khi đi từ <code class="docutils literal notranslate"><span class="pre">min_samples=3</span></code> đến <code class="docutils literal notranslate"><span class="pre">min_samples=5</span></code> với <code class="docutils literal notranslate"><span class="pre">eps=1.5</span></code>. Với <code class="docutils literal notranslate"><span class="pre">min_samples=3</span></code>, có ba cụm: một cụm bốn điểm, một cụm năm điểm, và một cụm ba điểm. Với <code class="docutils literal notranslate"><span class="pre">min_samples=5</span></code>, hai cụm nhỏ hơn (với ba và bốn điểm) bây giờ được gắn nhãn là nhiễu, và chỉ có cụm với năm mẫu còn lại.</p>
<p>Mặc dù DBSCAN không yêu cầu đặt số lượng cụm một cách rõ ràng, việc đặt <code class="docutils literal notranslate"><span class="pre">eps</span></code> ngầm định kiểm soát số lượng cụm sẽ được tìm thấy. Việc tìm một cài đặt tốt cho <code class="docutils literal notranslate"><span class="pre">eps</span></code> đôi khi dễ dàng hơn sau khi co giãn dữ liệu bằng <code class="docutils literal notranslate"><span class="pre">StandardScaler</span></code> hoặc <code class="docutils literal notranslate"><span class="pre">MinMaxScaler</span></code>, vì việc sử dụng các kỹ thuật co giãn này sẽ đảm bảo rằng tất cả các đặc trưng đều có phạm vi tương tự. Hình 3-38 cho thấy kết quả của việc chạy DBSCAN trên tập dữ liệu <code class="docutils literal notranslate"><span class="pre">two_moons</span></code>. Thuật toán thực sự tìm thấy hai nửa vòng tròn và tách chúng ra bằng các cài đặt mặc định:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span><span class="w"> </span><span class="nn">sklearn.preprocessing</span><span class="w"> </span><span class="kn">import</span> <span class="n">StandardScaler</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">sklearn.datasets</span><span class="w"> </span><span class="kn">import</span> <span class="n">make_moons</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">matplotlib.pyplot</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">plt</span>

<span class="n">X</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">make_moons</span><span class="p">(</span><span class="n">n_samples</span><span class="o">=</span><span class="mi">200</span><span class="p">,</span> <span class="n">noise</span><span class="o">=</span><span class="mf">0.05</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

<span class="c1"># co giãn lại dữ liệu về trung bình 0 và phương sai đơn vị</span>
<span class="n">scaler</span> <span class="o">=</span> <span class="n">StandardScaler</span><span class="p">()</span>
<span class="n">scaler</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
<span class="n">X_scaled</span> <span class="o">=</span> <span class="n">scaler</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>

<span class="n">dbscan</span> <span class="o">=</span> <span class="n">DBSCAN</span><span class="p">()</span>
<span class="n">clusters</span> <span class="o">=</span> <span class="n">dbscan</span><span class="o">.</span><span class="n">fit_predict</span><span class="p">(</span><span class="n">X_scaled</span><span class="p">)</span>
<span class="c1"># vẽ các gán cụm</span>
<span class="n">plt</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">X_scaled</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">X_scaled</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">c</span><span class="o">=</span><span class="n">clusters</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="n">mglearn</span><span class="o">.</span><span class="n">cm2</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="mi">60</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s2">&quot;Đặc trưng 0&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s2">&quot;Đặc trưng 1&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../_images/d5db30f24c9e6d74085306656fe0cf3dd659ef8a045117120f79d06c22d9b7e4.png" src="../_images/d5db30f24c9e6d74085306656fe0cf3dd659ef8a045117120f79d06c22d9b7e4.png" />
</div>
</div>
<p><strong>Hình 3-38. Gán cụm được tìm thấy bởi DBSCAN sử dụng giá trị mặc định của <span class="math notranslate nohighlight">\(eps=0.5\)</span></strong></p>
<p>Vì thuật toán đã tạo ra số lượng cụm mong muốn (hai), các cài đặt tham số có vẻ hoạt động tốt. Nếu chúng ta giảm <code class="docutils literal notranslate"><span class="pre">eps</span></code> xuống 0.2 (từ mặc định là 0.5), chúng ta sẽ có tám cụm, rõ ràng là quá nhiều. Tăng <code class="docutils literal notranslate"><span class="pre">eps</span></code> lên 0.7 dẫn đến một cụm duy nhất.</p>
<p>Khi sử dụng DBSCAN, bạn cần cẩn thận về việc xử lý các gán cụm được trả về. Việc sử dụng -1 để chỉ nhiễu có thể dẫn đến các hiệu ứng không mong muốn khi sử dụng các nhãn cụm để lập chỉ mục cho một mảng khác.</p>
</section>
<section id="so-sanh-va-danh-gia-cac-thuat-toan-phan-cum">
<h3>So sánh và Đánh giá các Thuật toán Phân cụm<a class="headerlink" href="#so-sanh-va-danh-gia-cac-thuat-toan-phan-cum" title="Link to this heading">#</a></h3>
<p>Một trong những thách thức trong việc áp dụng các thuật toán phân cụm là rất khó để đánh giá một thuật toán đã hoạt động tốt như thế nào, và để so sánh kết quả giữa các thuật toán khác nhau. Sau khi nói về các thuật toán đằng sau k-means, phân cụm gộp, và DBSCAN, bây giờ chúng ta sẽ so sánh chúng trên một số tập dữ liệu thực tế.</p>
<section id="danh-gia-phan-cum-voi-su-that-ngam-dinh-ground-truth">
<h4>Đánh giá phân cụm với sự thật ngầm định (ground truth)<a class="headerlink" href="#danh-gia-phan-cum-voi-su-that-ngam-dinh-ground-truth" title="Link to this heading">#</a></h4>
<p>Có các thước đo có thể được sử dụng để đánh giá kết quả của một thuật toán phân cụm so với một phân cụm sự thật ngầm định, những thước đo quan trọng nhất là chỉ số Rand điều chỉnh (ARI) và thông tin tương hỗ chuẩn hóa (NMI), cả hai đều cung cấp một thước đo định lượng từ 0 đến 1.</p>
<p>Ở đây, chúng ta so sánh các thuật toán k-means, phân cụm gộp, và DBSCAN bằng ARI. Chúng ta cũng bao gồm việc gán ngẫu nhiên các điểm vào hai cụm để so sánh (xem Hình 3-39):</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span><span class="w"> </span><span class="nn">sklearn.metrics.cluster</span><span class="w"> </span><span class="kn">import</span> <span class="n">adjusted_rand_score</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">sklearn.cluster</span><span class="w"> </span><span class="kn">import</span> <span class="n">KMeans</span><span class="p">,</span> <span class="n">AgglomerativeClustering</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>

<span class="n">X</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">make_moons</span><span class="p">(</span><span class="n">n_samples</span><span class="o">=</span><span class="mi">200</span><span class="p">,</span> <span class="n">noise</span><span class="o">=</span><span class="mf">0.05</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

<span class="c1"># co giãn lại dữ liệu về trung bình 0 và phương sai đơn vị</span>
<span class="n">scaler</span> <span class="o">=</span> <span class="n">StandardScaler</span><span class="p">()</span>
<span class="n">scaler</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
<span class="n">X_scaled</span> <span class="o">=</span> <span class="n">scaler</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>

<span class="n">fig</span><span class="p">,</span> <span class="n">axes</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">15</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span>
                       <span class="n">subplot_kw</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;xticks&#39;</span><span class="p">:</span> <span class="p">(),</span> <span class="s1">&#39;yticks&#39;</span><span class="p">:</span> <span class="p">()})</span>

<span class="c1"># tạo một danh sách các thuật toán để sử dụng</span>
<span class="n">algorithms</span> <span class="o">=</span> <span class="p">[</span><span class="n">KMeans</span><span class="p">(</span><span class="n">n_clusters</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">n_init</span><span class="o">=</span><span class="mi">10</span><span class="p">),</span> <span class="n">AgglomerativeClustering</span><span class="p">(</span><span class="n">n_clusters</span><span class="o">=</span><span class="mi">2</span><span class="p">),</span> <span class="n">DBSCAN</span><span class="p">()]</span>

<span class="c1"># tạo một gán cụm ngẫu nhiên để tham khảo</span>
<span class="n">random_state</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">RandomState</span><span class="p">(</span><span class="n">seed</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="n">random_clusters</span> <span class="o">=</span> <span class="n">random_state</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="n">low</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">high</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">X</span><span class="p">))</span>

<span class="c1"># vẽ gán ngẫu nhiên</span>
<span class="n">axes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">X_scaled</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">X_scaled</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">c</span><span class="o">=</span><span class="n">random_clusters</span><span class="p">,</span>
                <span class="n">cmap</span><span class="o">=</span><span class="n">mglearn</span><span class="o">.</span><span class="n">cm3</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="mi">60</span><span class="p">)</span>
<span class="n">axes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s2">&quot;Gán ngẫu nhiên - ARI: </span><span class="si">{:.2f}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
    <span class="n">adjusted_rand_score</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">random_clusters</span><span class="p">)))</span>

<span class="k">for</span> <span class="n">ax</span><span class="p">,</span> <span class="n">algorithm</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">axes</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span> <span class="n">algorithms</span><span class="p">):</span>
    <span class="c1"># vẽ các gán cụm và tâm cụm</span>
    <span class="n">clusters</span> <span class="o">=</span> <span class="n">algorithm</span><span class="o">.</span><span class="n">fit_predict</span><span class="p">(</span><span class="n">X_scaled</span><span class="p">)</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">X_scaled</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">X_scaled</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">c</span><span class="o">=</span><span class="n">clusters</span><span class="p">,</span>
               <span class="n">cmap</span><span class="o">=</span><span class="n">mglearn</span><span class="o">.</span><span class="n">cm3</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="mi">60</span><span class="p">)</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">{}</span><span class="s2"> - ARI: </span><span class="si">{:.2f}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">algorithm</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span>
                                          <span class="n">adjusted_rand_score</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">clusters</span><span class="p">)))</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stderr highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>c:\Users\Admin\anaconda3\envs\tf-gpu\lib\site-packages\sklearn\cluster\_kmeans.py:1334: UserWarning: KMeans is known to have a memory leak on Windows with MKL, when there are less chunks than available threads. You can avoid it by setting the environment variable OMP_NUM_THREADS=1.
  warnings.warn(
</pre></div>
</div>
<img alt="../_images/5e487c9d678af3863140c8199d92a9abad382d8b1c1a00c487168e450650a67e.png" src="../_images/5e487c9d678af3863140c8199d92a9abad382d8b1c1a00c487168e450650a67e.png" />
</div>
</div>
<p><strong>Hình 3-39. So sánh gán ngẫu nhiên, k-means, phân cụm gộp, và DBSCAN trên tập dữ liệu two_moons sử dụng điểm ARI có giám sát</strong></p>
<p>Chỉ số Rand điều chỉnh cung cấp kết quả trực quan, với việc gán cụm ngẫu nhiên có điểm là 0 và DBSCAN (khôi phục phân cụm mong muốn một cách hoàn hảo) có điểm là 1.</p>
<p>Một sai lầm phổ biến khi đánh giá phân cụm theo cách này là sử dụng <code class="docutils literal notranslate"><span class="pre">accuracy_score</span></code> thay vì <code class="docutils literal notranslate"><span class="pre">adjusted_rand_score</span></code>, <code class="docutils literal notranslate"><span class="pre">normalized_mutual_info_score</span></code>, hoặc một số thước đo phân cụm khác. Vấn đề trong việc sử dụng độ chính xác là nó yêu cầu các nhãn cụm được gán phải khớp chính xác với sự thật ngầm định. Tuy nhiên, các nhãn cụm tự chúng là vô nghĩa—điều duy nhất quan trọng là những điểm nào nằm trong cùng một cụm:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span><span class="w"> </span><span class="nn">sklearn.metrics</span><span class="w"> </span><span class="kn">import</span> <span class="n">accuracy_score</span>

<span class="c1"># hai cách gán nhãn điểm này tương ứng với cùng một phân cụm</span>
<span class="n">clusters1</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
<span class="n">clusters2</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
<span class="c1"># độ chính xác bằng không, vì không có nhãn nào giống nhau</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Accuracy: </span><span class="si">{:.2f}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">accuracy_score</span><span class="p">(</span><span class="n">clusters1</span><span class="p">,</span> <span class="n">clusters2</span><span class="p">)))</span>
<span class="c1"># chỉ số Rand điều chỉnh là 1, vì phân cụm hoàn toàn giống nhau</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;ARI: </span><span class="si">{:.2f}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">adjusted_rand_score</span><span class="p">(</span><span class="n">clusters1</span><span class="p">,</span> <span class="n">clusters2</span><span class="p">)))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Accuracy: 0.00
ARI: 1.00
</pre></div>
</div>
</div>
</div>
</section>
<section id="danh-gia-phan-cum-khong-co-su-that-ngam-dinh-ground-truth">
<h4>Đánh giá phân cụm không có sự thật ngầm định (ground truth)<a class="headerlink" href="#danh-gia-phan-cum-khong-co-su-that-ngam-dinh-ground-truth" title="Link to this heading">#</a></h4>
<p>Mặc dù chúng ta vừa chỉ ra một cách để đánh giá các thuật toán phân cụm, trong thực tế, có một vấn đề lớn với việc sử dụng các thước đo như ARI. Khi áp dụng các thuật toán phân cụm, thường không có sự thật ngầm định để so sánh kết quả. Nếu chúng ta biết phân cụm đúng của dữ liệu, chúng ta có thể sử dụng thông tin này để xây dựng một mô hình có giám sát như một bộ phân loại. Do đó, việc sử dụng các thước đo như ARI và NMI thường chỉ giúp ích trong việc phát triển thuật toán, chứ không phải trong việc đánh giá sự thành công trong một ứng dụng.</p>
<p>Có các thước đo chấm điểm cho phân cụm không yêu cầu sự thật ngầm định, như hệ số silhouette. Tuy nhiên, những thước đo này thường không hoạt động tốt trong thực tế. Điểm silhouette tính toán độ nhỏ gọn của một cụm, trong đó cao hơn là tốt hơn, với điểm hoàn hảo là 1. Mặc dù các cụm nhỏ gọn là tốt, độ nhỏ gọn không cho phép các hình dạng phức tạp. Dưới đây là một ví dụ so sánh kết quả của k-means, phân cụm gộp, và DBSCAN trên tập dữ liệu two_moons sử dụng điểm silhouette (Hình 3-40):</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span><span class="w"> </span><span class="nn">sklearn.metrics.cluster</span><span class="w"> </span><span class="kn">import</span> <span class="n">silhouette_score</span>

<span class="n">X</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">make_moons</span><span class="p">(</span><span class="n">n_samples</span><span class="o">=</span><span class="mi">200</span><span class="p">,</span> <span class="n">noise</span><span class="o">=</span><span class="mf">0.05</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="c1"># co giãn lại dữ liệu về trung bình 0 và phương sai đơn vị</span>
<span class="n">scaler</span> <span class="o">=</span> <span class="n">StandardScaler</span><span class="p">()</span>
<span class="n">scaler</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
<span class="n">X_scaled</span> <span class="o">=</span> <span class="n">scaler</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>

<span class="n">fig</span><span class="p">,</span> <span class="n">axes</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">15</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span>
                       <span class="n">subplot_kw</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;xticks&#39;</span><span class="p">:</span> <span class="p">(),</span> <span class="s1">&#39;yticks&#39;</span><span class="p">:</span> <span class="p">()})</span>

<span class="c1"># tạo một gán cụm ngẫu nhiên để tham khảo</span>
<span class="n">random_state</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">RandomState</span><span class="p">(</span><span class="n">seed</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="n">random_clusters</span> <span class="o">=</span> <span class="n">random_state</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="n">low</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">high</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">X</span><span class="p">))</span>

<span class="c1"># vẽ gán ngẫu nhiên</span>
<span class="n">axes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">X_scaled</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">X_scaled</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">c</span><span class="o">=</span><span class="n">random_clusters</span><span class="p">,</span>
                <span class="n">cmap</span><span class="o">=</span><span class="n">mglearn</span><span class="o">.</span><span class="n">cm3</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="mi">60</span><span class="p">)</span>
<span class="n">axes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s2">&quot;Gán ngẫu nhiên: </span><span class="si">{:.2f}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
    <span class="n">silhouette_score</span><span class="p">(</span><span class="n">X_scaled</span><span class="p">,</span> <span class="n">random_clusters</span><span class="p">)))</span>

<span class="n">algorithms</span> <span class="o">=</span> <span class="p">[</span><span class="n">KMeans</span><span class="p">(</span><span class="n">n_clusters</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">n_init</span><span class="o">=</span><span class="mi">10</span><span class="p">),</span> <span class="n">AgglomerativeClustering</span><span class="p">(</span><span class="n">n_clusters</span><span class="o">=</span><span class="mi">2</span><span class="p">),</span>
              <span class="n">DBSCAN</span><span class="p">()]</span>

<span class="k">for</span> <span class="n">ax</span><span class="p">,</span> <span class="n">algorithm</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">axes</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span> <span class="n">algorithms</span><span class="p">):</span>
    <span class="n">clusters</span> <span class="o">=</span> <span class="n">algorithm</span><span class="o">.</span><span class="n">fit_predict</span><span class="p">(</span><span class="n">X_scaled</span><span class="p">)</span>
    <span class="c1"># vẽ các gán cụm và tâm cụm</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">X_scaled</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">X_scaled</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">c</span><span class="o">=</span><span class="n">clusters</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="n">mglearn</span><span class="o">.</span><span class="n">cm3</span><span class="p">,</span>
               <span class="n">s</span><span class="o">=</span><span class="mi">60</span><span class="p">)</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">{}</span><span class="s2"> - </span><span class="si">{:.2f}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">algorithm</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span>
                                      <span class="n">silhouette_score</span><span class="p">(</span><span class="n">X_scaled</span><span class="p">,</span> <span class="n">clusters</span><span class="p">)))</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stderr highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>c:\Users\Admin\anaconda3\envs\tf-gpu\lib\site-packages\sklearn\cluster\_kmeans.py:1334: UserWarning: KMeans is known to have a memory leak on Windows with MKL, when there are less chunks than available threads. You can avoid it by setting the environment variable OMP_NUM_THREADS=1.
  warnings.warn(
</pre></div>
</div>
<img alt="../_images/c5c201cd78e183e5768f4b2a5eb40e825ab403a64af854f22b951a65d3710292.png" src="../_images/c5c201cd78e183e5768f4b2a5eb40e825ab403a64af854f22b951a65d3710292.png" />
</div>
</div>
<p><strong>Hình 3-40. So sánh gán ngẫu nhiên, k-means, phân cụm gộp, và DBSCAN trên tập dữ liệu two_moons sử dụng điểm silhouette không giám sát—kết quả trực quan hơn của DBSCAN có điểm silhouette thấp hơn so với các gán được tìm thấy bởi k-means</strong></p>
<p>Như bạn có thể thấy, k-means có điểm silhouette cao nhất, mặc dù chúng ta có thể thích kết quả được tạo ra bởi DBSCAN hơn. Một chiến lược tốt hơn một chút để đánh giá các cụm là sử dụng các thước đo phân cụm dựa trên độ bền vững. Các thước đo này chạy một thuật toán sau khi thêm một số nhiễu vào dữ liệu, hoặc sử dụng các cài đặt tham số khác nhau, và so sánh kết quả. Ý tưởng là nếu nhiều tham số thuật toán và nhiều nhiễu loạn của dữ liệu trả về cùng một kết quả, thì kết quả đó có khả năng đáng tin cậy. Thật không may, chiến lược này không được triển khai trong scikit-learn tại thời điểm viết bài.</p>
<p>Ngay cả khi chúng ta có được một phân cụm rất bền vững, hoặc một điểm silhouette rất cao, chúng ta vẫn không biết liệu có bất kỳ ý nghĩa ngữ nghĩa nào trong việc phân cụm, hoặc liệu việc phân cụm có phản ánh một khía cạnh nào đó của dữ liệu mà chúng ta quan tâm hay không. Hãy quay lại ví dụ về hình ảnh khuôn mặt. Chúng ta hy vọng tìm thấy các nhóm khuôn mặt tương tự—ví dụ, nam và nữ, người già và người trẻ, hoặc người có râu và không có râu. Giả sử chúng ta phân cụm dữ liệu thành hai cụm, và tất cả các thuật toán đều đồng ý về những điểm nào nên được phân cụm cùng nhau. Chúng ta vẫn không biết liệu các cụm được tìm thấy có tương ứng với bất kỳ khái niệm nào mà chúng ta quan tâm hay không. Có thể chúng đã tìm thấy các góc nhìn nghiêng so với các góc nhìn chính diện, hoặc các bức ảnh được chụp vào ban đêm so với các bức ảnh được chụp vào ban ngày, hoặc các bức ảnh được chụp bằng iPhone so với các bức ảnh được chụp bằng điện thoại Android. Cách duy nhất để biết liệu việc phân cụm có tương ứng với bất cứ điều gì chúng ta quan tâm hay không là phân tích các cụm một cách thủ công.</p>
</section>
<section id="so-sanh-cac-thuat-toan-tren-tap-du-lieu-khuon-mat">
<h4>So sánh các thuật toán trên tập dữ liệu khuôn mặt<a class="headerlink" href="#so-sanh-cac-thuat-toan-tren-tap-du-lieu-khuon-mat" title="Link to this heading">#</a></h4>
<p>Hãy áp dụng các thuật toán k-means, DBSCAN, và phân cụm gộp cho tập dữ liệu Labeled Faces in the Wild, và xem liệu có thuật toán nào tìm thấy cấu trúc thú vị không. Chúng ta sẽ sử dụng biểu diễn eigenface của dữ liệu, được tạo ra bởi <code class="docutils literal notranslate"><span class="pre">PCA(whiten=True)</span></code>, với 100 thành phần:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Tải dữ liệu và chuẩn bị</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">sklearn.datasets</span><span class="w"> </span><span class="kn">import</span> <span class="n">fetch_lfw_people</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="n">people</span> <span class="o">=</span> <span class="n">fetch_lfw_people</span><span class="p">(</span><span class="n">min_faces_per_person</span><span class="o">=</span><span class="mi">20</span><span class="p">,</span> <span class="n">resize</span><span class="o">=</span><span class="mf">0.7</span><span class="p">)</span>
<span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">people</span><span class="o">.</span><span class="n">target</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
<span class="k">for</span> <span class="n">target</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">people</span><span class="o">.</span><span class="n">target</span><span class="p">):</span>
    <span class="n">mask</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">people</span><span class="o">.</span><span class="n">target</span> <span class="o">==</span> <span class="n">target</span><span class="p">)[</span><span class="mi">0</span><span class="p">][:</span><span class="mi">50</span><span class="p">]]</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">X_people</span> <span class="o">=</span> <span class="n">people</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span>
<span class="n">y_people</span> <span class="o">=</span> <span class="n">people</span><span class="o">.</span><span class="n">target</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span>
<span class="n">X_people</span> <span class="o">=</span> <span class="n">X_people</span> <span class="o">/</span> <span class="mf">255.</span>
<span class="n">image_shape</span> <span class="o">=</span> <span class="n">people</span><span class="o">.</span><span class="n">images</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span>

<span class="c1"># Trích xuất eigenfaces từ dữ liệu lfw và biến đổi dữ liệu</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">sklearn.decomposition</span><span class="w"> </span><span class="kn">import</span> <span class="n">PCA</span>
<span class="n">pca</span> <span class="o">=</span> <span class="n">PCA</span><span class="p">(</span><span class="n">n_components</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">whiten</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="n">pca</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X_people</span><span class="p">)</span>
<span class="n">X_pca</span> <span class="o">=</span> <span class="n">pca</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">X_people</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>Chúng ta đã thấy trước đó rằng đây là một biểu diễn có ngữ nghĩa hơn của hình ảnh khuôn mặt so với các pixel thô. Nó cũng sẽ làm cho việc tính toán nhanh hơn. Một bài tập tốt cho bạn là chạy các thí nghiệm sau trên dữ liệu gốc, không có PCA, và xem bạn có tìm thấy các cụm tương tự không.</p>
<section id="phan-tich-tap-du-lieu-khuon-mat-voi-dbscan">
<h5>Phân tích tập dữ liệu khuôn mặt với DBSCAN<a class="headerlink" href="#phan-tich-tap-du-lieu-khuon-mat-voi-dbscan" title="Link to this heading">#</a></h5>
<p>Chúng ta sẽ bắt đầu bằng cách áp dụng DBSCAN, mà chúng ta vừa thảo luận:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span><span class="w"> </span><span class="nn">sklearn.cluster</span><span class="w"> </span><span class="kn">import</span> <span class="n">DBSCAN</span>
<span class="c1"># áp dụng DBSCAN với các tham số mặc định</span>
<span class="n">dbscan</span> <span class="o">=</span> <span class="n">DBSCAN</span><span class="p">()</span>
<span class="n">labels</span> <span class="o">=</span> <span class="n">dbscan</span><span class="o">.</span><span class="n">fit_predict</span><span class="p">(</span><span class="n">X_pca</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Unique labels: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">labels</span><span class="p">)))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Unique labels: [-1]
</pre></div>
</div>
</div>
</div>
<p>Chúng ta thấy rằng tất cả các nhãn được trả về đều là -1, vì vậy tất cả dữ liệu đã được DBSCAN gán nhãn là “nhiễu”. Có hai điều chúng ta có thể thay đổi để giúp giải quyết vấn đề này: chúng ta có thể làm cho <code class="docutils literal notranslate"><span class="pre">eps</span></code> cao hơn, để mở rộng vùng lân cận của mỗi điểm, và đặt <code class="docutils literal notranslate"><span class="pre">min_samples</span></code> thấp hơn, để xem xét các nhóm điểm nhỏ hơn là các cụm. Hãy thử thay đổi <code class="docutils literal notranslate"><span class="pre">min_samples</span></code> trước:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">dbscan</span> <span class="o">=</span> <span class="n">DBSCAN</span><span class="p">(</span><span class="n">min_samples</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
<span class="n">labels</span> <span class="o">=</span> <span class="n">dbscan</span><span class="o">.</span><span class="n">fit_predict</span><span class="p">(</span><span class="n">X_pca</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Unique labels: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">labels</span><span class="p">)))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Unique labels: [-1]
</pre></div>
</div>
</div>
</div>
<p>Ngay cả khi xem xét các nhóm ba điểm, mọi thứ vẫn được gán nhãn là nhiễu. Vì vậy, chúng ta cần tăng <code class="docutils literal notranslate"><span class="pre">eps</span></code>:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">dbscan</span> <span class="o">=</span> <span class="n">DBSCAN</span><span class="p">(</span><span class="n">min_samples</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">eps</span><span class="o">=</span><span class="mi">15</span><span class="p">)</span>
<span class="n">labels</span> <span class="o">=</span> <span class="n">dbscan</span><span class="o">.</span><span class="n">fit_predict</span><span class="p">(</span><span class="n">X_pca</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Unique labels: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">labels</span><span class="p">)))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Unique labels: [-1  0]
</pre></div>
</div>
</div>
</div>
<p>Sử dụng một <code class="docutils literal notranslate"><span class="pre">eps</span></code> lớn hơn nhiều là 15, chúng ta chỉ nhận được một cụm duy nhất và các điểm nhiễu. Chúng ta có thể sử dụng kết quả này để tìm hiểu xem “nhiễu” trông như thế nào so với phần còn lại của dữ liệu. Để hiểu rõ hơn về những gì đang xảy ra, hãy xem có bao nhiêu điểm là nhiễu, và bao nhiêu điểm nằm trong cụm:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Đếm số điểm trong tất cả các cụm và nhiễu.</span>
<span class="c1"># bincount không cho phép số âm, vì vậy chúng ta cần cộng 1.</span>
<span class="c1"># Số đầu tiên trong kết quả tương ứng với các điểm nhiễu.</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Number of points per cluster: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">bincount</span><span class="p">(</span><span class="n">labels</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Number of points per cluster: [  12 2051]
</pre></div>
</div>
</div>
</div>
<p>Có rất ít điểm nhiễu—chỉ 27—vì vậy chúng ta có thể xem tất cả chúng (xem Hình 3-41):</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span><span class="w"> </span><span class="nn">matplotlib.pyplot</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">plt</span>

<span class="n">noise</span> <span class="o">=</span> <span class="n">X_people</span><span class="p">[</span><span class="n">labels</span><span class="o">==-</span><span class="mi">1</span><span class="p">]</span>
<span class="n">fig</span><span class="p">,</span> <span class="n">axes</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="n">subplot_kw</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;xticks&#39;</span><span class="p">:</span> <span class="p">(),</span> <span class="s1">&#39;yticks&#39;</span><span class="p">:</span> <span class="p">()},</span>
                       <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">12</span><span class="p">,</span> <span class="mi">4</span><span class="p">))</span>
<span class="k">for</span> <span class="n">image</span><span class="p">,</span> <span class="n">ax</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">noise</span><span class="p">,</span> <span class="n">axes</span><span class="o">.</span><span class="n">ravel</span><span class="p">()):</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">image</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">image_shape</span><span class="p">),</span> <span class="n">vmin</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">vmax</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="s1">&#39;gray&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../_images/0a17044d97bb64ef63c2ecdd3b106c587452cce4993f52f7b17062074cff78c6.png" src="../_images/0a17044d97bb64ef63c2ecdd3b106c587452cce4993f52f7b17062074cff78c6.png" />
</div>
</div>
<p><strong>Hình 3-41. Các mẫu từ tập dữ liệu khuôn mặt được DBSCAN gán nhãn là nhiễu</strong></p>
<p>So sánh những hình ảnh này với mẫu ngẫu nhiên các hình ảnh khuôn mặt từ Hình 3-7, chúng ta có thể đoán tại sao chúng được gán nhãn là nhiễu: hình ảnh thứ năm ở hàng đầu tiên cho thấy một người đang uống từ một chiếc ly, có những hình ảnh của những người đội mũ, và trong hình ảnh cuối cùng có một bàn tay ở phía trước khuôn mặt của người đó. Các hình ảnh khác chứa các góc kỳ lạ hoặc các lần cắt quá gần hoặc quá rộng. Loại phân tích này—cố gắng tìm ra “người khác biệt”—được gọi là phát hiện ngoại lệ. Nếu đây là một ứng dụng thực tế, chúng ta có thể cố gắng làm tốt hơn việc cắt ảnh, để có được dữ liệu đồng nhất hơn. Có rất ít điều chúng ta có thể làm về việc mọi người trong ảnh đôi khi đội mũ, uống nước, hoặc cầm một cái gì đó trước mặt họ, nhưng tốt nhất là biết rằng đây là những vấn đề trong dữ liệu mà bất kỳ thuật toán nào chúng ta có thể áp dụng cần phải xử lý.</p>
<p>Nếu chúng ta muốn tìm các cụm thú vị hơn là chỉ một cụm lớn, chúng ta cần đặt <code class="docutils literal notranslate"><span class="pre">eps</span></code> nhỏ hơn, ở đâu đó giữa 15 và 0.5 (mặc định). Hãy xem các giá trị khác nhau của <code class="docutils literal notranslate"><span class="pre">eps</span></code> dẫn đến kết quả gì:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="n">eps</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">11</span><span class="p">,</span> <span class="mi">13</span><span class="p">]:</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">eps=</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">eps</span><span class="p">))</span>
    <span class="n">dbscan</span> <span class="o">=</span> <span class="n">DBSCAN</span><span class="p">(</span><span class="n">eps</span><span class="o">=</span><span class="n">eps</span><span class="p">,</span> <span class="n">min_samples</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
    <span class="n">labels</span> <span class="o">=</span> <span class="n">dbscan</span><span class="o">.</span><span class="n">fit_predict</span><span class="p">(</span><span class="n">X_pca</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Clusters present: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">labels</span><span class="p">)))</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Cluster sizes: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">bincount</span><span class="p">(</span><span class="n">labels</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>eps=1
Clusters present: [-1]
Cluster sizes: [2063]

eps=3
Clusters present: [-1]
Cluster sizes: [2063]

eps=5
Clusters present: [-1  0]
Cluster sizes: [2060    3]

eps=7
Clusters present: [-1  0]
Cluster sizes: [1912  151]

eps=9
Clusters present: [-1  0]
Cluster sizes: [1302  761]

eps=11
Clusters present: [-1  0]
Cluster sizes: [ 512 1551]

eps=13
Clusters present: [-1  0]
Cluster sizes: [  96 1967]
</pre></div>
</div>
</div>
</div>
<p>Đối với các cài đặt <code class="docutils literal notranslate"><span class="pre">eps</span></code> thấp, tất cả các điểm được gán nhãn là nhiễu. Đối với <code class="docutils literal notranslate"><span class="pre">eps=7</span></code>, chúng ta có nhiều điểm nhiễu và nhiều cụm nhỏ hơn. Đối với <code class="docutils literal notranslate"><span class="pre">eps=9</span></code> chúng ta vẫn có nhiều điểm nhiễu, nhưng chúng ta có một cụm lớn và một số cụm nhỏ hơn. Bắt đầu từ <code class="docutils literal notranslate"><span class="pre">eps=11</span></code>, chúng ta chỉ có một cụm lớn và nhiễu. Điều thú vị cần lưu ý là không bao giờ có nhiều hơn một cụm lớn. Tối đa, có một cụm lớn chứa hầu hết các điểm, và một số cụm nhỏ hơn. Điều này chỉ ra rằng không có hai hoặc ba loại hình ảnh khuôn mặt khác nhau trong dữ liệu rất khác biệt, mà thay vào đó tất cả các hình ảnh đều ít nhiều giống nhau (hoặc không giống nhau) với phần còn lại.</p>
<p>Kết quả cho <code class="docutils literal notranslate"><span class="pre">eps=7</span></code> trông thú vị nhất, với nhiều cụm nhỏ. Chúng ta có thể điều tra phân cụm này chi tiết hơn bằng cách trực quan hóa tất cả các điểm trong mỗi cụm trong số 13 cụm nhỏ (Hình 3-42):</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">dbscan</span> <span class="o">=</span> <span class="n">DBSCAN</span><span class="p">(</span><span class="n">min_samples</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">eps</span><span class="o">=</span><span class="mi">7</span><span class="p">)</span>
<span class="n">labels</span> <span class="o">=</span> <span class="n">dbscan</span><span class="o">.</span><span class="n">fit_predict</span><span class="p">(</span><span class="n">X_pca</span><span class="p">)</span>

<span class="k">for</span> <span class="n">cluster</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="n">labels</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
    <span class="n">mask</span> <span class="o">=</span> <span class="n">labels</span> <span class="o">==</span> <span class="n">cluster</span>
    <span class="n">n_images</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">mask</span><span class="p">)</span>
    <span class="n">fig</span><span class="p">,</span> <span class="n">axes</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n_images</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="n">n_images</span> <span class="o">*</span> <span class="mf">1.5</span><span class="p">,</span> <span class="mi">4</span><span class="p">),</span>
                           <span class="n">subplot_kw</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;xticks&#39;</span><span class="p">:</span> <span class="p">(),</span> <span class="s1">&#39;yticks&#39;</span><span class="p">:</span> <span class="p">()})</span>
    <span class="c1"># Check if axes is iterable, if not, put it in a list</span>
    <span class="n">axes_flat</span> <span class="o">=</span> <span class="n">axes</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">axes</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="k">else</span> <span class="p">[</span><span class="n">axes</span><span class="p">]</span>
    <span class="k">for</span> <span class="n">image</span><span class="p">,</span> <span class="n">label</span><span class="p">,</span> <span class="n">ax</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">X_people</span><span class="p">[</span><span class="n">mask</span><span class="p">],</span> <span class="n">y_people</span><span class="p">[</span><span class="n">mask</span><span class="p">],</span> <span class="n">axes_flat</span><span class="p">):</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">image</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">image_shape</span><span class="p">),</span> <span class="n">vmin</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">vmax</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="s1">&#39;gray&#39;</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="n">people</span><span class="o">.</span><span class="n">target_names</span><span class="p">[</span><span class="n">label</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">()[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
    <span class="c1"># Hide unused subplots if n_images &lt; number of subplots created</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_images</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">axes_flat</span><span class="p">)):</span>
        <span class="n">axes_flat</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">set_visible</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../_images/0bf9aa6966f21dbf02d9d8afb4b094e4ab1ee2f1f6b77328ce24d81436f54d0e.png" src="../_images/0bf9aa6966f21dbf02d9d8afb4b094e4ab1ee2f1f6b77328ce24d81436f54d0e.png" />
</div>
</div>
<p><strong>Hình 3-42. Các cụm được tìm thấy bởi DBSCAN với <span class="math notranslate nohighlight">\(eps=7\)</span></strong></p>
<p>Một số cụm tương ứng với những người có khuôn mặt rất khác biệt (trong tập dữ liệu này), chẳng hạn như Sharon hoặc Koizumi. Trong mỗi cụm, hướng của khuôn mặt cũng khá cố định, cũng như biểu cảm trên khuôn mặt. Một số cụm chứa khuôn mặt của nhiều người, nhưng họ có cùng hướng và biểu cảm tương tự. Điều này kết thúc phân tích của chúng ta về thuật toán DBSCAN được áp dụng cho tập dữ liệu khuôn mặt. Như bạn có thể thấy, chúng ta đang thực hiện một phân tích thủ công ở đây, khác với phương pháp tìm kiếm tự động hơn nhiều mà chúng ta có thể sử dụng cho học có giám sát dựa trên điểm <span class="math notranslate nohighlight">\(R^2\)</span> hoặc độ chính xác. Hãy chuyển sang áp dụng k-means và phân cụm gộp.</p>
</section>
<section id="phan-tich-tap-du-lieu-khuon-mat-voi-k-means">
<h5>Phân tích tập dữ liệu khuôn mặt với k-means<a class="headerlink" href="#phan-tich-tap-du-lieu-khuon-mat-voi-k-means" title="Link to this heading">#</a></h5>
<p>Chúng ta đã thấy rằng không thể tạo ra nhiều hơn một cụm lớn bằng DBSCAN. Phân cụm gộp và k-means có nhiều khả năng tạo ra các cụm có kích thước đồng đều hơn, nhưng chúng ta cần đặt một số lượng cụm mục tiêu. Chúng ta có thể đặt số lượng cụm thành số người đã biết trong tập dữ liệu, mặc dù rất khó có khả năng một thuật toán phân cụm không giám sát sẽ khôi phục chúng. Thay vào đó, chúng ta có thể bắt đầu với một số lượng cụm thấp, như 10, điều này có thể cho phép chúng ta phân tích từng cụm:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span><span class="w"> </span><span class="nn">sklearn.cluster</span><span class="w"> </span><span class="kn">import</span> <span class="n">KMeans</span>
<span class="c1"># trích xuất các cụm với k-means</span>
<span class="n">km</span> <span class="o">=</span> <span class="n">KMeans</span><span class="p">(</span><span class="n">n_clusters</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">n_init</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
<span class="n">labels_km</span> <span class="o">=</span> <span class="n">km</span><span class="o">.</span><span class="n">fit_predict</span><span class="p">(</span><span class="n">X_pca</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Cluster sizes k-means: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">bincount</span><span class="p">(</span><span class="n">labels_km</span><span class="p">)))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stderr highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>c:\Users\Admin\anaconda3\envs\tf-gpu\lib\site-packages\sklearn\cluster\_kmeans.py:1334: UserWarning: KMeans is known to have a memory leak on Windows with MKL, when there are less chunks than available threads. You can avoid it by setting the environment variable OMP_NUM_THREADS=9.
  warnings.warn(
</pre></div>
</div>
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Cluster sizes k-means: [ 94  91 270 222 119 331 119 220 495 102]
</pre></div>
</div>
</div>
</div>
<p>Như bạn có thể thấy, phân cụm k-means đã phân chia dữ liệu thành các cụm có kích thước tương đối tương tự từ 64 đến 386. Điều này khá khác với kết quả của DBSCAN.</p>
<p>Chúng ta có thể phân tích thêm kết quả của k-means bằng cách trực quan hóa các tâm cụm (Hình 3-43). Vì chúng ta đã phân cụm trong biểu diễn được tạo ra bởi PCA, chúng ta cần xoay các tâm cụm trở lại không gian ban đầu để trực quan hóa chúng, bằng cách sử dụng <code class="docutils literal notranslate"><span class="pre">pca.inverse_transform</span></code>:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">fig</span><span class="p">,</span> <span class="n">axes</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="n">subplot_kw</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;xticks&#39;</span><span class="p">:</span> <span class="p">(),</span> <span class="s1">&#39;yticks&#39;</span><span class="p">:</span> <span class="p">()},</span>
                       <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">12</span><span class="p">,</span> <span class="mi">4</span><span class="p">))</span>
<span class="k">for</span> <span class="n">center</span><span class="p">,</span> <span class="n">ax</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">km</span><span class="o">.</span><span class="n">cluster_centers_</span><span class="p">,</span> <span class="n">axes</span><span class="o">.</span><span class="n">ravel</span><span class="p">()):</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">pca</span><span class="o">.</span><span class="n">inverse_transform</span><span class="p">(</span><span class="n">center</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">image_shape</span><span class="p">),</span>
              <span class="n">vmin</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">vmax</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="s1">&#39;gray&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../_images/543b69a7a0ce5b5f4072225fcf6f826678d8e496485a2be89eb1dbf9c1d3d7c5.png" src="../_images/543b69a7a0ce5b5f4072225fcf6f826678d8e496485a2be89eb1dbf9c1d3d7c5.png" />
</div>
</div>
<p><strong>Hình 3-43. Các tâm cụm được tìm thấy bởi k-means khi đặt số lượng cụm là 10</strong></p>
<p>Các tâm cụm được tìm thấy bởi k-means là các phiên bản rất mịn của khuôn mặt. Điều này không có gì đáng ngạc nhiên, vì mỗi tâm là trung bình của 64 đến 386 hình ảnh khuôn mặt. Việc làm việc với một biểu diễn PCA đã giảm làm tăng thêm độ mịn của hình ảnh (so với các khuôn mặt được tái tạo bằng 100 chiều PCA trong Hình 3-11). Việc phân cụm dường như nhận ra các hướng khác nhau của khuôn mặt, các biểu cảm khác nhau (tâm cụm thứ ba dường như cho thấy một khuôn mặt đang cười), và sự hiện diện của cổ áo sơ mi (xem tâm cụm gần cuối). Để có cái nhìn chi tiết hơn, trong Hình 3-44, chúng ta hiển thị cho mỗi tâm cụm năm hình ảnh điển hình nhất trong cụm (các hình ảnh được gán cho cụm gần nhất với tâm cụm) và năm hình ảnh không điển hình nhất trong cụm (các hình ảnh được gán cho cụm xa nhất so với tâm cụm):</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span><span class="w"> </span><span class="nn">mglearn</span>
<span class="n">mglearn</span><span class="o">.</span><span class="n">plots</span><span class="o">.</span><span class="n">plot_kmeans_faces</span><span class="p">(</span><span class="n">km</span><span class="p">,</span> <span class="n">pca</span><span class="p">,</span> <span class="n">X_pca</span><span class="p">,</span> <span class="n">X_people</span><span class="p">,</span>
                                <span class="n">y_people</span><span class="p">,</span> <span class="n">people</span><span class="o">.</span><span class="n">target_names</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../_images/ede2f273e2eb0c5b3d6cbe2a4785384513d7a38d7bcd3720752fd06b8dd86091.png" src="../_images/ede2f273e2eb0c5b3d6cbe2a4785384513d7a38d7bcd3720752fd06b8dd86091.png" />
</div>
</div>
<p><strong>Hình 3-44. Các hình ảnh mẫu cho mỗi cụm được tìm thấy bởi k-means—các tâm cụm ở bên trái, tiếp theo là năm điểm gần nhất với mỗi tâm và năm điểm được gán cho cụm nhưng ở xa tâm nhất</strong></p>
<p>Hình 3-44 xác nhận trực giác của chúng ta về các khuôn mặt cười cho cụm thứ ba, và cũng là tầm quan trọng của hướng cho các cụm khác. Tuy nhiên, các điểm “không điển hình” không quá giống với các tâm cụm, và việc gán của chúng có vẻ hơi tùy tiện. Điều này có thể được cho là do k-means phân vùng tất cả các điểm dữ liệu và không có khái niệm về các điểm “nhiễu”, như DBSCAN. Sử dụng một số lượng cụm lớn hơn, thuật toán có thể tìm thấy các sự khác biệt tinh vi hơn. Tuy nhiên, việc thêm nhiều cụm hơn làm cho việc kiểm tra thủ công trở nên khó khăn hơn.</p>
</section>
<section id="phan-tich-tap-du-lieu-khuon-mat-voi-phan-cum-gop">
<h5>Phân tích tập dữ liệu khuôn mặt với phân cụm gộp<a class="headerlink" href="#phan-tich-tap-du-lieu-khuon-mat-voi-phan-cum-gop" title="Link to this heading">#</a></h5>
<p>Bây giờ, hãy xem kết quả của phân cụm gộp:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span><span class="w"> </span><span class="nn">sklearn.cluster</span><span class="w"> </span><span class="kn">import</span> <span class="n">AgglomerativeClustering</span>
<span class="c1"># trích xuất các cụm với phân cụm gộp ward</span>
<span class="n">agglomerative</span> <span class="o">=</span> <span class="n">AgglomerativeClustering</span><span class="p">(</span><span class="n">n_clusters</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
<span class="n">labels_agg</span> <span class="o">=</span> <span class="n">agglomerative</span><span class="o">.</span><span class="n">fit_predict</span><span class="p">(</span><span class="n">X_pca</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Cluster sizes agglomerative clustering: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
    <span class="n">np</span><span class="o">.</span><span class="n">bincount</span><span class="p">(</span><span class="n">labels_agg</span><span class="p">)))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Cluster sizes agglomerative clustering: [185 975 298  96 103  28  60  22 203  93]
</pre></div>
</div>
</div>
</div>
<p>Phân cụm gộp cũng tạo ra các cụm có kích thước tương đối đồng đều, với kích thước cụm từ 26 đến 623. Các cụm này không đồng đều bằng các cụm được tạo ra bởi k-means, nhưng đồng đều hơn nhiều so với các cụm được tạo ra bởi DBSCAN. Chúng ta có thể tính ARI để đo xem hai phân vùng của dữ liệu được đưa ra bởi phân cụm gộp và k-means có tương tự nhau không:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span><span class="w"> </span><span class="nn">sklearn.metrics.cluster</span><span class="w"> </span><span class="kn">import</span> <span class="n">adjusted_rand_score</span>

<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;ARI: </span><span class="si">{:.2f}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">adjusted_rand_score</span><span class="p">(</span><span class="n">labels_agg</span><span class="p">,</span> <span class="n">labels_km</span><span class="p">)))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>ARI: 0.06
</pre></div>
</div>
</div>
</div>
<p>Một ARI chỉ 0.13 có nghĩa là hai cách gán nhãn cụm <code class="docutils literal notranslate"><span class="pre">labels_agg</span></code> và <code class="docutils literal notranslate"><span class="pre">labels_km</span></code> có ít điểm chung. Điều này không có gì đáng ngạc nhiên, vì các điểm ở xa các tâm cụm dường như có ít điểm chung đối với k-means. Tiếp theo, chúng ta có thể muốn vẽ biểu đồ cây (Hình 3-45). Chúng ta sẽ giới hạn độ sâu của cây trong biểu đồ, vì việc phân nhánh xuống từng điểm dữ liệu trong số 2.063 điểm sẽ dẫn đến một biểu đồ dày đặc không thể đọc được:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span><span class="w"> </span><span class="nn">scipy.cluster.hierarchy</span><span class="w"> </span><span class="kn">import</span> <span class="n">dendrogram</span><span class="p">,</span> <span class="n">ward</span>

<span class="n">linkage_array</span> <span class="o">=</span> <span class="n">ward</span><span class="p">(</span><span class="n">X_pca</span><span class="p">)</span>
<span class="c1"># bây giờ chúng ta vẽ biểu đồ cây cho linkage_array</span>
<span class="c1"># chứa các khoảng cách giữa các cụm</span>
<span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">20</span><span class="p">,</span> <span class="mi">5</span><span class="p">))</span>
<span class="n">dendrogram</span><span class="p">(</span><span class="n">linkage_array</span><span class="p">,</span> <span class="n">p</span><span class="o">=</span><span class="mi">7</span><span class="p">,</span> <span class="n">truncate_mode</span><span class="o">=</span><span class="s1">&#39;level&#39;</span><span class="p">,</span> <span class="n">no_labels</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s2">&quot;Chỉ số mẫu&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s2">&quot;Khoảng cách cụm&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../_images/faf21cc8d1fc333505a36d1720ac6e4dcb6bc770fb61eb6e89a577b1a19674dd.png" src="../_images/faf21cc8d1fc333505a36d1720ac6e4dcb6bc770fb61eb6e89a577b1a19674dd.png" />
</div>
</div>
<p><strong>Hình 3-45. Biểu đồ cây của phân cụm gộp trên tập dữ liệu khuôn mặt</strong></p>
<p>Tạo 10 cụm, chúng ta cắt ngang cây ở trên cùng, nơi có 10 đường thẳng đứng. Trong biểu đồ cây cho dữ liệu đồ chơi được hiển thị trong Hình 3-36, bạn có thể thấy qua độ dài của các nhánh rằng hai hoặc ba cụm có thể nắm bắt dữ liệu một cách thích hợp. Đối với dữ liệu khuôn mặt, dường như không có một điểm cắt tự nhiên nào. Có một số nhánh đại diện cho các nhóm khác biệt hơn, nhưng dường như không có một số lượng cụm cụ thể nào là phù hợp. Điều này không có gì đáng ngạc nhiên, với kết quả của DBSCAN, đã cố gắng phân cụm tất cả các điểm lại với nhau. Hãy trực quan hóa 10 cụm, như chúng ta đã làm cho k-means trước đó (Hình 3-46). Lưu ý rằng không có khái niệm về tâm cụm trong phân cụm gộp (mặc dù chúng ta có thể tính giá trị trung bình), và chúng ta chỉ đơn giản hiển thị một vài điểm đầu tiên trong mỗi cụm. Chúng ta hiển thị số lượng điểm trong mỗi cụm ở bên trái của hình ảnh đầu tiên:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># This visualization might be large and take time to render.</span>
<span class="n">n_clusters</span> <span class="o">=</span> <span class="mi">10</span>
<span class="k">for</span> <span class="n">cluster</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_clusters</span><span class="p">):</span>
    <span class="n">mask</span> <span class="o">=</span> <span class="n">labels_agg</span> <span class="o">==</span> <span class="n">cluster</span>
    <span class="n">fig</span><span class="p">,</span> <span class="n">axes</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="n">subplot_kw</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;xticks&#39;</span><span class="p">:</span> <span class="p">(),</span> <span class="s1">&#39;yticks&#39;</span><span class="p">:</span> <span class="p">()},</span>
                           <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">15</span><span class="p">,</span> <span class="mi">8</span><span class="p">))</span>
    <span class="n">axes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">mask</span><span class="p">))</span>
    <span class="c1"># Limit the number of images to plot to 10 for each cluster</span>
    <span class="n">images_to_plot</span> <span class="o">=</span> <span class="n">X_people</span><span class="p">[</span><span class="n">mask</span><span class="p">][:</span><span class="mi">10</span><span class="p">]</span>
    <span class="n">labels_to_plot</span> <span class="o">=</span> <span class="n">y_people</span><span class="p">[</span><span class="n">mask</span><span class="p">][:</span><span class="mi">10</span><span class="p">]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">images_to_plot</span><span class="p">):</span>
            <span class="n">axes</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">images_to_plot</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">image_shape</span><span class="p">),</span> <span class="n">vmin</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">vmax</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="s1">&#39;gray&#39;</span><span class="p">)</span>
            <span class="n">axes</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="n">people</span><span class="o">.</span><span class="n">target_names</span><span class="p">[</span><span class="n">labels_to_plot</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span><span class="o">.</span><span class="n">split</span><span class="p">()[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span>
                            <span class="n">fontdict</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;fontsize&#39;</span><span class="p">:</span> <span class="mi">9</span><span class="p">})</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">axes</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">set_visible</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span> <span class="c1"># Hide unused subplots</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../_images/6c0f333ecc50c0804894a000e333e1ee601ba8a32ac436b725df3cb07cfc6460.png" src="../_images/6c0f333ecc50c0804894a000e333e1ee601ba8a32ac436b725df3cb07cfc6460.png" />
<img alt="../_images/c20e032df64c748c3e7f6e2741b2df8b574e07665e2760fb953045415869b44a.png" src="../_images/c20e032df64c748c3e7f6e2741b2df8b574e07665e2760fb953045415869b44a.png" />
<img alt="../_images/c570e4d4c8ba0238c94d3dd5627fb5a8784aacbf823bdbe72cd2082cba31251f.png" src="../_images/c570e4d4c8ba0238c94d3dd5627fb5a8784aacbf823bdbe72cd2082cba31251f.png" />
<img alt="../_images/1bd121a4f9071aafcff207e475974c8cfc930b719b0d45891d36989ab64e359c.png" src="../_images/1bd121a4f9071aafcff207e475974c8cfc930b719b0d45891d36989ab64e359c.png" />
<img alt="../_images/19cebbc1e891e855b361f9294d76e5aa8ce395ec9ac71c313a31a02dee113555.png" src="../_images/19cebbc1e891e855b361f9294d76e5aa8ce395ec9ac71c313a31a02dee113555.png" />
<img alt="../_images/f127e5191d48a0098b9eb4845a151cc158c1acd18f4fcd139b10138d300deef9.png" src="../_images/f127e5191d48a0098b9eb4845a151cc158c1acd18f4fcd139b10138d300deef9.png" />
<img alt="../_images/b9b39bd9ffb478378d9714ee2dc50bac9f63b8d2282cce68ca9428115da88baa.png" src="../_images/b9b39bd9ffb478378d9714ee2dc50bac9f63b8d2282cce68ca9428115da88baa.png" />
<img alt="../_images/4c38b9d096681e33c4f290444d0231284582833d6912ffee72aa8dc4ecf1424a.png" src="../_images/4c38b9d096681e33c4f290444d0231284582833d6912ffee72aa8dc4ecf1424a.png" />
<img alt="../_images/3ead88faacf7d1434c408a5e1f48a6e17d9fabb73f69d411f2840b2d31848ecb.png" src="../_images/3ead88faacf7d1434c408a5e1f48a6e17d9fabb73f69d411f2840b2d31848ecb.png" />
<img alt="../_images/654334ba6afd97eec87d1828610cfadefcd16f048aee0329281ebc876af57e2c.png" src="../_images/654334ba6afd97eec87d1828610cfadefcd16f048aee0329281ebc876af57e2c.png" />
</div>
</div>
<p><strong>Hình 3-46. Các hình ảnh ngẫu nhiên từ các cụm được tạo ra bởi phân cụm gộp—mỗi hàng tương ứng với một cụm; số ở bên trái liệt kê số lượng hình ảnh trong mỗi cụm</strong></p>
<p>Trong khi một số cụm dường như có một chủ đề ngữ nghĩa, nhiều cụm trong số chúng quá lớn để thực sự đồng nhất. Để có được các cụm đồng nhất hơn, chúng ta có thể chạy lại thuật toán, lần này với 40 cụm, và chọn ra một số cụm đặc biệt thú vị (Hình 3-47):</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># trích xuất các cụm với phân cụm gộp ward</span>
<span class="n">agglomerative</span> <span class="o">=</span> <span class="n">AgglomerativeClustering</span><span class="p">(</span><span class="n">n_clusters</span><span class="o">=</span><span class="mi">40</span><span class="p">)</span>
<span class="n">labels_agg</span> <span class="o">=</span> <span class="n">agglomerative</span><span class="o">.</span><span class="n">fit_predict</span><span class="p">(</span><span class="n">X_pca</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;cluster sizes agglomerative clustering: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">bincount</span><span class="p">(</span><span class="n">labels_agg</span><span class="p">)))</span>

<span class="c1"># Plotting hand-picked interesting clusters</span>
<span class="n">n_clusters</span> <span class="o">=</span> <span class="mi">40</span>
<span class="k">for</span> <span class="n">cluster</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">10</span><span class="p">,</span> <span class="mi">13</span><span class="p">,</span> <span class="mi">19</span><span class="p">,</span> <span class="mi">22</span><span class="p">,</span> <span class="mi">36</span><span class="p">]:</span> <span class="c1"># các cụm &quot;thú vị&quot; được chọn thủ công</span>
    <span class="n">mask</span> <span class="o">=</span> <span class="n">labels_agg</span> <span class="o">==</span> <span class="n">cluster</span>
    <span class="n">fig</span><span class="p">,</span> <span class="n">axes</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">15</span><span class="p">,</span> <span class="n">subplot_kw</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;xticks&#39;</span><span class="p">:</span> <span class="p">(),</span> <span class="s1">&#39;yticks&#39;</span><span class="p">:</span> <span class="p">()},</span>
                           <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">15</span><span class="p">,</span> <span class="mi">8</span><span class="p">))</span>
    <span class="n">cluster_size</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">mask</span><span class="p">)</span>
    <span class="n">axes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s2">&quot;#</span><span class="si">{}</span><span class="s2">: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">cluster</span><span class="p">,</span> <span class="n">cluster_size</span><span class="p">))</span>
    
    <span class="n">images_to_plot</span> <span class="o">=</span> <span class="n">X_people</span><span class="p">[</span><span class="n">mask</span><span class="p">][:</span><span class="mi">15</span><span class="p">]</span>
    <span class="n">labels_to_plot</span> <span class="o">=</span> <span class="n">y_people</span><span class="p">[</span><span class="n">mask</span><span class="p">][:</span><span class="mi">15</span><span class="p">]</span>
    
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">15</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">images_to_plot</span><span class="p">):</span>
            <span class="n">axes</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">images_to_plot</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">image_shape</span><span class="p">),</span> <span class="n">vmin</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">vmax</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="s1">&#39;gray&#39;</span><span class="p">)</span>
            <span class="n">axes</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="n">people</span><span class="o">.</span><span class="n">target_names</span><span class="p">[</span><span class="n">labels_to_plot</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span><span class="o">.</span><span class="n">split</span><span class="p">()[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span>
                            <span class="n">fontdict</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;fontsize&#39;</span><span class="p">:</span> <span class="mi">9</span><span class="p">})</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">axes</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">set_visible</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>cluster sizes agglomerative clustering: [ 45 183  41  89 162  28  22  31  54 216  28  97 156  35  36  32  62  30
  42  16  55  29  33  63  16  31  18  31  64  60  30  29   6  36   7  27
  47  22  43  11]
</pre></div>
</div>
<img alt="../_images/322818c00d922d66b4598c1f0d30311eeea0fafbb365be4a37b091643991e080.png" src="../_images/322818c00d922d66b4598c1f0d30311eeea0fafbb365be4a37b091643991e080.png" />
<img alt="../_images/f67d561e9c19bcb890ee7b7b5f85d3666f1e4db4d91fd1eed18817b981d2b771.png" src="../_images/f67d561e9c19bcb890ee7b7b5f85d3666f1e4db4d91fd1eed18817b981d2b771.png" />
<img alt="../_images/9e7d2429d93ff4d6e431c02462cd8669f16b91e18575bf1c9e502374ef0102f0.png" src="../_images/9e7d2429d93ff4d6e431c02462cd8669f16b91e18575bf1c9e502374ef0102f0.png" />
<img alt="../_images/f4bbcaaf7b78f56d3f4341c20630ffb6f5442dc8ae2c1aa8c68d578a64c7be62.png" src="../_images/f4bbcaaf7b78f56d3f4341c20630ffb6f5442dc8ae2c1aa8c68d578a64c7be62.png" />
<img alt="../_images/460bf540d73168be656b03fd3d791bd2e62e2630b1937c1b419ade2e0a788d5a.png" src="../_images/460bf540d73168be656b03fd3d791bd2e62e2630b1937c1b419ade2e0a788d5a.png" />
</div>
</div>
<p><strong>Hình 3-47. Các hình ảnh từ các cụm được chọn được tìm thấy bởi phân cụm gộp khi đặt số lượng cụm là 40—văn bản ở bên trái hiển thị chỉ số của cụm và tổng số điểm trong cụm</strong></p>
<p>Ở đây, việc phân cụm dường như đã nhận ra “da ngăm và cười”, “áo sơ mi có cổ”, “người phụ nữ đang cười”, “Hussein”, và “trán cao”. Chúng ta cũng có thể tìm thấy các cụm rất giống nhau này bằng cách sử dụng biểu đồ cây, nếu chúng ta phân tích chi tiết hơn.</p>
</section>
</section>
</section>
<section id="tom-tat-cac-phuong-phap-phan-cum">
<h3>Tóm tắt các Phương pháp Phân cụm<a class="headerlink" href="#tom-tat-cac-phuong-phap-phan-cum" title="Link to this heading">#</a></h3>
<p>Phần này đã cho thấy rằng việc áp dụng và đánh giá phân cụm là một quy trình định tính cao, và thường hữu ích nhất trong giai đoạn khám phá của phân tích dữ liệu. Chúng ta đã xem xét ba thuật toán phân cụm: k-means, DBSCAN, và phân cụm gộp. Cả ba đều có một cách để kiểm soát độ chi tiết của phân cụm. k-means và phân cụm gộp cho phép bạn chỉ định số lượng cụm mong muốn, trong khi DBSCAN cho phép bạn xác định sự gần gũi bằng cách sử dụng tham số <code class="docutils literal notranslate"><span class="pre">eps</span></code>, gián tiếp ảnh hưởng đến kích thước cụm. Cả ba phương pháp đều có thể được sử dụng trên các tập dữ liệu thực tế lớn, tương đối dễ hiểu, và cho phép phân cụm thành nhiều cụm.</p>
<p>Mỗi thuật toán có những điểm mạnh hơi khác nhau. k-means cho phép mô tả các cụm bằng cách sử dụng các trung bình của cụm. Nó cũng có thể được xem như một phương pháp phân rã, trong đó mỗi điểm dữ liệu được biểu diễn bằng tâm cụm của nó. DBSCAN cho phép phát hiện các “điểm nhiễu” không được gán cho bất kỳ cụm nào, và nó có thể giúp tự động xác định số lượng cụm. Trái ngược với hai phương pháp kia, nó cho phép các hình dạng cụm phức tạp, như chúng ta đã thấy trong ví dụ <code class="docutils literal notranslate"><span class="pre">two_moons</span></code>. DBSCAN đôi khi tạo ra các cụm có kích thước rất khác nhau, có thể là một điểm mạnh hoặc một điểm yếu. Phân cụm gộp có thể cung cấp toàn bộ hệ thống phân cấp các phân vùng có thể có của dữ liệu, có thể được kiểm tra dễ dàng thông qua các biểu đồ cây.</p>
</section>
</section>
<section id="tom-tat-va-trien-vong">
<h2>Tóm tắt và Triển vọng<a class="headerlink" href="#tom-tat-va-trien-vong" title="Link to this heading">#</a></h2>
<p>Chương này đã giới thiệu một loạt các thuật toán học không giám sát có thể được áp dụng cho phân tích dữ liệu khám phá và tiền xử lý. Việc có biểu diễn đúng của dữ liệu thường rất quan trọng để học có giám sát hoặc không giám sát thành công, và các phương pháp tiền xử lý và phân rã đóng một vai trò quan trọng trong việc chuẩn bị dữ liệu.</p>
<p>Phân rã, học đa tạp, và phân cụm là những công cụ thiết yếu để hiểu sâu hơn về dữ liệu của bạn, và có thể là cách duy nhất để hiểu được dữ liệu của bạn khi không có thông tin giám sát. Ngay cả trong một môi trường có giám sát, các công cụ khám phá cũng quan trọng để hiểu rõ hơn về các thuộc tính của dữ liệu. Thường thì rất khó để định lượng tính hữu dụng của một thuật toán không giám sát, mặc dù điều này không nên ngăn cản bạn sử dụng chúng để thu thập thông tin chi tiết từ dữ liệu của bạn.</p>
<p>Với những phương pháp này trong tay, bây giờ bạn đã được trang bị tất cả các thuật toán học thiết yếu mà các nhà thực hành học máy sử dụng hàng ngày. Chúng tôi khuyến khích bạn thử các phương pháp phân cụm và phân rã trên cả dữ liệu đồ chơi hai chiều và trên các tập dữ liệu thực tế được bao gồm trong scikit-learn, như các tập dữ liệu digits, iris, và cancer.</p>
<section id="tom-tat-giao-dien-estimator">
<h3>Tóm tắt Giao diện Estimator<a class="headerlink" href="#tom-tat-giao-dien-estimator" title="Link to this heading">#</a></h3>
<p>Hãy xem lại ngắn gọn API mà chúng ta đã giới thiệu trong Chương 2 và 3. Tất cả các thuật toán trong scikit-learn, dù là tiền xử lý, học có giám sát, hay thuật toán học không giám sát, đều được triển khai dưới dạng các lớp. Các lớp này được gọi là các estimator trong scikit-learn. Để áp dụng một thuật toán, trước tiên bạn phải khởi tạo một đối tượng của lớp cụ thể đó:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span><span class="w"> </span><span class="nn">sklearn.linear_model</span><span class="w"> </span><span class="kn">import</span> <span class="n">LogisticRegression</span>
<span class="n">logreg</span> <span class="o">=</span> <span class="n">LogisticRegression</span><span class="p">()</span>
</pre></div>
</div>
</div>
</div>
<p>Lớp estimator chứa thuật toán, và cũng lưu trữ mô hình được học từ dữ liệu bằng thuật toán đó. Bạn nên đặt bất kỳ tham số nào của mô hình khi xây dựng đối tượng mô hình. Các tham số này bao gồm điều chuẩn, kiểm soát độ phức tạp, số lượng cụm cần tìm, v.v. Tất cả các estimator đều có một phương thức <code class="docutils literal notranslate"><span class="pre">fit</span></code>, được sử dụng để xây dựng mô hình. Phương thức <code class="docutils literal notranslate"><span class="pre">fit</span></code> luôn yêu cầu đối số đầu tiên của nó là dữ liệu <code class="docutils literal notranslate"><span class="pre">X</span></code>, được biểu diễn dưới dạng một mảng NumPy hoặc một ma trận thưa SciPy, trong đó mỗi hàng đại diện cho một điểm dữ liệu duy nhất. Dữ liệu <code class="docutils literal notranslate"><span class="pre">X</span></code> luôn được giả định là một mảng NumPy hoặc ma trận thưa SciPy có các mục nhập liên tục (số thực dấu phẩy động).</p>
<p>Các thuật toán có giám sát cũng yêu cầu một đối số <code class="docutils literal notranslate"><span class="pre">y</span></code>, là một mảng NumPy một chiều chứa các giá trị mục tiêu cho hồi quy hoặc phân loại (tức là, các nhãn hoặc phản hồi đầu ra đã biết).</p>
<p>Có hai cách chính để áp dụng một mô hình đã học trong scikit-learn. Để tạo một dự đoán dưới dạng một đầu ra mới như <code class="docutils literal notranslate"><span class="pre">y</span></code>, bạn sử dụng phương thức <code class="docutils literal notranslate"><span class="pre">predict</span></code>. Để tạo một biểu diễn mới của dữ liệu đầu vào <code class="docutils literal notranslate"><span class="pre">X</span></code>, bạn sử dụng phương thức <code class="docutils literal notranslate"><span class="pre">transform</span></code>. Bảng 3-1 tóm tắt các trường hợp sử dụng của các phương thức <code class="docutils literal notranslate"><span class="pre">predict</span></code> và <code class="docutils literal notranslate"><span class="pre">transform</span></code>.</p>
<p><strong>Bảng 3-1. Tóm tắt API scikit-learn</strong></p>
<div class="pst-scrollable-table-container"><table class="table">
<thead>
<tr class="row-odd"><th class="head text-left"><p></p></th>
<th class="head text-left"><p><code class="docutils literal notranslate"><span class="pre">estimator.fit(X_train,</span> <span class="pre">[y_train])</span></code></p></th>
<th class="head text-left"><p><code class="docutils literal notranslate"><span class="pre">estimator.predict(X_test)</span></code></p></th>
<th class="head text-left"><p><code class="docutils literal notranslate"><span class="pre">estimator.transform(X_test)</span></code></p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td class="text-left"><p><strong>Phân loại</strong></p></td>
<td class="text-left"><p>Xây dựng mô hình</p></td>
<td class="text-left"><p>Dự đoán nhãn lớp</p></td>
<td class="text-left"><p></p></td>
</tr>
<tr class="row-odd"><td class="text-left"><p><strong>Hồi quy</strong></p></td>
<td class="text-left"><p>Xây dựng mô hình</p></td>
<td class="text-left"><p>Dự đoán giá trị mục tiêu</p></td>
<td class="text-left"><p></p></td>
</tr>
<tr class="row-even"><td class="text-left"><p><strong>Phân cụm</strong></p></td>
<td class="text-left"><p>Xây dựng mô hình</p></td>
<td class="text-left"><p>Dự đoán nhãn cụm</p></td>
<td class="text-left"><p>Khoảng cách đến tâm cụm</p></td>
</tr>
<tr class="row-odd"><td class="text-left"><p><strong>Tiền xử lý</strong></p></td>
<td class="text-left"><p>Tìm tham số</p></td>
<td class="text-left"><p></p></td>
<td class="text-left"><p>Áp dụng biến đổi</p></td>
</tr>
<tr class="row-even"><td class="text-left"><p><strong>Giảm chiều</strong></p></td>
<td class="text-left"><p>Tìm tham số</p></td>
<td class="text-left"><p></p></td>
<td class="text-left"><p>Giảm chiều</p></td>
</tr>
<tr class="row-odd"><td class="text-left"><p><strong>Trích xuất Đặc trưng</strong></p></td>
<td class="text-left"><p>Tìm tham số</p></td>
<td class="text-left"><p></p></td>
<td class="text-left"><p>Trích xuất đặc trưng</p></td>
</tr>
</tbody>
</table>
</div>
<p>Ngoài ra, tất cả các mô hình có giám sát đều có một phương thức <code class="docutils literal notranslate"><span class="pre">score(X_test,</span> <span class="pre">y_test)</span></code> cho phép đánh giá mô hình. Trong Bảng 3-1, <code class="docutils literal notranslate"><span class="pre">X_train</span></code> và <code class="docutils literal notranslate"><span class="pre">y_train</span></code> đề cập đến dữ liệu huấn luyện và nhãn huấn luyện, trong khi <code class="docutils literal notranslate"><span class="pre">X_test</span></code> và <code class="docutils literal notranslate"><span class="pre">y_test</span></code> đề cập đến dữ liệu kiểm tra và nhãn kiểm tra (nếu có).</p>
</section>
</section>
</section>

    <script type="text/x-thebe-config">
    {
        requestKernel: true,
        binderOptions: {
            repo: "binder-examples/jupyter-stacks-datascience",
            ref: "master",
        },
        codeMirrorConfig: {
            theme: "abcdef",
            mode: "python"
        },
        kernelOptions: {
            name: "python3",
            path: "./chapters"
        },
        predefinedOutput: true
    }
    </script>
    <script>kernelName = 'python3'</script>

                </article>
              

              
              
              
              
                <footer class="prev-next-footer d-print-none">
                  
<div class="prev-next-area">
    <a class="left-prev"
       href="chapter12-Supervised.html"
       title="previous page">
      <i class="fa-solid fa-angle-left"></i>
      <div class="prev-next-info">
        <p class="prev-next-subtitle">previous</p>
        <p class="prev-next-title">Chương 12: Các mô hình học máy có giám sát</p>
      </div>
    </a>
    <a class="right-next"
       href="../practice-exercises/chapter1-basics-practice.html"
       title="next page">
      <div class="prev-next-info">
        <p class="prev-next-subtitle">next</p>
        <p class="prev-next-title">Python Basics</p>
      </div>
      <i class="fa-solid fa-angle-right"></i>
    </a>
</div>
                </footer>
              
            </div>
            
            
              
                <div class="bd-sidebar-secondary bd-toc"><div class="sidebar-secondary-items sidebar-secondary__inner">


  <div class="sidebar-secondary-item">
  <div class="page-toc tocsection onthispage">
    <i class="fa-solid fa-list"></i> Contents
  </div>
  <nav class="bd-toc-nav page-toc">
    <ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#cac-loai-hoc-khong-giam-sat">Các loại Học không giám sát</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#nhung-thach-thuc-trong-hoc-khong-giam-sat">Những thách thức trong Học không giám sát</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#tien-xu-ly-va-co-gian-du-lieu">Tiền xử lý và Co giãn dữ liệu</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#cac-loai-tien-xu-ly-khac-nhau">Các loại Tiền xử lý khác nhau</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#ap-dung-cac-phep-bien-doi-du-lieu">Áp dụng các Phép biến đổi Dữ liệu</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#co-gian-du-lieu-huan-luyen-va-kiem-tra-theo-cung-mot-cach">Co giãn Dữ liệu Huấn luyện và Kiểm tra theo cùng một cách</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#cac-phuong-phap-tat-va-cac-lua-chon-thay-the-hieu-qua">Các phương pháp tắt và các lựa chọn thay thế hiệu quả</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#anh-huong-cua-tien-xu-ly-den-hoc-co-giam-sat">Ảnh hưởng của Tiền xử lý đến Học có giám sát</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#giam-chieu-trich-xuat-dac-trung-va-hoc-da-tap-manifold-learning">Giảm chiều, Trích xuất Đặc trưng, và Học Đa tạp (Manifold Learning)</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#phan-tich-thanh-phan-chinh-pca">Phân tích Thành phần Chính (PCA)</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#ap-dung-pca-cho-tap-du-lieu-ung-thu-de-truc-quan-hoa">Áp dụng PCA cho tập dữ liệu ung thư để trực quan hóa</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#cac-khuon-mat-dac-trung-eigenfaces-de-trich-xuat-dac-trung">Các khuôn mặt đặc trưng (Eigenfaces) để trích xuất đặc trưng</a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#phan-ra-ma-tran-khong-am-nmf">Phân rã Ma trận không âm (NMF)</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#ap-dung-nmf-cho-du-lieu-tong-hop">Áp dụng NMF cho dữ liệu tổng hợp</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#ap-dung-nmf-cho-hinh-anh-khuon-mat">Áp dụng NMF cho hình ảnh khuôn mặt</a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#hoc-da-tap-manifold-learning-voi-t-sne">Học Đa tạp (Manifold Learning) với t-SNE</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#phan-cum">Phân cụm</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#phan-cum-k-means">Phân cụm k-Means</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#cac-truong-hop-that-bai-cua-k-means">Các trường hợp thất bại của k-means</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#luong-tu-hoa-vector-hay-xem-k-means-nhu-la-mot-phuong-phap-phan-ra">Lượng tử hóa vector, hay xem k-means như là một phương pháp phân rã</a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#phan-cum-gop-agglomerative-clustering">Phân cụm Gộp (Agglomerative Clustering)</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#phan-cum-phan-cap-va-bieu-do-cay-dendrogram">Phân cụm phân cấp và biểu đồ cây (dendrogram)</a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#dbscan">DBSCAN</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#so-sanh-va-danh-gia-cac-thuat-toan-phan-cum">So sánh và Đánh giá các Thuật toán Phân cụm</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#danh-gia-phan-cum-voi-su-that-ngam-dinh-ground-truth">Đánh giá phân cụm với sự thật ngầm định (ground truth)</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#danh-gia-phan-cum-khong-co-su-that-ngam-dinh-ground-truth">Đánh giá phân cụm không có sự thật ngầm định (ground truth)</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#so-sanh-cac-thuat-toan-tren-tap-du-lieu-khuon-mat">So sánh các thuật toán trên tập dữ liệu khuôn mặt</a><ul class="nav section-nav flex-column">
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#phan-tich-tap-du-lieu-khuon-mat-voi-dbscan">Phân tích tập dữ liệu khuôn mặt với DBSCAN</a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#phan-tich-tap-du-lieu-khuon-mat-voi-k-means">Phân tích tập dữ liệu khuôn mặt với k-means</a></li>
<li class="toc-h5 nav-item toc-entry"><a class="reference internal nav-link" href="#phan-tich-tap-du-lieu-khuon-mat-voi-phan-cum-gop">Phân tích tập dữ liệu khuôn mặt với phân cụm gộp</a></li>
</ul>
</li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#tom-tat-cac-phuong-phap-phan-cum">Tóm tắt các Phương pháp Phân cụm</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#tom-tat-va-trien-vong">Tóm tắt và Triển vọng</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#tom-tat-giao-dien-estimator">Tóm tắt Giao diện Estimator</a></li>
</ul>
</li>
</ul>
  </nav></div>

</div></div>
              
            
          </div>
          <footer class="bd-footer-content">
            
<div class="bd-footer-content__inner container">
  
  <div class="footer-item">
    
<p class="component-author">
By Trường Công nghệ, Đại học Kinh tế Quốc dân
</p>

  </div>
  
  <div class="footer-item">
    

  <p class="copyright">
    
      © Copyright 2025.
      <br/>
    
  </p>

  </div>
  
  <div class="footer-item">
    
  </div>
  
  <div class="footer-item">
    
  </div>
  
</div>
          </footer>
        

      </main>
    </div>
  </div>
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script src="../_static/scripts/bootstrap.js?digest=dfe6caa3a7d634c4db9b"></script>
<script src="../_static/scripts/pydata-sphinx-theme.js?digest=dfe6caa3a7d634c4db9b"></script>

  <footer class="bd-footer">
  </footer>
  </body>
</html>